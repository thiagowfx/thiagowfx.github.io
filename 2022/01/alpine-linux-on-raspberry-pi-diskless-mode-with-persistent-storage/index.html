<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage | not just serendipity</title><meta name=title content="Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage">
<meta name=description content="Use case: Given an Alpine Linux diskless1 installation meant for
a Raspberry Pi setup, we would like to add a persistent storage component to it
to make it survive across reboots.
Goal
The Alpine Linux Wiki covers most of the installation process, hence I will only document the bits that were lacking and/or confusing therein.
My use case is the following:

Given a Raspberry Pi 3B with an old 4GiB SD Card as CF storage2, install Alpine Linux in diskless mode. Find a way to preserve modifications in /etc and /var, as well as any installed packages through its apk package manager."><meta name=keywords content="linux,selfhosted,bestof★,"><meta property="og:url" content="https://perrotta.dev/2022/01/alpine-linux-on-raspberry-pi-diskless-mode-with-persistent-storage/"><meta property="og:site_name" content="not just serendipity"><meta property="og:title" content="Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage"><meta property="og:description" content="Use case: Given an Alpine Linux diskless1 installation meant for a Raspberry Pi setup, we would like to add a persistent storage component to it to make it survive across reboots.
Goal The Alpine Linux Wiki covers most of the installation process, hence I will only document the bits that were lacking and/or confusing therein.
My use case is the following:
Given a Raspberry Pi 3B with an old 4GiB SD Card as CF storage2, install Alpine Linux in diskless mode. Find a way to preserve modifications in /etc and /var, as well as any installed packages through its apk package manager."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-15T23:18:56-05:00"><meta property="article:modified_time" content="2022-01-15T23:18:56-05:00"><meta property="article:tag" content="Linux"><meta property="article:tag" content="Selfhosted"><meta property="article:tag" content="Bestof★"><meta name=twitter:card content="summary"><meta name=twitter:title content="Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage"><meta name=twitter:description content="Use case: Given an Alpine Linux diskless1 installation meant for a Raspberry Pi setup, we would like to add a persistent storage component to it to make it survive across reboots.
Goal The Alpine Linux Wiki covers most of the installation process, hence I will only document the bits that were lacking and/or confusing therein.
My use case is the following:
Given a Raspberry Pi 3B with an old 4GiB SD Card as CF storage2, install Alpine Linux in diskless mode. Find a way to preserve modifications in /etc and /var, as well as any installed packages through its apk package manager."><meta itemprop=name content="Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage"><meta itemprop=description content="Use case: Given an Alpine Linux diskless1 installation meant for a Raspberry Pi setup, we would like to add a persistent storage component to it to make it survive across reboots.
Goal The Alpine Linux Wiki covers most of the installation process, hence I will only document the bits that were lacking and/or confusing therein.
My use case is the following:
Given a Raspberry Pi 3B with an old 4GiB SD Card as CF storage2, install Alpine Linux in diskless mode. Find a way to preserve modifications in /etc and /var, as well as any installed packages through its apk package manager."><meta itemprop=datePublished content="2022-01-15T23:18:56-05:00"><meta itemprop=dateModified content="2022-01-15T23:18:56-05:00"><meta itemprop=wordCount content="1596"><meta itemprop=keywords content="Linux,Selfhosted,Bestof★"><meta name=referrer content="no-referrer-when-downgrade"><link rel="shortcut icon" href=https://perrotta.dev/favicon.ico><link rel=canonical href=https://perrotta.dev/><style>body{font-family:crimson pro,vollkorn,alegreya,iowan old style,apple garamond,baskerville,times new roman,noto serif,droid serif,times,source serif pro,serif,apple color emoji,segoe ui emoji,segoe ui symbol,noto color emoji;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fffcf0;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}h1,h2,h3,h4,h5,h6,footer,nav{font-family:inter,fira sans,lato,system-ui,-apple-system,BlinkMacSystemFont,avenir next,avenir,segoe ui,helvetica neue,Helvetica,Ubuntu,Roboto,Noto,Cantarell,Arial,sans-serif}footer{font-size:small;padding:25px;text-align:center}a{color:#3273dc}.title{text-decoration:none;border:0;display:flex;align-items:center;column-gap:10px}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}li code,p code{font-size:small}pre code{color:#222;display:block;padding:20px;white-space:pre;font-size:14px;overflow-x:auto}code,pre{font-family:fira code,pt mono,ibm plex mono,Menlo,Consolas,Monaco,liberation mono,ubuntu mono,lucida console,monospace}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 110px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#01242e;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#444}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}}</style><link rel=apple-touch-icon href=https://perrotta.dev/apple-touch-icon.png></head><body><header><a href=/ class=title><img src=https://perrotta.dev/thiagowfx.png alt="not just serendipity" style=height:2em><h2>not just serendipity</h2></a><nav><a href=/>Home</a>
<a href=/posts/>Blog</a>
<a href=/tags/bestof/>★</a></nav></header><main><h1><span>★</span>
Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage</h1><p><i><time datetime=2022-01-15 pubdate>15 Jan, 2022
</time>• 1596 words
• 8 minutes</i></p><content><p>Use case: Given an Alpine Linux <strong>diskless</strong><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> installation meant for
a Raspberry Pi setup, we would like to add a persistent storage component to it
to make it survive across reboots.</p><h2 id=goal>Goal</h2><p>The <a href=https://wiki.alpinelinux.org/wiki/Installation>Alpine Linux Wiki</a> covers most of the installation process, hence I will only document the bits that were lacking and/or confusing therein.</p><p>My use case is the following:</p><blockquote><p>Given a Raspberry Pi 3B with an old 4GiB SD Card as CF storage<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, install Alpine Linux in diskless mode. Find a way to preserve modifications in <code>/etc</code> and <code>/var</code>, as well as any installed packages through its <code>apk</code> package manager.</p></blockquote><p>Let&rsquo;s follow the steps outlined in the wiki.</p><h2 id=copy-alpine-to-the-sd-card>Copy Alpine to the SD Card</h2><blockquote><p>Grab the SD card and install Alpine Linux in it.</p></blockquote><p>Alpine provides officially supported images designed for the Raspberry Pi.</p><p>Most Linux distributions provide an <code>.iso</code> or <code>.img</code> file to be installed with a tool like <a href=https://www.balena.io/etcher/>Balena Etcher</a>, <a href=https://rufus.ie/en/>Rufus</a>, <a href=https://www.raspberrypi.com/news/raspberry-pi-imager-imaging-utility/><strong>Raspberry Pi Imager</strong></a> or plain <code>dd</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>Alpine is not like most Linux distributions: Instead, it provides a <code>.tar.gz</code> archive with files that should be copied directly to the SD card. Grab the latest version (3.15 at the time of this post) from <a href=https://alpinelinux.org/downloads/>https://alpinelinux.org/downloads/</a>. There are 3 options:</p><ul><li><p><code>armhf</code>: Works with all Pis, but may perform less optimally on recent versions.</p></li><li><p><code>armv7</code>: Works with the Pi 3B, 32-bit.</p></li><li><p><code>aarch64</code>: Works with the Pi 3B, 64-bit.</p></li></ul><p>I opted for <code>aarch64</code> to make it 64-bit, but <code>armv7</code> would also have worked well for my setup. In fact, Raspberry Pi OS (Debian) uses <code>armv7</code> (32-bit) at the time of this writing.</p><p>Before copying files over, format the SD Card. As I was doing this
from a Windows machine because it was the only one I had readily available with
a SD card slot, I just used the native Windows Disk Management tool to do so.
I decided to allocate a 100MB<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> FAT32 partition. The rest of the SD card would be
blank for now. Alpine is surprisingly small, 100MB was more than enough for the kernel and other needed files.</p><p>Once the SD card is formatted, copy the files over to it. It turns out Windows cannot extract tarballs (<code>.tar.gz</code>); a tool like <a href=https://www.7-zip.org/>7-zip</a> should do the job. Copy the files over to the root of the newly allocated FAT32 partition, and then safely eject the SD card.</p><h2 id=boot-alpine-from-the-sd-card>Boot Alpine from the SD Card</h2><p>The next step is to insert the SD Card into the Pi and then boot. I had some trouble in this step and eventually figured out I didn&rsquo;t mark the primary FAT32 partition as bootable. Unfortunately it&rsquo;s not straightforward to mark the partition as bootable from Windows. On a Linux machine there&rsquo;s a wide array of tools to do so: <code>fdisk</code>, <code>cfdisk</code> (TUI), <code>sfdisk</code> (scriptable <code>fdisk</code>), <code>parted</code>, <code>gparted</code> (GUI) are some of them. I worked around that by installing Raspberry Pi OS on the SD card with the Raspberry Pi imager, and then overwriting it with the Alpine files. This works because the Raspberry PI OS installation marks the FAT32 partition as bootable.</p><h2 id=install-alpine>Install Alpine</h2><p>Installing Alpine is well documented in the <a href=https://wiki.alpinelinux.org/wiki/Installation>wiki</a> thus it won&rsquo;t be covered here. It basically comes down to invoking <code>setup-alpine</code>, which then invokes other <code>setup-*</code> scripts.</p><p>Keep in mind we&rsquo;re not really &ldquo;installing&rdquo; Alpine as this is a diskless installation. A more accurate term here would be &ldquo;configuring&rdquo;.</p><p>Before invoking the installation script, I created a second primary partition in the SD card, set to <code>ext4</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Configure networking to get working internet access.</span>
</span></span><span style=display:flex><span>% setup-interfaces
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Install some partitioning tools.</span>
</span></span><span style=display:flex><span>% apk add cfdisk e2fsprogs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create a second partition (mmcblk0p2) and write it.</span>
</span></span><span style=display:flex><span>% cfdisk /dev/mmcblk0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Format the partition as ext4.</span>
</span></span><span style=display:flex><span>% mkfs.ext4 /dev/mmcblk0p2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Mount the partition under /media.</span>
</span></span><span style=display:flex><span>% mount /dev/mmcblk0p2 /media/mmcblk0p2
</span></span></code></pre></div><p>The installation is straightforward, we just need to pay attention to a few select steps:</p><ul><li><code>setup-disk</code>: Select <code>none</code> to ensure a <code>diskless</code> installation<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</li><li><code>setup-apkcache</code>: Select <code>/media/mmcblk0p2/cache</code> to persist downloaded <code>apk</code> packages.</li><li><code>setup-lbu</code>: Edit <code>/etc/lbu/lbu.conf</code> and set <code>LBU_MEDIA="mmcblk0p2"</code>. Note: Do not add <code>/media</code> as it is implicit.</li></ul><p>Once the installation is complete, run <code>lbu commit</code> to persist the changes in the second partition. Once you do so, a <code>&lt;hostname>.apkovl.tar.gz</code><sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> file should materialize on <code>/media/mmcblk0p2/</code>.</p><p>This is a good moment to reboot. Before we do so, let&rsquo;s cache the packages we had previously downloaded.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Cache packages.</span>
</span></span><span style=display:flex><span>% apk cache download
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>% reboot
</span></span></code></pre></div><h2 id=after-the-first-reboot>After the first reboot</h2><p>If everything worked as expected, once you reboot all your previously installed packages should have been preserved and automatically restored / reinstalled, as well as your modifications done to <code>/etc</code>.</p><p>From this point on, whenever you install a new package that you want to be preserved for subsequent reboots, run <code>lbu commit</code> afterwards. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>% apk add vim
</span></span><span style=display:flex><span>% lbu commit
</span></span></code></pre></div><p>If you would like to see what is going to be committed, run <code>lbu status</code> or <code>lbu diff</code> before doing the actual commit. Whenever you commit, <code>/media/mmcblk0p2/&lt;hostname>.apkovl.tar.gz</code> gets overwritten with your most recent modifications.</p><p>It&rsquo;s possible to keep more than one backup file by changing <code>BACKUP_LIMIT=</code> in <code>/etc/lbu/lbu.conf</code>. This is specially handy if you decide to revert to an earlier system snapshot / state later on. The stock config looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>% cat /etc/lbu/lbu.conf
</span></span><span style=display:flex><span><span style=color:#75715e># what cipher to use with -e option</span>
</span></span><span style=display:flex><span>DEFAULT_CIPHER<span style=color:#f92672>=</span>aes-256-cbc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Uncomment the row below to encrypt config by default</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ENCRYPTION=$DEFAULT_CIPHER</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Uncomment below to avoid &lt;media&gt; option to &#39;lbu commit&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Can also be set to &#39;floppy&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># LBU_MEDIA=usb</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Set the LBU_BACKUPDIR variable in case you prefer to save the apkovls</span>
</span></span><span style=display:flex><span><span style=color:#75715e># in a normal directory instead of mounting an external media.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># LBU_BACKUPDIR=/root/config-backups</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Uncomment below to let lbu make up to 3 backups</span>
</span></span><span style=display:flex><span><span style=color:#75715e># BACKUP_LIMIT=3</span>
</span></span></code></pre></div><p><strong>Tip</strong>: You can find the list of all explicitly installed packages in <code>/etc/apk/world</code>.</p><h2 id=the-last-piece-make-var-persistent>The last piece: make /var persistent</h2><p>There are three natural ways that come to mind to make <code>/var</code> persistent:</p><h3 id=a-separate-partition-or-file>A) Separate partition (or file)</h3><p>Instead of two partitions (FAT32 and ext4), create 3 partitions: FAT32, ext4 and ext4. Use the latter one to mount <code>/var</code> on, saving this information in <code>/etc/fstab</code>. The main disadvantage of this setup is that you&rsquo;ll need to allocate a fixed amount of space of each of the ext4 partitions and it may be difficult to figure out how to split the space between them.</p><p>A variant of this approach is to just create the third partition as a file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 500MB file</span>
</span></span><span style=display:flex><span>% dd <span style=color:#66d9ef>if</span><span style=color:#f92672>=</span>/dev/zero of<span style=color:#f92672>=</span>/media/mmcblk0p2/var.img bs<span style=color:#f92672>=</span>1M count<span style=color:#f92672>=</span><span style=color:#ae81ff>500</span> status<span style=color:#f92672>=</span>progress
</span></span><span style=display:flex><span>% mkfs.ext4 /media/mmcblk0p2/var.img
</span></span><span style=display:flex><span>% mount /media/mmcblk0p2/var.img /var
</span></span></code></pre></div><p>This works because the Linux kernel supports mounting files as if they were device blocks, treating them as loop devices (pseudo-devices).</p><p>I don&rsquo;t like these approaches because they shadow the preexisting <code>/var</code> from the boot media, which in turn messes up with existing services that use it such as <code>cron</code>: <code>% crontab -l</code> would fail. One workaround would be to mount a <code>/var</code> subdirectory instead: for example, <code>/var/lib/docker</code> for docker.</p><h3 id=b-bind-mount>B) Bind mount</h3><p>This one is straightforward:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>% mount --bind /media/mmcblk0p2/var/lib/docker /var/lib/docker
</span></span></code></pre></div><p>The actual partition lives in the SD card, however we make a bind mount under
<code>/var</code>, which is like an <em>alias</em>. From <a href=https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount>Stack Exchange</a>:</p><blockquote><p>A bind mount is an alternate view of a directory tree. Classically, mounting creates a view of a storage device as a directory tree. A bind mount instead takes an existing directory tree and replicates it under a different point. The directories and files in the bind mount are the same as the original. Any modification on one side is immediately reflected on the other side, since the two views show the same data.</p></blockquote><h3 id=c-overlay-mount>C) Overlay mount</h3><p>From <a href=https://wiki.archlinux.org/title/Overlay_filesystem>ArchWiki</a>:</p><blockquote><p>Overlayfs allows one, usually read-write, directory tree to be overlaid onto another, read-only directory tree. All modifications go to the upper, writable layer. This type of mechanism is most often used for live CDs but there is a wide variety of other uses.</p></blockquote><p>It&rsquo;s perfect for our use case, which uses a live bootable SD card for Alpine. It blends the preexisting, ephemeral, in-memory <code>/var</code> with the persistent in-disk <code>/var</code>.</p><p>I wanted to mount <code>/var</code> directly but found it to be problematic for the same reasons mentioned earlier, therefore I just went with <code>/var/lib/docker</code> instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Create overlay upper and work directories.</span>
</span></span><span style=display:flex><span>% mkdir -p /media/mmcblk0p2/var/lib/docker /media/mmcblk0p2/var/lib/docker-work
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Add mountpoint entry to fstab. Note: The work dir must be an empty directory in the same filesystem mount as the upper directory.</span>
</span></span><span style=display:flex><span>% echo <span style=color:#e6db74>&#34;overlay /var/lib/docker overlay lowerdir=/var/lib/docker,upperdir=/media/mmcblk0p2/var/lib/docker,workdir=/media/mmcblk0p2/var/lib/docker-work 0 0&#34;</span> &gt;&gt; /etc/fstab
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Mount all fstab entries, including our newly added one.</span>
</span></span><span style=display:flex><span>% mount -a
</span></span></code></pre></div><h2 id=conclusion>Conclusion</h2><p>I opted for the third approach, using an overlay mount, it was the most
seamless one. A bind mount would have been fine as well.</p><p>The final setup works surprisingly well:</p><ul><li>Alpine Linux is very lightweight and runs mostly from RAM</li><li><code>apk</code> cache is persistent to the ext4 partition</li><li><code>/var/</code> is persistent to the ext4 partition</li><li><code>lbu commit</code> persists changes in <code>/etc/</code> and <code>/home/</code> in the ext4 partition</li><li>Every reboot fully resets the system sans persistent components above</li></ul><h2 id=references>References</h2><ul><li><a href=https://vincentserpoul.github.io/post/alpine-linux-rpi0/>https://vincentserpoul.github.io/post/alpine-linux-rpi0/</a></li><li><a href=http://dahl-jacobsen.dk/tips/blog/2021-04-08-docker-on-alpine-linux/>http://dahl-jacobsen.dk/tips/blog/2021-04-08-docker-on-alpine-linux/</a></li><li><a href=http://dahl-jacobsen.dk/tips/blog/2018-03-15-alpine-on-raspberry-pi/>http://dahl-jacobsen.dk/tips/blog/2018-03-15-alpine-on-raspberry-pi/</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Running (almost) fully from RAM.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>CF = Compact disk.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>On Linux I&rsquo;d usually opt for <code>dd</code>, on Windows the Raspberry Pi Imager is a sensible choice.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>100MB is overly conservative, but keep in mind I had a very small SD Card, with only 4GiB storage. 250MB or even 500MB should be a more sensible default if you have a bigger SD Card (e.g. 32GiB).&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>An alternative is to select <code>data</code> disk mode, but it didn&rsquo;t work for me.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><em>ovl</em> is short for <em>overlay</em>. Not to be confused with <em>vol</em> for <em>volume</em>.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></content><p><a href=https://perrotta.dev/tags/linux/>#linux</a>
<a href=https://perrotta.dev/tags/selfhosted/>#selfhosted</a>
<a href=https://perrotta.dev/tags/bestof/>#bestof★</a></p></main><footer><span>© 2021 - 2025 <a href=mailto:tbperrotta@gmail.com>Thiago Perrotta</a> <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>Some Rights Reserved</a> · <a href=/index.xml>RSS</a> · a fork of <a href=https://github.com/janraasch/hugo-bearblog/>hugo ʕ•ᴥ•ʔ bear</a></span></footer></body></html>