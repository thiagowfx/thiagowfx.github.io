<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>★ Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage | not just serendipity</title>
<meta name=keywords content="linux,selfhosted,bestof"><meta name=description content="Use case: Given an Alpine Linux diskless1 installation meant for
a Raspberry Pi setup, we would like to add a persistent storage component to it
to make it survive across reboots."><meta name=author content="Thiago Perrotta"><link rel=canonical href=https://www.perrotta.dev/2022/01/alpine-linux-on-raspberry-pi-diskless-mode-with-persistent-storage/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://www.perrotta.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.perrotta.dev/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://www.perrotta.dev/favicon.ico><link rel=apple-touch-icon href=https://www.perrotta.dev/apple-touch-icon.png><link rel=mask-icon href=https://www.perrotta.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.perrotta.dev/2022/01/alpine-linux-on-raspberry-pi-diskless-mode-with-persistent-storage/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>body{font-family:Crimson Pro,Vollkorn,Alegreya,Iowan Old Style,Apple Garamond,Baskerville,Times New Roman,Noto Serif,Droid Serif,Times,Source Serif Pro,serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}h1,h2,h3,h4,h5,h6,footer,nav,.toc,.post-meta{font-family:Inter,Fira Sans,Lato,system-ui,-apple-system,BlinkMacSystemFont,Avenir Next,Avenir,Segoe UI,Helvetica Neue,Helvetica,Ubuntu,Roboto,Noto,Cantarell,Arial,sans-serif}code,pre{font-family:Fira Code,PT Mono,IBM Plex Mono,Menlo,Consolas,Monaco,Liberation Mono,Ubuntu Mono,Lucida Console,monospace}</style><meta property="og:title" content="★ Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage"><meta property="og:description" content="Use case: Given an Alpine Linux diskless1 installation meant for
a Raspberry Pi setup, we would like to add a persistent storage component to it
to make it survive across reboots."><meta property="og:type" content="article"><meta property="og:url" content="https://www.perrotta.dev/2022/01/alpine-linux-on-raspberry-pi-diskless-mode-with-persistent-storage/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-15T23:18:56-05:00"><meta property="article:modified_time" content="2022-01-15T23:18:56-05:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="★ Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage"><meta name=twitter:description content="Use case: Given an Alpine Linux diskless1 installation meant for
a Raspberry Pi setup, we would like to add a persistent storage component to it
to make it survive across reboots."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.perrotta.dev/posts/"},{"@type":"ListItem","position":2,"name":"★ Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage","item":"https://www.perrotta.dev/2022/01/alpine-linux-on-raspberry-pi-diskless-mode-with-persistent-storage/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"★ Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage","name":"★ Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage","description":"Use case: Given an Alpine Linux diskless1 installation meant for a Raspberry Pi setup, we would like to add a persistent storage component to it to make it survive across reboots.\n","keywords":["linux","selfhosted","bestof"],"articleBody":"Use case: Given an Alpine Linux diskless1 installation meant for a Raspberry Pi setup, we would like to add a persistent storage component to it to make it survive across reboots.\nGoal The Alpine Linux Wiki covers most of the installation process, hence I will only document the bits that were lacking and/or confusing therein.\nMy use case is the following:\nGiven a Raspberry Pi 3B with an old 4GiB SD Card as CF storage2, install Alpine Linux in diskless mode. Find a way to preserve modifications in /etc and /var, as well as any installed packages through its apk package manager.\nLet’s follow the steps outlined in the wiki.\nCopy Alpine to the SD Card Grab the SD card and install Alpine Linux in it.\nAlpine provides officially supported images designed for the Raspberry Pi.\nMost Linux distributions provide an .iso or .img file to be installed with a tool like Balena Etcher, Rufus, Raspberry Pi Imager or plain dd3.\nAlpine is not like most Linux distributions: Instead, it provides a .tar.gz archive with files that should be copied directly to the SD card. Grab the latest version (3.15 at the time of this post) from https://alpinelinux.org/downloads/. There are 3 options:\narmhf: Works with all Pis, but may perform less optimally on recent versions.\narmv7: Works with the Pi 3B, 32-bit.\naarch64: Works with the Pi 3B, 64-bit.\nI opted for aarch64 to make it 64-bit, but armv7 would also have worked well for my setup. In fact, Raspberry Pi OS (Debian) uses armv7 (32-bit) at the time of this writing.\nBefore copying files over, format the SD Card. As I was doing this from a Windows machine because it was the only one I had readily available with a SD card slot, I just used the native Windows Disk Management tool to do so. I decided to allocate a 100MB4 FAT32 partition. The rest of the SD card would be blank for now. Alpine is surprisingly small, 100MB was more than enough for the kernel and other needed files.\nOnce the SD card is formatted, copy the files over to it. It turns out Windows cannot extract tarballs (.tar.gz); a tool like 7-zip should do the job. Copy the files over to the root of the newly allocated FAT32 partition, and then safely eject the SD card.\nBoot Alpine from the SD Card The next step is to insert the SD Card into the Pi and then boot. I had some trouble in this step and eventually figured out I didn’t mark the primary FAT32 partition as bootable. Unfortunately it’s not straightforward to mark the partition as bootable from Windows. On a Linux machine there’s a wide array of tools to do so: fdisk, cfdisk (TUI), sfdisk (scriptable fdisk), parted, gparted (GUI) are some of them. I worked around that by installing Raspberry Pi OS on the SD card with the Raspberry Pi imager, and then overwriting it with the Alpine files. This works because the Raspberry PI OS installation marks the FAT32 partition as bootable.\nInstall Alpine Installing Alpine is well documented in the wiki thus it won’t be covered here. It basically comes down to invoking setup-alpine, which then invokes other setup-* scripts.\nKeep in mind we’re not really “installing” Alpine as this is a diskless installation. A more accurate term here would be “configuring”.\nBefore invoking the installation script, I created a second primary partition in the SD card, set to ext4:\n# Configure networking to get working internet access. % setup-interfaces # Install some partitioning tools. % apk add cfdisk e2fsprogs # Create a second partition (mmcblk0p2) and write it. % cfdisk /dev/mmcblk0 # Format the partition as ext4. % mkfs.ext4 /dev/mmcblk0p2 # Mount the partition under /media. % mount /dev/mmcblk0p2 /media/mmcblk0p2 The installation is straightforward, we just need to pay attention to a few select steps:\nsetup-disk: Select none to ensure a diskless installation5. setup-apkcache: Select /media/mmcblk0p2/cache to persist downloaded apk packages. setup-lbu: Edit /etc/lbu/lbu.conf and set LBU_MEDIA=\"mmcblk0p2\". Note: Do not add /media as it is implicit. Once the installation is complete, run lbu commit to persist the changes in the second partition. Once you do so, a .apkovl.tar.gz6 file should materialize on /media/mmcblk0p2/.\nThis is a good moment to reboot. Before we do so, let’s cache the packages we had previously downloaded.\n# Cache packages. % apk cache download % reboot After the first reboot If everything worked as expected, once you reboot all your previously installed packages should have been preserved and automatically restored / reinstalled, as well as your modifications done to /etc.\nFrom this point on, whenever you install a new package that you want to be preserved for subsequent reboots, run lbu commit afterwards. For example:\n% apk add vim % lbu commit If you would like to see what is going to be committed, run lbu status or lbu diff before doing the actual commit. Whenever you commit, /media/mmcblk0p2/.apkovl.tar.gz gets overwritten with your most recent modifications.\nIt’s possible to keep more than one backup file by changing BACKUP_LIMIT= in /etc/lbu/lbu.conf. This is specially handy if you decide to revert to an earlier system snapshot / state later on. The stock config looks like this:\n% cat /etc/lbu/lbu.conf # what cipher to use with -e option DEFAULT_CIPHER=aes-256-cbc # Uncomment the row below to encrypt config by default # ENCRYPTION=$DEFAULT_CIPHER # Uncomment below to avoid option to 'lbu commit' # Can also be set to 'floppy' # LBU_MEDIA=usb # Set the LBU_BACKUPDIR variable in case you prefer to save the apkovls # in a normal directory instead of mounting an external media. # LBU_BACKUPDIR=/root/config-backups # Uncomment below to let lbu make up to 3 backups # BACKUP_LIMIT=3 Tip: You can find the list of all explicitly installed packages in /etc/apk/world.\nThe last piece: make /var persistent There are three natural ways that come to mind to make /var persistent:\nA) Separate partition (or file) Instead of two partitions (FAT32 and ext4), create 3 partitions: FAT32, ext4 and ext4. Use the latter one to mount /var on, saving this information in /etc/fstab. The main disadvantage of this setup is that you’ll need to allocate a fixed amount of space of each of the ext4 partitions and it may be difficult to figure out how to split the space between them.\nA variant of this approach is to just create the third partition as a file:\n# 500MB file % dd if=/dev/zero of=/media/mmcblk0p2/var.img bs=1M count=500 status=progress % mkfs.ext4 /media/mmcblk0p2/var.img % mount /media/mmcblk0p2/var.img /var This works because the Linux kernel supports mounting files as if they were device blocks, treating them as loop devices (pseudo-devices).\nI don’t like these approaches because they shadow the preexisting /var from the boot media, which in turn messes up with existing services that use it such as cron: % crontab -l would fail. One workaround would be to mount a /var subdirectory instead: for example, /var/lib/docker for docker.\nB) Bind mount This one is straightforward:\n% mount --bind /media/mmcblk0p2/var/lib/docker /var/lib/docker The actual partition lives in the SD card, however we make a bind mount under /var, which is like an alias. From Stack Exchange:\nA bind mount is an alternate view of a directory tree. Classically, mounting creates a view of a storage device as a directory tree. A bind mount instead takes an existing directory tree and replicates it under a different point. The directories and files in the bind mount are the same as the original. Any modification on one side is immediately reflected on the other side, since the two views show the same data.\nC) Overlay mount From ArchWiki:\nOverlayfs allows one, usually read-write, directory tree to be overlaid onto another, read-only directory tree. All modifications go to the upper, writable layer. This type of mechanism is most often used for live CDs but there is a wide variety of other uses.\nIt’s perfect for our use case, which uses a live bootable SD card for Alpine. It blends the preexisting, ephemeral, in-memory /var with the persistent in-disk /var.\nI wanted to mount /var directly but found it to be problematic for the same reasons mentioned earlier, therefore I just went with /var/lib/docker instead:\n# Create overlay upper and work directories. % mkdir -p /media/mmcblk0p2/var/lib/docker /media/mmcblk0p2/var/lib/docker-work # Add mountpoint entry to fstab. Note: The work dir must be an empty directory in the same filesystem mount as the upper directory. % echo \"overlay /var/lib/docker overlay lowerdir=/var/lib/docker,upperdir=/media/mmcblk0p2/var/lib/docker,workdir=/media/mmcblk0p2/var/lib/docker-work 0 0\" \u003e\u003e /etc/fstab # Mount all fstab entries, including our newly added one. % mount -a Conclusion I opted for the third approach, using an overlay mount, it was the most seamless one. A bind mount would have been fine as well.\nThe final setup works surprisingly well:\nAlpine Linux is very lightweight and runs mostly from RAM apk cache is persistent to the ext4 partition /var/ is persistent to the ext4 partition lbu commit persists changes in /etc/ and /home/ in the ext4 partition Every reboot fully resets the system sans persistent components above References https://vincentserpoul.github.io/post/alpine-linux-rpi0/ http://dahl-jacobsen.dk/tips/blog/2021-04-08-docker-on-alpine-linux/ http://dahl-jacobsen.dk/tips/blog/2018-03-15-alpine-on-raspberry-pi/ Running (almost) fully from RAM. ↩︎\nCF = Compact disk. ↩︎\nOn Linux I’d usually opt for dd, on Windows the Raspberry Pi Imager is a sensible choice. ↩︎\n100MB is overly conservative, but keep in mind I had a very small SD Card, with only 4GiB storage. 250MB or even 500MB should be a more sensible default if you have a bigger SD Card (e.g. 32GiB). ↩︎\nAn alternative is to select data disk mode, but it didn’t work for me. ↩︎\novl is short for overlay. Not to be confused with vol for volume. ↩︎\n","wordCount":"1596","inLanguage":"en","datePublished":"2022-01-15T23:18:56-05:00","dateModified":"2022-01-15T23:18:56-05:00","author":{"@type":"Person","name":"Thiago Perrotta"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.perrotta.dev/2022/01/alpine-linux-on-raspberry-pi-diskless-mode-with-persistent-storage/"},"publisher":{"@type":"Person","name":"not just serendipity","logo":{"@type":"ImageObject","url":"https://www.perrotta.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.perrotta.dev/ accesskey=h title="not just serendipity (Alt + H)"><img src=https://www.perrotta.dev/apple-touch-icon.png alt aria-label=logo height=32>not just serendipity</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.perrotta.dev/posts/ title=posts><span>posts</span></a></li><li><a href=https://www.perrotta.dev/archives/ title=archives><span>archives</span></a></li><li><a href=https://www.perrotta.dev/tags/bestof/ title=bestof><span>bestof</span></a></li><li><a href=https://www.perrotta.dev/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://www.perrotta.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">★ Alpine Linux on Raspberry Pi: Diskless Mode with persistent storage</h1><div class=post-meta><span title='2022-01-15 23:18:56 -0500 -0500'>January 15, 2022</span>&nbsp;·&nbsp;1596 words&nbsp;·&nbsp;Thiago Perrotta</div></header><div class=post-content><p>Use case: Given an Alpine Linux <strong>diskless</strong><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> installation meant for
a Raspberry Pi setup, we would like to add a persistent storage component to it
to make it survive across reboots.</p><h2 id=goal>Goal<a hidden class=anchor aria-hidden=true href=#goal>#</a></h2><p>The <a href=https://wiki.alpinelinux.org/wiki/Installation>Alpine Linux Wiki</a> covers most of the installation process, hence I will only document the bits that were lacking and/or confusing therein.</p><p>My use case is the following:</p><blockquote><p>Given a Raspberry Pi 3B with an old 4GiB SD Card as CF storage<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>, install Alpine Linux in diskless mode. Find a way to preserve modifications in <code>/etc</code> and <code>/var</code>, as well as any installed packages through its <code>apk</code> package manager.</p></blockquote><p>Let&rsquo;s follow the steps outlined in the wiki.</p><h2 id=copy-alpine-to-the-sd-card>Copy Alpine to the SD Card<a hidden class=anchor aria-hidden=true href=#copy-alpine-to-the-sd-card>#</a></h2><blockquote><p>Grab the SD card and install Alpine Linux in it.</p></blockquote><p>Alpine provides officially supported images designed for the Raspberry Pi.</p><p>Most Linux distributions provide an <code>.iso</code> or <code>.img</code> file to be installed with a tool like <a href=https://www.balena.io/etcher/>Balena Etcher</a>, <a href=https://rufus.ie/en/>Rufus</a>, <a href=https://www.raspberrypi.com/news/raspberry-pi-imager-imaging-utility/><strong>Raspberry Pi Imager</strong></a> or plain <code>dd</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>Alpine is not like most Linux distributions: Instead, it provides a <code>.tar.gz</code> archive with files that should be copied directly to the SD card. Grab the latest version (3.15 at the time of this post) from <a href=https://alpinelinux.org/downloads/>https://alpinelinux.org/downloads/</a>. There are 3 options:</p><ul><li><p><code>armhf</code>: Works with all Pis, but may perform less optimally on recent versions.</p></li><li><p><code>armv7</code>: Works with the Pi 3B, 32-bit.</p></li><li><p><code>aarch64</code>: Works with the Pi 3B, 64-bit.</p></li></ul><p>I opted for <code>aarch64</code> to make it 64-bit, but <code>armv7</code> would also have worked well for my setup. In fact, Raspberry Pi OS (Debian) uses <code>armv7</code> (32-bit) at the time of this writing.</p><p>Before copying files over, format the SD Card. As I was doing this
from a Windows machine because it was the only one I had readily available with
a SD card slot, I just used the native Windows Disk Management tool to do so.
I decided to allocate a 100MB<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> FAT32 partition. The rest of the SD card would be
blank for now. Alpine is surprisingly small, 100MB was more than enough for the kernel and other needed files.</p><p>Once the SD card is formatted, copy the files over to it. It turns out Windows cannot extract tarballs (<code>.tar.gz</code>); a tool like <a href=https://www.7-zip.org/>7-zip</a> should do the job. Copy the files over to the root of the newly allocated FAT32 partition, and then safely eject the SD card.</p><h2 id=boot-alpine-from-the-sd-card>Boot Alpine from the SD Card<a hidden class=anchor aria-hidden=true href=#boot-alpine-from-the-sd-card>#</a></h2><p>The next step is to insert the SD Card into the Pi and then boot. I had some trouble in this step and eventually figured out I didn&rsquo;t mark the primary FAT32 partition as bootable. Unfortunately it&rsquo;s not straightforward to mark the partition as bootable from Windows. On a Linux machine there&rsquo;s a wide array of tools to do so: <code>fdisk</code>, <code>cfdisk</code> (TUI), <code>sfdisk</code> (scriptable <code>fdisk</code>), <code>parted</code>, <code>gparted</code> (GUI) are some of them. I worked around that by installing Raspberry Pi OS on the SD card with the Raspberry Pi imager, and then overwriting it with the Alpine files. This works because the Raspberry PI OS installation marks the FAT32 partition as bootable.</p><h2 id=install-alpine>Install Alpine<a hidden class=anchor aria-hidden=true href=#install-alpine>#</a></h2><p>Installing Alpine is well documented in the <a href=https://wiki.alpinelinux.org/wiki/Installation>wiki</a> thus it won&rsquo;t be covered here. It basically comes down to invoking <code>setup-alpine</code>, which then invokes other <code>setup-*</code> scripts.</p><p>Keep in mind we&rsquo;re not really &ldquo;installing&rdquo; Alpine as this is a diskless installation. A more accurate term here would be &ldquo;configuring&rdquo;.</p><p>Before invoking the installation script, I created a second primary partition in the SD card, set to <code>ext4</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Configure networking to get working internet access.</span>
</span></span><span style=display:flex><span>% setup-interfaces
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Install some partitioning tools.</span>
</span></span><span style=display:flex><span>% apk add cfdisk e2fsprogs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create a second partition (mmcblk0p2) and write it.</span>
</span></span><span style=display:flex><span>% cfdisk /dev/mmcblk0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Format the partition as ext4.</span>
</span></span><span style=display:flex><span>% mkfs.ext4 /dev/mmcblk0p2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Mount the partition under /media.</span>
</span></span><span style=display:flex><span>% mount /dev/mmcblk0p2 /media/mmcblk0p2
</span></span></code></pre></div><p>The installation is straightforward, we just need to pay attention to a few select steps:</p><ul><li><code>setup-disk</code>: Select <code>none</code> to ensure a <code>diskless</code> installation<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.</li><li><code>setup-apkcache</code>: Select <code>/media/mmcblk0p2/cache</code> to persist downloaded <code>apk</code> packages.</li><li><code>setup-lbu</code>: Edit <code>/etc/lbu/lbu.conf</code> and set <code>LBU_MEDIA="mmcblk0p2"</code>. Note: Do not add <code>/media</code> as it is implicit.</li></ul><p>Once the installation is complete, run <code>lbu commit</code> to persist the changes in the second partition. Once you do so, a <code>&lt;hostname>.apkovl.tar.gz</code><sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> file should materialize on <code>/media/mmcblk0p2/</code>.</p><p>This is a good moment to reboot. Before we do so, let&rsquo;s cache the packages we had previously downloaded.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Cache packages.</span>
</span></span><span style=display:flex><span>% apk cache download
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>% reboot
</span></span></code></pre></div><h2 id=after-the-first-reboot>After the first reboot<a hidden class=anchor aria-hidden=true href=#after-the-first-reboot>#</a></h2><p>If everything worked as expected, once you reboot all your previously installed packages should have been preserved and automatically restored / reinstalled, as well as your modifications done to <code>/etc</code>.</p><p>From this point on, whenever you install a new package that you want to be preserved for subsequent reboots, run <code>lbu commit</code> afterwards. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>% apk add vim
</span></span><span style=display:flex><span>% lbu commit
</span></span></code></pre></div><p>If you would like to see what is going to be committed, run <code>lbu status</code> or <code>lbu diff</code> before doing the actual commit. Whenever you commit, <code>/media/mmcblk0p2/&lt;hostname>.apkovl.tar.gz</code> gets overwritten with your most recent modifications.</p><p>It&rsquo;s possible to keep more than one backup file by changing <code>BACKUP_LIMIT=</code> in <code>/etc/lbu/lbu.conf</code>. This is specially handy if you decide to revert to an earlier system snapshot / state later on. The stock config looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>% cat /etc/lbu/lbu.conf
</span></span><span style=display:flex><span><span style=color:#75715e># what cipher to use with -e option</span>
</span></span><span style=display:flex><span>DEFAULT_CIPHER<span style=color:#f92672>=</span>aes-256-cbc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Uncomment the row below to encrypt config by default</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ENCRYPTION=$DEFAULT_CIPHER</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Uncomment below to avoid &lt;media&gt; option to &#39;lbu commit&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Can also be set to &#39;floppy&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># LBU_MEDIA=usb</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Set the LBU_BACKUPDIR variable in case you prefer to save the apkovls</span>
</span></span><span style=display:flex><span><span style=color:#75715e># in a normal directory instead of mounting an external media.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># LBU_BACKUPDIR=/root/config-backups</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Uncomment below to let lbu make up to 3 backups</span>
</span></span><span style=display:flex><span><span style=color:#75715e># BACKUP_LIMIT=3</span>
</span></span></code></pre></div><p><strong>Tip</strong>: You can find the list of all explicitly installed packages in <code>/etc/apk/world</code>.</p><h2 id=the-last-piece-make-var-persistent>The last piece: make /var persistent<a hidden class=anchor aria-hidden=true href=#the-last-piece-make-var-persistent>#</a></h2><p>There are three natural ways that come to mind to make <code>/var</code> persistent:</p><h3 id=a-separate-partition-or-file>A) Separate partition (or file)<a hidden class=anchor aria-hidden=true href=#a-separate-partition-or-file>#</a></h3><p>Instead of two partitions (FAT32 and ext4), create 3 partitions: FAT32, ext4 and ext4. Use the latter one to mount <code>/var</code> on, saving this information in <code>/etc/fstab</code>. The main disadvantage of this setup is that you&rsquo;ll need to allocate a fixed amount of space of each of the ext4 partitions and it may be difficult to figure out how to split the space between them.</p><p>A variant of this approach is to just create the third partition as a file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># 500MB file</span>
</span></span><span style=display:flex><span>% dd <span style=color:#66d9ef>if</span><span style=color:#f92672>=</span>/dev/zero of<span style=color:#f92672>=</span>/media/mmcblk0p2/var.img bs<span style=color:#f92672>=</span>1M count<span style=color:#f92672>=</span><span style=color:#ae81ff>500</span> status<span style=color:#f92672>=</span>progress
</span></span><span style=display:flex><span>% mkfs.ext4 /media/mmcblk0p2/var.img
</span></span><span style=display:flex><span>% mount /media/mmcblk0p2/var.img /var
</span></span></code></pre></div><p>This works because the Linux kernel supports mounting files as if they were device blocks, treating them as loop devices (pseudo-devices).</p><p>I don&rsquo;t like these approaches because they shadow the preexisting <code>/var</code> from the boot media, which in turn messes up with existing services that use it such as <code>cron</code>: <code>% crontab -l</code> would fail. One workaround would be to mount a <code>/var</code> subdirectory instead: for example, <code>/var/lib/docker</code> for docker.</p><h3 id=b-bind-mount>B) Bind mount<a hidden class=anchor aria-hidden=true href=#b-bind-mount>#</a></h3><p>This one is straightforward:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>% mount --bind /media/mmcblk0p2/var/lib/docker /var/lib/docker
</span></span></code></pre></div><p>The actual partition lives in the SD card, however we make a bind mount under
<code>/var</code>, which is like an <em>alias</em>. From <a href=https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount>Stack Exchange</a>:</p><blockquote><p>A bind mount is an alternate view of a directory tree. Classically, mounting creates a view of a storage device as a directory tree. A bind mount instead takes an existing directory tree and replicates it under a different point. The directories and files in the bind mount are the same as the original. Any modification on one side is immediately reflected on the other side, since the two views show the same data.</p></blockquote><h3 id=c-overlay-mount>C) Overlay mount<a hidden class=anchor aria-hidden=true href=#c-overlay-mount>#</a></h3><p>From <a href=https://wiki.archlinux.org/title/Overlay_filesystem>ArchWiki</a>:</p><blockquote><p>Overlayfs allows one, usually read-write, directory tree to be overlaid onto another, read-only directory tree. All modifications go to the upper, writable layer. This type of mechanism is most often used for live CDs but there is a wide variety of other uses.</p></blockquote><p>It&rsquo;s perfect for our use case, which uses a live bootable SD card for Alpine. It blends the preexisting, ephemeral, in-memory <code>/var</code> with the persistent in-disk <code>/var</code>.</p><p>I wanted to mount <code>/var</code> directly but found it to be problematic for the same reasons mentioned earlier, therefore I just went with <code>/var/lib/docker</code> instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Create overlay upper and work directories.</span>
</span></span><span style=display:flex><span>% mkdir -p /media/mmcblk0p2/var/lib/docker /media/mmcblk0p2/var/lib/docker-work
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Add mountpoint entry to fstab. Note: The work dir must be an empty directory in the same filesystem mount as the upper directory.</span>
</span></span><span style=display:flex><span>% echo <span style=color:#e6db74>&#34;overlay /var/lib/docker overlay lowerdir=/var/lib/docker,upperdir=/media/mmcblk0p2/var/lib/docker,workdir=/media/mmcblk0p2/var/lib/docker-work 0 0&#34;</span> &gt;&gt; /etc/fstab
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Mount all fstab entries, including our newly added one.</span>
</span></span><span style=display:flex><span>% mount -a
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I opted for the third approach, using an overlay mount, it was the most
seamless one. A bind mount would have been fine as well.</p><p>The final setup works surprisingly well:</p><ul><li>Alpine Linux is very lightweight and runs mostly from RAM</li><li><code>apk</code> cache is persistent to the ext4 partition</li><li><code>/var/</code> is persistent to the ext4 partition</li><li><code>lbu commit</code> persists changes in <code>/etc/</code> and <code>/home/</code> in the ext4 partition</li><li>Every reboot fully resets the system sans persistent components above</li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://vincentserpoul.github.io/post/alpine-linux-rpi0/>https://vincentserpoul.github.io/post/alpine-linux-rpi0/</a></li><li><a href=http://dahl-jacobsen.dk/tips/blog/2021-04-08-docker-on-alpine-linux/>http://dahl-jacobsen.dk/tips/blog/2021-04-08-docker-on-alpine-linux/</a></li><li><a href=http://dahl-jacobsen.dk/tips/blog/2018-03-15-alpine-on-raspberry-pi/>http://dahl-jacobsen.dk/tips/blog/2018-03-15-alpine-on-raspberry-pi/</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Running (almost) fully from RAM.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>CF = Compact disk.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>On Linux I&rsquo;d usually opt for <code>dd</code>, on Windows the Raspberry Pi Imager is a sensible choice.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>100MB is overly conservative, but keep in mind I had a very small SD Card, with only 4GiB storage. 250MB or even 500MB should be a more sensible default if you have a bigger SD Card (e.g. 32GiB).&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>An alternative is to select <code>data</code> disk mode, but it didn&rsquo;t work for me.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><em>ovl</em> is short for <em>overlay</em>. Not to be confused with <em>vol</em> for <em>volume</em>.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.perrotta.dev/tags/linux/>Linux</a></li><li><a href=https://www.perrotta.dev/tags/selfhosted/>Selfhosted</a></li><li><a href=https://www.perrotta.dev/tags/bestof/>Bestof</a></li></ul></footer><div style=text-align:center><a href="mailto:tbperrotta@gmail.com?subject=RE: not%20just%20serendipity comment for '%e2%98%85%20Alpine%20Linux%20on%20Raspberry%20Pi%3a%20Diskless%20Mode%20with%20persistent%20storage'" target=_blank><button>Reply via email</button></a></div></article></main><footer class=footer><span>Copyright © 2021 - 2024 Thiago Perrotta · <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a> • <a href=/index.xml>RSS</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>