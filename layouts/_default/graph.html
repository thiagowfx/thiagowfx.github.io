{{- define "main" }}
<style>
  #graph-container {
    position: relative;
    width: 100%;
    height: 70vh;
    min-height: 400px;
    max-height: 800px;
    border: 2px solid var(--border-color);
    border-radius: .5rem;
    overflow: hidden;
    background: linear-gradient(135deg, var(--bg-color) 0%, color-mix(in srgb, var(--border-color) 8%, var(--bg-color)) 100%);
  }
  body.fullscreen-mode #graph-container {
    height: calc(100vh - 6rem);
    max-height: none;
  }
  #graph-controls {
    display: flex;
    gap: 0.75rem;
    align-items: center;
    margin-top: 0.75rem;
  }
  #graph-controls button {
    background: none;
    border: 1px solid var(--border-color);
    border-radius: .25rem;
    padding: 0.25rem 0.75rem;
    cursor: pointer;
    color: var(--text-color);
    font-size: 0.85rem;
  }
  #graph-controls button:hover {
    border-color: var(--link-color);
    color: var(--link-color);
  }
  #graph-tooltip {
    position: absolute;
    pointer-events: none;
    background: var(--bg-color);
    border: 1px solid var(--border-color);
    border-radius: .25rem;
    padding: 0.4rem 0.6rem;
    font-size: 0.8rem;
    line-height: 1.3;
    max-width: 280px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    display: none;
    z-index: 10;
  }
  #graph-tooltip .tooltip-title {
    font-weight: 600;
    color: var(--heading-color, var(--text-color));
  }
  #graph-tooltip .tooltip-meta {
    color: var(--color-gray);
    font-size: 0.75rem;
    margin-top: 0.15rem;
  }
</style>

<div style="display: flex; align-items: center; gap: 0.75rem;">
  <h2 style="margin: 0;">{{ .Title }}</h2>
  <button id="fullscreen-btn" class="fullscreen-btn" aria-label="Toggle fullscreen mode" title="Toggle fullscreen mode (f)">
    <span id="fullscreen-icon">⛶</span>
  </button>
</div>
<p>Interactive graph of blog posts and their connections. Drag nodes to rearrange. Click a node to visit the post.</p>

<div id="graph-container">
  <p id="graph-loading" style="padding: 1rem; color: var(--color-gray);">Loading graph data...</p>
  <div id="graph-tooltip">
    <div class="tooltip-title"></div>
    <div class="tooltip-meta"></div>
  </div>
</div>

<div id="graph-controls">
  <span id="graph-stats" style="color: var(--color-gray); font-size: 0.9rem;"></span>
  <button id="toggle-singletons">Show all posts</button>
</div>

<script src="/vendor/d3.v7.min.js"></script>
<script>
(function() {
  fetch('/graph.json')
    .then(response => response.json())
    .then(data => {
      const allNodes = data.nodes;
      const links = data.edges;

      // Pre-compute connected node IDs from edges
      const connectedNodeIds = new Set();
      links.forEach(l => {
        connectedNodeIds.add(l.source);
        connectedNodeIds.add(l.target);
      });

      const connectedNodes = allNodes.filter(n => connectedNodeIds.has(n.id));
      const singletonNodes = allNodes.filter(n => !connectedNodeIds.has(n.id));

      // Pre-compute neighbor map for hover highlighting
      const neighbors = new Map();
      links.forEach(l => {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid = typeof l.target === 'object' ? l.target.id : l.target;
        if (!neighbors.has(sid)) neighbors.set(sid, new Set());
        if (!neighbors.has(tid)) neighbors.set(tid, new Set());
        neighbors.get(sid).add(tid);
        neighbors.get(tid).add(sid);
      });

      // Start with connected nodes only
      let activeNodes = [...connectedNodes];
      let showingSingletons = false;

      // Remove loading message
      document.getElementById('graph-loading').remove();

      const updateStats = () => {
        const singletonText = showingSingletons ? '' : ` · ${singletonNodes.length} singletons hidden`;
        document.getElementById('graph-stats').textContent =
          `${activeNodes.length} posts · ${links.length} links${singletonText}`;
      };
      updateStats();

      const container = document.getElementById('graph-container');
      const tooltip = document.getElementById('graph-tooltip');
      const tooltipTitle = tooltip.querySelector('.tooltip-title');
      const tooltipMeta = tooltip.querySelector('.tooltip-meta');
      let width = container.clientWidth;
      let height = container.clientHeight;

      const svg = d3.select('#graph-container')
        .append('svg')
        .attr('width', '100%')
        .attr('height', '100%')
        .attr('viewBox', [0, 0, width, height]);

      // Add zoom behavior
      const g = svg.append('g');
      svg.call(d3.zoom()
        .scaleExtent([0.1, 4])
        .on('zoom', (event) => g.attr('transform', event.transform)));

      // Get colors from CSS variables
      const style = getComputedStyle(document.documentElement);
      const linkColor = style.getPropertyValue('--border-color').trim() || '#ccc';
      const nodeColor = style.getPropertyValue('--link-color').trim() || '#0066cc';
      const bgColor = style.getPropertyValue('--bg-color').trim() || '#fff';

      // Pre-compute connection counts (before d3 mutates link objects)
      const connectionCount = new Map();
      links.forEach(l => {
        const sid = typeof l.source === 'object' ? l.source.id : l.source;
        const tid = typeof l.target === 'object' ? l.target.id : l.target;
        connectionCount.set(sid, (connectionCount.get(sid) || 0) + 1);
        connectionCount.set(tid, (connectionCount.get(tid) || 0) + 1);
      });

      const nodeRadius = d => {
        const c = connectionCount.get(d.id) || 0;
        return c === 0 ? 2 : Math.max(5, Math.min(15, 5 + c * 2));
      };

      // Create simulation
      const simulation = d3.forceSimulation(activeNodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(80))
        .force('charge', d3.forceManyBody().strength(-200))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(20));

      // Draw layers
      const linkGroup = g.append('g');
      const nodeGroup = g.append('g');

      let link = linkGroup.selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke', linkColor)
        .attr('stroke-opacity', 0.6)
        .attr('stroke-width', 1.5);

      let node = nodeGroup.selectAll('circle')
        .data(activeNodes, d => d.id)
        .join('circle')
        .attr('r', nodeRadius)
        .attr('fill', nodeColor)
        .attr('stroke', bgColor)
        .attr('stroke-width', 1.5)
        .style('cursor', 'pointer')
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended));

      function bindNodeEvents(sel) {
        sel.on('click', (event, d) => {
          window.location.href = d.url;
        });

        sel.on('mouseover', function(event, d) {
          const neighborIds = neighbors.get(d.id) || new Set();
          d3.select(this).attr('fill', '#ff6600');

          // Highlight neighbor nodes
          node.attr('fill', n => {
            if (n.id === d.id) return '#ff6600';
            if (neighborIds.has(n.id)) return '#ff6600';
            return nodeColor;
          }).attr('opacity', n => {
            if (n.id === d.id || neighborIds.has(n.id)) return 1;
            return 0.3;
          });

          // Highlight connected links
          link.attr('stroke', l => (l.source.id === d.id || l.target.id === d.id) ? '#ff6600' : linkColor)
              .attr('stroke-width', l => (l.source.id === d.id || l.target.id === d.id) ? 2.5 : 1.5)
              .attr('stroke-opacity', l => (l.source.id === d.id || l.target.id === d.id) ? 1 : 0.15);

          // Show tooltip
          const count = connectionCount.get(d.id) || 0;
          tooltipTitle.textContent = d.title;
          const datePart = d.date ? d.date.substring(0, 10) : '';
          tooltipMeta.textContent = `${datePart}${datePart ? ' · ' : ''}${count} connection${count !== 1 ? 's' : ''}`;
          tooltip.style.display = 'block';

          const rect = container.getBoundingClientRect();
          const x = event.clientX - rect.left + 12;
          const y = event.clientY - rect.top - 10;
          tooltip.style.left = Math.min(x, rect.width - 290) + 'px';
          tooltip.style.top = y + 'px';
        });

        sel.on('mousemove', function(event) {
          const rect = container.getBoundingClientRect();
          const x = event.clientX - rect.left + 12;
          const y = event.clientY - rect.top - 10;
          tooltip.style.left = Math.min(x, rect.width - 290) + 'px';
          tooltip.style.top = y + 'px';
        });

        sel.on('mouseout', function() {
          node.attr('fill', nodeColor).attr('opacity', 1);
          link.attr('stroke', linkColor).attr('stroke-width', 1.5).attr('stroke-opacity', 0.6);
          tooltip.style.display = 'none';
        });
      }

      bindNodeEvents(node);

      function rebuildNodes() {
        node = nodeGroup.selectAll('circle')
          .data(activeNodes, d => d.id)
          .join(
            enter => enter.append('circle')
              .attr('r', nodeRadius)
              .attr('fill', nodeColor)
              .attr('stroke', bgColor)
              .attr('stroke-width', 1.5)
              .attr('opacity', d => connectedNodeIds.has(d.id) ? 1 : 0.4)
              .style('cursor', 'pointer')
              .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended)),
            update => update,
            exit => exit.remove()
          );
        bindNodeEvents(node);
      }

      // Update positions on tick
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        node
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);
      });

      // Toggle singletons
      const toggleBtn = document.getElementById('toggle-singletons');
      toggleBtn.addEventListener('click', () => {
        showingSingletons = !showingSingletons;
        toggleBtn.textContent = showingSingletons ? 'Show connected only' : 'Show all posts';

        if (showingSingletons) {
          // Scatter singletons around the periphery
          singletonNodes.forEach((n, i) => {
            const angle = (2 * Math.PI * i) / singletonNodes.length;
            const r = Math.min(width, height) * 0.45;
            n.x = width / 2 + r * Math.cos(angle);
            n.y = height / 2 + r * Math.sin(angle);
          });
          activeNodes = [...connectedNodes, ...singletonNodes];
        } else {
          activeNodes = [...connectedNodes];
        }

        simulation.nodes(activeNodes);
        rebuildNodes();
        updateStats();

        if (showingSingletons) {
          simulation.force('charge', d3.forceManyBody().strength(d => connectedNodeIds.has(d.id) ? -200 : -30));
        } else {
          simulation.force('charge', d3.forceManyBody().strength(-200));
        }
        simulation.alpha(0.5).restart();
      });

      // Resize handler for fullscreen toggle
      const resizeObserver = new ResizeObserver(() => {
        width = container.clientWidth;
        height = container.clientHeight;
        svg.attr('viewBox', [0, 0, width, height]);
        simulation.force('center', d3.forceCenter(width / 2, height / 2));
        simulation.alpha(0.3).restart();
      });
      resizeObserver.observe(container);

      function dragstarted(event) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        event.subject.fx = event.subject.x;
        event.subject.fy = event.subject.y;
      }

      function dragged(event) {
        event.subject.fx = event.x;
        event.subject.fy = event.y;
      }

      function dragended(event) {
        if (!event.active) simulation.alphaTarget(0);
        event.subject.fx = null;
        event.subject.fy = null;
      }
    })
    .catch(error => {
      const el = document.getElementById('graph-loading');
      if (el) el.textContent = 'Failed to load graph data.';
      console.error('Error loading graph data:', error);
    });
})();
</script>

{{- end -}}
