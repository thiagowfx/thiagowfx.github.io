{{- $autofocus := .autofocus | default false }}
{{- $contentSelector := .contentSelector | default "" }}
{{- $excludeTags := .excludeTags | default slice }}
{{- $includeTags := .includeTags | default slice }}
{{- $excludeCategories := .excludeCategories | default slice }}
{{- $includeCategories := .includeCategories | default slice }}
<div class="search-container">
  <input type="text" id="search-input" placeholder="{{ i18n "searchPlaceholder" }}" autocomplete="off" {{ if $autofocus }}autofocus{{ end }} />
  <div id="search-info" class="search-info"></div>
</div>
<div id="search-results" class="search-results"></div>
<script type="module">
  let searchIndex = null;
  const searchInput = document.getElementById('search-input');
  const searchResults = document.getElementById('search-results');
  const searchInfo = document.getElementById('search-info');
  const contentSelector = '{{ $contentSelector }}';
  const contentEl = contentSelector ? document.querySelector(contentSelector) : null;
  const excludeTags = new Set({{ $excludeTags | jsonify | safeJS }});
  const includeTags = new Set({{ $includeTags | jsonify | safeJS }});
  const excludeCategories = new Set({{ $excludeCategories | jsonify | safeJS }});
  const includeCategories = new Set({{ $includeCategories | jsonify | safeJS }});
  const i18n = {
    postsIndexed: '{{ i18n "postsIndexed" }}',
    noResults: '{{ i18n "noResults" }}',
    loading: '{{ i18n "searchLoading" }}'
  };

  const debounce = (fn, delay) => {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn(...args), delay);
    };
  };

  const escapeHtml = (text) => {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  };

  const termToRegex = (term) => {
    const escaped = term.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
    return new RegExp(escaped.replace(/\*/g, '.*'), 'i');
  };

  const matchesTerm = (text, term) => {
    if (term.includes('*')) {
      return termToRegex(term).test(text);
    }
    return text.includes(term);
  };

  const highlightMatch = (text, query) => {
    if (!text) return '';
    const escaped = escapeHtml(text);
    const terms = query.toLowerCase().split(/\s+/).filter(t => t.length > 0);
    return terms.reduce((result, term) => {
      const pattern = term.includes('*')
        ? term.replace(/[.+?^${}()|[\]\\]/g, '\\$&').replace(/\*/g, '[^\\s]*')
        : term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return result.replace(new RegExp(`(${pattern})`, 'gi'), '<mark>$1</mark>');
    }, escaped);
  };

  const updateURL = (query) => {
    const url = new URL(window.location);
    if (query) {
      url.searchParams.set('q', query);
    } else {
      url.searchParams.delete('q');
    }
    history.replaceState(null, '', url);
  };

  const renderResults = (results, query) => {
    if (results.length === 0) {
      searchInfo.textContent = i18n.noResults;
      searchResults.innerHTML = '<p class="no-results">No posts match your search.</p>';
      return;
    }

    searchInfo.textContent = `${results.length} result${results.length === 1 ? '' : 's'} found`;

    searchResults.innerHTML = results.map(({ post }) => {
      const categories = (post.categories ?? [])
        .map(c => `<a href="${langPath}/categories/${c}/" class="search-tag">%${escapeHtml(c)}</a>`)
        .join(' ');
      const tags = (post.tags ?? [])
        .map(t => `<a href="${langPath}/tags/${t}/" class="search-tag">#${escapeHtml(t)}</a>`)
        .join(' ');
      const allTags = [categories, tags].filter(Boolean).join(' â€¢ ');

      return `
        <div class="search-result">
          <a href="${escapeHtml(post.url)}" class="search-result-title">${highlightMatch(post.title, query)}</a>
          <div class="search-result-meta">
            <span class="search-result-date">${escapeHtml(post.date)}</span>
            ${allTags ? `<span class="search-result-tags">${allTags}</span>` : ''}
          </div>
          ${post.summary ? `<p class="search-result-summary">${highlightMatch(post.summary, query)}</p>` : ''}
        </div>
      `;
    }).join('');
  };

  const performSearch = (query) => {
    if (!searchIndex) return;

    const q = query.toLowerCase().trim();
    if (q.length === 0) {
      searchResults.innerHTML = '';
      searchInfo.textContent = `${searchIndex.length} ${i18n.postsIndexed}`;
      if (contentEl) contentEl.style.display = '';
      updateURL('');
      return;
    }

    if (contentEl) contentEl.style.display = 'none';

    const terms = q.split(/\s+/).filter(t => t.length > 0);
    const results = [];

    for (const post of searchIndex) {
      const title = (post.title ?? '').toLowerCase();
      const summary = (post.summary ?? '').toLowerCase();
      const tags = (post.tags ?? []).map(t => t.toLowerCase());
      const tagsText = tags.join(' ');

      let allMatch = true;
      let score = 0;

      for (const term of terms) {
        const inTitle = matchesTerm(title, term);
        const inSummary = matchesTerm(summary, term);
        const inTags = matchesTerm(tagsText, term);

        if (!inTitle && !inSummary && !inTags) {
          allMatch = false;
          break;
        }

        if (inTitle) score += 10;
        if (inTags) score += 5;
        if (inSummary) score += 1;
      }

      if (allMatch) {
        results.push({ post, score });
      }
    }

    results.sort((a, b) => b.score - a.score || b.post.date.localeCompare(a.post.date));

    updateURL(query);
    renderResults(results, query);
  };

  const lang = '{{ $.lang }}' || 'en';
  const langPath = lang === 'en' ? '' : '/' + lang;

  const loadSearchIndex = () => {
    if (searchIndex !== null) return;
    searchInfo.textContent = i18n.loading;
    fetch(langPath + '/search/index.json')
      .then(response => response.json())
      .then(data => {
        searchIndex = data;
        if (includeTags.size > 0) {
          searchIndex = searchIndex.filter(post => (post.tags ?? []).some(t => includeTags.has(t)));
        }
        if (excludeTags.size > 0) {
          searchIndex = searchIndex.filter(post => !(post.tags ?? []).some(t => excludeTags.has(t)));
        }
        if (includeCategories.size > 0) {
          searchIndex = searchIndex.filter(post => (post.categories ?? []).some(c => includeCategories.has(c)));
        }
        if (excludeCategories.size > 0) {
          searchIndex = searchIndex.filter(post => !(post.categories ?? []).some(c => excludeCategories.has(c)));
        }
        searchInfo.textContent = `${searchIndex.length} ${i18n.postsIndexed}`;
        const q = searchInput.value.trim();
        if (q) {
          performSearch(q);
        }
      })
      .catch(err => {
        searchInfo.textContent = 'Error loading search index';
        console.error('Search index load error:', err);
      });
  };

  // Load index on first focus, or immediately if there's a ?q= param
  const q = new URLSearchParams(window.location.search).get('q');
  if (q) {
    searchInput.value = q;
    loadSearchIndex();
  } else {
    searchInput.addEventListener('focus', loadSearchIndex, { once: true });
  }

  searchInput.addEventListener('input', debounce(e => performSearch(e.target.value), 150));
</script>
