<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet type="text/xsl" href="https://perrotta.dev/rss.xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Coding on ¬¨ just serendipity üçÄ</title><link>https://perrotta.dev/</link><description>Recent content in Coding on ¬¨ just serendipity üçÄ</description><generator>Hugo</generator><language>en</language><managingEditor>serendipity@perrotta.dev (Thiago Perrotta)</managingEditor><webMaster>serendipity@perrotta.dev (Thiago Perrotta)</webMaster><copyright>¬© 2013 - 2026 Thiago Perrotta ¬∑
[some rights reserved](https://creativecommons.org/licenses/by-nc-sa/4.0/) ¬∑
a fork of [hugo  ï‚Ä¢·¥•‚Ä¢ î bear](https://github.com/janraasch/hugo-bearblog/)</copyright><lastBuildDate>Mon, 16 Feb 2026 21:04:03 +0100</lastBuildDate><atom:link href="https://perrotta.dev/categories/coding/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode #2166: Design Bitset</title><link>https://perrotta.dev/2026/01/leetcode-%232166-design-bitset/</link><pubDate>Tue, 20 Jan 2026 22:20:59 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%232166-design-bitset/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-bitset"&gt;LeetCode #2166: Design Bitset&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Time limit exceeded:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Bitset:

 def __init__(self, size: int):
 self.bits = [False] * size


 def fix(self, idx: int) -&amp;gt; None:
 self.bits[idx] = 1


 def unfix(self, idx: int) -&amp;gt; None:
 self.bits[idx] = 0


 def flip(self) -&amp;gt; None:
 self.bits = [not bit for bit in self.bits]


 def all(self) -&amp;gt; bool:
 return all(self.bits)


 def one(self) -&amp;gt; bool:
 return any(self.bits)


 def count(self) -&amp;gt; int:
 return len([bit for bit in self.bits if bit])


 def toString(self) -&amp;gt; str:
 return &amp;#39;&amp;#39;.join(&amp;#39;1&amp;#39; if bit else &amp;#39;0&amp;#39; for bit in self.bits)



# Your Bitset object will be instantiated and called as such:
# obj = Bitset(size)
# obj.fix(idx)
# obj.unfix(idx)
# obj.flip()
# param_4 = obj.all()
# param_5 = obj.one()
# param_6 = obj.count()
# param_7 = obj.toString()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Optimized:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Bitset:

 def __init__(self, size: int):
 self.bits = [False] * size
 self.ones = 0
 self.flipped = False


 def fix(self, idx: int) -&amp;gt; None:
 if self.flipped:
 # When flipped, fixing means setting underlying bit to 0
 if self.bits[idx]:
 self.bits[idx] = False
 self.ones -= 1
 else:
 # Normal case: set to 1
 if not self.bits[idx]:
 self.bits[idx] = True
 self.ones &amp;#43;= 1


 def unfix(self, idx: int) -&amp;gt; None:
 if self.flipped:
 # When flipped, unfixing means setting underlying bit to 1
 if not self.bits[idx]:
 self.bits[idx] = True
 self.ones &amp;#43;= 1
 else:
 # Normal case: set to 0
 if self.bits[idx]:
 self.bits[idx] = False
 self.ones -= 1


 def flip(self) -&amp;gt; None:
 self.flipped = not self.flipped


 def all(self) -&amp;gt; bool:
 if self.flipped:
 return self.ones == 0
 else:
 return self.ones == len(self.bits)


 def one(self) -&amp;gt; bool:
 if self.flipped:
 # When flipped, we need at least one 0 in underlying array (which becomes 1)
 return self.ones &amp;lt; len(self.bits)
 else:
 return self.ones &amp;gt; 0


 def count(self) -&amp;gt; int:
 if self.flipped:
 return len(self.bits) - self.ones
 else:
 return self.ones


 def toString(self) -&amp;gt; str:
 if self.flipped:
 return &amp;#39;&amp;#39;.join(&amp;#39;0&amp;#39; if bit else &amp;#39;1&amp;#39; for bit in self.bits)
 else:
 return &amp;#39;&amp;#39;.join(&amp;#39;1&amp;#39; if bit else &amp;#39;0&amp;#39; for bit in self.bits)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #2166: Design Bitset"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1047: Remove All Adjacent Duplicates In String</title><link>https://perrotta.dev/2026/01/leetcode-%231047-remove-all-adjacent-duplicates-in-string/</link><pubDate>Sun, 18 Jan 2026 13:37:46 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231047-remove-all-adjacent-duplicates-in-string/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string"&gt;LeetCode #1047: Remove All Adjacent Duplicates In String&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Initial:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def removeDuplicates(self, s: str) -&amp;gt; str:
 stack = []
 ans = []

 for c in s:
 if not stack:
 stack.append(c)
 ans.append(c)
 else:
 if stack[-1] != c:
 stack.append(c)
 ans.append(c)
 else:
 stack.pop()
 ans.pop()

 return &amp;#39;&amp;#39;.join(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Optimized:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def removeDuplicates(self, s: str) -&amp;gt; str:
 stack = []
 ans = []

 for c in s:
 if not stack or stack[-1] != c:
 stack.append(c)
 ans.append(c)
 else:
 stack.pop()
 ans.pop()

 return &amp;#39;&amp;#39;.join(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1047: Remove All Adjacent Duplicates In String"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #380: Insert Delete GetRandom O(1)</title><link>https://perrotta.dev/2026/01/leetcode-%23380-insert-delete-getrandom-o1/</link><pubDate>Sun, 18 Jan 2026 02:54:25 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23380-insert-delete-getrandom-o1/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/insert-delete-getrandom-o%281%29"&gt;LeetCode #380: Insert Delete GetRandom O(1)&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Initial solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import random

class RandomizedSet:

 def __init__(self):
 self.l = []

 self.d = {}
 ## self.d = dict()

 def insert(self, val: int) -&amp;gt; bool:
 if val not in self.d:
 self.d[val] = len(self.l)
 self.l.append(val)
 return True

 return False


 def remove(self, val: int) -&amp;gt; bool:
 if val in self.d:
 del self.d[val]
 ## self.l: do not touch. Removal is O(n)
 return True

 return False


 def getRandom(self) -&amp;gt; int:
 return random.choice(list(self.d.keys()))


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;However, &lt;code&gt;getRandom()&lt;/code&gt; is &lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Better solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import random

class RandomizedSet:

 def __init__(self):
 self.l = []

 self.d = {}
 ## self.d = dict()

 def insert(self, val: int) -&amp;gt; bool:
 if val not in self.d:
 self.d[val] = len(self.l)
 self.l.append(val)
 return True

 return False


 def remove(self, val: int) -&amp;gt; bool:
 if val in self.d:
 i = self.d[val]
 del self.d[val]

 del self.l[i]
 return True

 return False


 def getRandom(self) -&amp;gt; int:
 return random.choice(self.l)


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;But it&amp;rsquo;s still &lt;code&gt;O(n)&lt;/code&gt; because of the list deletion.&lt;/p&gt;
&lt;p&gt;Even better:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import random

class RandomizedSet:

 def __init__(self):
 self.l = []

 self.d = {}
 ## self.d = dict()

 def insert(self, val: int) -&amp;gt; bool:
 if val not in self.d:
 self.d[val] = len(self.l)
 self.l.append(val)
 return True

 return False


 def remove(self, val: int) -&amp;gt; bool:
 if val in self.d:
 i = self.d[val]
 del self.d[val]

 last_val = self.l[-1]

 # Swap with the last element
 self.l[i] = last_val
 self.l.pop()

 # Update the dictionary for the swapped element only if it&amp;#39;s not the same as removed valA
 # i.e. not the last element
 if i &amp;lt; len(self.l):
 ## if i != len(self.l):
 self.d[last_val] = i

 return True

 return False


 def getRandom(self) -&amp;gt; int:
 return random.choice(self.l)


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #380: Insert Delete GetRandom O(1)"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #288: Unique Word Abbreviation</title><link>https://perrotta.dev/2026/01/leetcode-%23288-unique-word-abbreviation/</link><pubDate>Sat, 17 Jan 2026 03:00:13 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23288-unique-word-abbreviation/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/unique-word-abbreviation"&gt;LeetCode #288: Unique Word Abbreviation&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

def abbrev(word):
 if len(word) &amp;lt; 3:
 return word

 return f&amp;#39;{word[0]}{len(word) - 2}{word[-1]}&amp;#39;

assert abbrev(&amp;#34;dg&amp;#34;) == &amp;#34;dg&amp;#34;
assert abbrev(&amp;#34;dog&amp;#34;) == &amp;#34;d1g&amp;#34;
assert abbrev(&amp;#34;a&amp;#34;) == &amp;#34;a&amp;#34;


class ValidWordAbbr:

 def __init__(self, words: List[str]):
 self.words = words

 ## self.mappings = Counter() # abbrev -&amp;gt; word
 ## for word in set(words):
 ## self.mappings[abbrev(word)] &amp;#43;= 1

 self.mappings = Counter(abbrev(word) for word in set(words))

 def isUnique(self, word: str) -&amp;gt; bool:
 ab = abbrev(word)

 return self.mappings[ab] &amp;lt; 1 or (self.mappings[ab] == 1 and word in self.words)


# Your ValidWordAbbr object will be instantiated and called as such:
# obj = ValidWordAbbr(dictionary)
# param_1 = obj.isUnique(word)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #288: Unique Word Abbreviation"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #23: Merge k Sorted Lists</title><link>https://perrotta.dev/2026/01/leetcode-%2323-merge-k-sorted-lists/</link><pubDate>Thu, 15 Jan 2026 23:20:52 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%2323-merge-k-sorted-lists/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/merge-k-sorted-lists"&gt;LeetCode #23: Merge k Sorted Lists&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Heap of ListNodes:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import heapq

# Definition for singly-linked list.
# class ListNode:
# def __init__(self, val=0, next=None):
# self.val = val
# self.next = next
class HeapNode:
 def __init__(self, node: ListNode):
 self.node = node

 def __lt__(self, other: HeapNode):
 return self.node.val &amp;lt; other.node.val

class Solution:
 def mergeKLists(self, lists: List[Optional[ListNode]]) -&amp;gt; Optional[ListNode]:
 prehead = ListNode(None)

 curr = prehead
 heap = []

 for lst in lists:
 if lst:
 heapq.heappush(heap, HeapNode(lst))

 while heap:
 # find next element: val
 next_heap_node = heapq.heappop(heap)
 next_node = next_heap_node.node

 curr.next = ListNode(next_node.val)
 curr = curr.next

 next_node = next_node.next
 if next_node:
 heapq.heappush(heap, HeapNode(next_node))


 head = prehead.next
 return head&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #23: Merge k Sorted Lists"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #362: Design Hit Counter</title><link>https://perrotta.dev/2026/01/leetcode-%23362-design-hit-counter/</link><pubDate>Thu, 15 Jan 2026 23:10:19 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23362-design-hit-counter/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-hit-counter"&gt;LeetCode #362: Design Hit Counter&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;Counter&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import bisect
from collections import Counter

class HitCounter:

 def __init__(self):
 self.hits = Counter()
 ## timestamp -&amp;gt; hits

 def hit(self, timestamp: int) -&amp;gt; None:
 self.hits[timestamp] &amp;#43;= 1

 def getHits(self, timestamp: int) -&amp;gt; int:
 ## 3 * 60 -&amp;gt; 2
 ## 4 * 60 -&amp;gt; 1
 ## getHits(8 * 60) -&amp;gt; 3

 ## (exclusive, inclusive)
 ## (self.hits[timestamp - 300], self.hits[timestamp])

 items = list(sorted(self.hits.items()))
 ## (timestamp, counter)

 ## inclusive
 ts_left = bisect.bisect_right(items, timestamp - 300, key=lambda item: item[0])
 ts_right = bisect.bisect_left(items, timestamp, key=lambda item: item[0])

 ans = 0

 for (timestamp, hits) in items[ts_left:]:
 ans &amp;#43;= hits

 return ans


# Your HitCounter object will be instantiated and called as such:
# obj = HitCounter()
# obj.hit(timestamp)
# param_2 = obj.getHits(timestamp)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Alternatively, maintain our own sorted list of tuple:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import bisect

class HitCounter:

 def __init__(self):
 self.hits = []
 ## (timestamp, hits)

 def hit(self, timestamp: int) -&amp;gt; None:
 i = bisect.bisect_left(self.hits, timestamp, key=lambda item: item[0])
 if i &amp;lt; len(self.hits) and self.hits[i][0] == timestamp:
 self.hits[i] = (timestamp, self.hits[i][1] &amp;#43; 1)
 else:
 self.hits.insert(i, (timestamp, 1))

 def getHits(self, timestamp: int) -&amp;gt; int:
 ## 3 * 60 -&amp;gt; 2
 ## 4 * 60 -&amp;gt; 1
 ## getHits(8 * 60) -&amp;gt; 3

 ## (exclusive, inclusive)
 ## (self.hits[timestamp - 300], self.hits[timestamp])

 ## (timestamp, counter)

 ## inclusive
 ts_left = bisect.bisect_right(self.hits, timestamp - 300, key=lambda item: item[0])
 ts_right = bisect.bisect_left(self.hits, timestamp, key=lambda item: item[0])

 ans = 0

 for (timestamp, hits) in self.hits[ts_left:]:
 ans &amp;#43;= hits

 return ans


# Your HitCounter object will be instantiated and called as such:
# obj = HitCounter()
# obj.hit(timestamp)
# param_2 = obj.getHits(timestamp)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #362: Design Hit Counter"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>merge sort</title><link>https://perrotta.dev/2026/01/merge-sort/</link><pubDate>Wed, 14 Jan 2026 19:09:04 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/merge-sort/</guid><description>&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def merge_sort(a):
 if len(a) &amp;lt; 2: ## [0, 1]
 return a

 ## (0 1) (2 3)
 ## m
 ##
 ## (0 1) (2 3 4)
 ## m

 mid = len(a) // 2

 left = a[:mid]
 right = a[mid:]

 left = merge_sort(left)
 right = merge_sort(right)

 return merge(left, right)

def merge(left, right):
 ans = []

 i = j = 0
 while i &amp;lt; len(left) and j &amp;lt; len(right):
 if left[i] &amp;lt; right[j]:
 ans.append(left[i])
 i &amp;#43;= 1
 else:
 ans.append(right[j])
 j &amp;#43;= 1
 ans.extend(left[i:])
 ans.extend(right[j:])

 return ans

a = list(range(10))[::-1]
assert merge_sort(a) == list(range(10))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: merge sort"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>quick sort</title><link>https://perrotta.dev/2026/01/quick-sort/</link><pubDate>Wed, 14 Jan 2026 18:56:43 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/quick-sort/</guid><description>&lt;p&gt;First element is the pivot:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def quick_sort(a):
 if len(a) &amp;lt; 2: ## [0, 1]
 return a

 pivot = a[0]
 left = [x for x in a[1:] if x &amp;lt; pivot]
 right = [x for x in a[1:] if x &amp;gt;= pivot]

 left = quick_sort(left)
 right = quick_sort(right)

 return left &amp;#43; [pivot] &amp;#43; right

a = list(range(10))[::-1]

# it&amp;#39;s usually easier to do it with a copy
assert quick_sort(a) == list(range(10))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With a random pivot:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;import random

def quick_sort(a):
 if len(a) &amp;lt; 2: ## [0, 1]
 return a

 pivot = random.choice(a)
 a_nopivot = [x for x in a if x != pivot]

 left = [x for x in a_nopivot if x &amp;lt; pivot]
 right = [x for x in a_nopivot if x &amp;gt;= pivot]

 left = quick_sort(left)
 right = quick_sort(right)

 return left &amp;#43; [pivot] &amp;#43; right

a = list(range(10))[::-1]

# it&amp;#39;s usually easier to do it with a copy
assert quick_sort(a) == list(range(10))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: quick sort"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>bisect: list of tuple</title><link>https://perrotta.dev/2026/01/bisect-list-of-tuple/</link><pubDate>Wed, 14 Jan 2026 18:47:50 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/bisect-list-of-tuple/</guid><description>&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;a = [(1, 3), (1, 4), (2, 5), (3, 6), (3, 7), (5, 8)]
b = [1, 1, 2, 3, 3, 5]
c = [x for (x, _) in a]
assert b == c

import bisect
assert bisect.bisect_right(b, 1) == 2
assert bisect.bisect_right(b, 3) == 5
assert bisect.bisect_right(b, 6) == len(b)

## use:
## i = bisect.bisect_right(b, 3)
## return a[i - 1][1]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: bisect: list of tuple"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>sorting algorithms</title><link>https://perrotta.dev/2026/01/sorting-algorithms/</link><pubDate>Wed, 14 Jan 2026 03:30:25 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/sorting-algorithms/</guid><description>&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def swap(a, x, y):
 a[x], a[y] = a[y], a[x]

def bubble_sort(a):
 for i in range(len(a)):
 for j in range(i &amp;#43; 1, len(a)):
 if a[i] &amp;gt; a[j]:
 swap(a, i, j)

a = list(range(10)[::-1])
bubble_sort(a)
assert a == list(range(10))

def selection_sort(a):
 for i in range(len(a) - 1):
 ## el = min(a[i &amp;#43; 1:])
 ## eli = a.index(el)
 el = float(&amp;#39;inf&amp;#39;)
 eli = None
 for j in range(i &amp;#43; 1, len(a)):
 if a[j] &amp;lt; el:
 el = a[j]
 eli = j
 if eli:
 if a[i] &amp;gt; a[eli]:
 swap(a, i, eli)

a = list(range(10)[::-1])
selection_sort(a)
assert a == list(range(10))

def merge_sort_inplace(a):
 a[:] = merge_sort(a)

def merge_sort(a): ## no indices! (indexes)
 n = len(a)

 if n &amp;lt; 2: ## in [0, 1]
 return a

 # 0 1 2 3 4
 # 0 m n

 # 0 1 2 3
 # 0 m n
 mid = n // 2

 ## left: [0, mid - 1]
 ## right: [mid, len(a) - 1]
 A = merge_sort(a[:mid])
 B = merge_sort(a[mid:])

 ## A
 ## 1 4 7
 ## 2 3 6
 ## B

 return merge(A, B)

def merge(A, B):
 ans = []

 a = 0
 b = 0

 while a &amp;lt; len(A) and b &amp;lt; len(B):
 if A[a] &amp;lt; B[b]:
 ans.append(A[a])
 a &amp;#43;= 1
 else:
 ans.append(B[b])
 b &amp;#43;= 1

 ans.extend(A[a:])
 ans.extend(B[b:])

 return ans


a = list(range(10)[::-1])
merge_sort_inplace(a)
assert a == list(range(10))

def quick_sort(a):
 if len(a) &amp;lt; 2:
 return
 pivot = a[0]
 left = [x for x in a[1:] if x &amp;lt; pivot]
 right = [x for x in a[1:] if x &amp;gt;= pivot]

 quick_sort(left)
 quick_sort(right)
 a[:] = left &amp;#43; [pivot] &amp;#43; right

a = list(range(10)[::-1])
quick_sort(a)
assert a == list(range(10))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: sorting algorithms"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>rca</title><link>https://perrotta.dev/2026/01/rca/</link><pubDate>Wed, 14 Jan 2026 02:47:21 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/rca/</guid><description>&lt;p&gt;RCA = Root-Cause Analysis = Postmortem&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5 Whys. Why?? Why?? &lt;a href="https://www.youtube.com/watch?v=yki_bWIMvIU"&gt;Tell me
why!!!!&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;CAPAs =&amp;gt; corrective actions, preventive actions&lt;/li&gt;
&lt;li&gt;Corrective: fix the issue right away. Stop the bleeding.&lt;/li&gt;
&lt;li&gt;Preventive: how to stop it from reoccurring?&lt;/li&gt;
&lt;li&gt;Is there a monitoring gap? Did we find out about the issue by ourselves or via
the customer?&lt;/li&gt;
&lt;li&gt;If there was an alert, was it lost in the noise? Did it have the right
priority? Did it have proper routing, to the relevant (oncall) teams?&lt;/li&gt;
&lt;li&gt;Do we have an incident management process (IRM / Requiem)?&lt;/li&gt;
&lt;li&gt;Who is the incident commander?&lt;/li&gt;
&lt;li&gt;Do we have a status page that our customers can follow? Example:
&lt;a href="http://status.github.com/"&gt;http://status.github.com/&lt;/a&gt;. Uptime dashboard (UptimeKuma). Atlassian
StatusPage.&lt;/li&gt;
&lt;li&gt;What is our burn rate?&lt;/li&gt;
&lt;li&gt;What are our SLAs (agreement, contract)? SLOs (objective)? SLIs (indicator)?&lt;/li&gt;
&lt;li&gt;Prometheus. PromQL. Time-series database (TRDB), time-series tracking.
Cardinality of metrics.&lt;/li&gt;
&lt;li&gt;Cause: trigger of an immediate event vs contributing factor that made it
worse.&lt;/li&gt;
&lt;li&gt;Blameless postmortem culture. Psychological safety!&lt;/li&gt;
&lt;li&gt;Grafana. Dashboard. Render.&lt;/li&gt;
&lt;li&gt;AlertManager. Alert routing. Silencing. Snoozing.&lt;/li&gt;
&lt;li&gt;Maintenance mode. Maintenance windows.&lt;/li&gt;
&lt;li&gt;Logs collection. Loki. Analog.&lt;/li&gt;
&lt;li&gt;Logging (&lt;code&gt;/var/log/&lt;/code&gt;) ‚Äî logging framework, or even good ol&amp;rsquo; &lt;code&gt;print(f)&lt;/code&gt; /
&lt;code&gt;echo&lt;/code&gt;. stdout vs stderr. Log levels. Debugging logs vs error (panic) logs.
Exceptions, stack traces. ThirdEye / Sentry. Error, warning, info. Logs
collection and aggregation.&lt;/li&gt;
&lt;li&gt;Analytics (more product-based e.g. PM, UX are interested in them) ‚Äî page views
/ hits, number of daily/weekly/monthly active users.&lt;/li&gt;
&lt;li&gt;Metrics. Buckets. Histograms. Counters. Gauges. Number of responses with a
given HTTP status code. Latency in ms. Rates e.g. success / total.&lt;/li&gt;
&lt;li&gt;Alerts. Conditions observed during a certain time window. Surpassed a certain
threshold. Flapping.&lt;/li&gt;
&lt;li&gt;(Distributed) Tracing. Life of a request. Honeycomb. Microservices.0&lt;/li&gt;
&lt;li&gt;Bisection (e.g. &lt;code&gt;git bisect&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;When a bug is found, write a test to prevent it from reoccurring.&lt;/li&gt;
&lt;li&gt;Profiling. Function latency breakdown.&lt;/li&gt;
&lt;li&gt;Metrics correlation.&lt;/li&gt;
&lt;li&gt;Incident lifecycle: detection (alert? customer?) -&amp;gt; triage (P0?) -&amp;gt; mitigation
(CA) -&amp;gt; resolution (PA) -&amp;gt; postmortem / RCA.&lt;/li&gt;
&lt;li&gt;RCAs are only useful if action items are addressed. Prioritization is
important.&lt;/li&gt;
&lt;li&gt;Action items need to be&amp;hellip;actionable! Story-sized, not epic-sized.&lt;/li&gt;
&lt;li&gt;Playbooks (runbooks). Manual! How to address an alert. What to do? What to
look out for?&lt;/li&gt;
&lt;li&gt;Failures: technical (code, infra); observability (gaps, tooling); process
(SOP).&lt;/li&gt;
&lt;li&gt;Golden metrics: latency (overloaded, preempting), traffic (e.g. spikes),
errors (kubectl logs? / loki), saturation (e.g. disk, memory ‚Äî OOM, cpu ‚Äì
thrasing)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: rca"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>cicd</title><link>https://perrotta.dev/2026/01/cicd/</link><pubDate>Tue, 13 Jan 2026 20:46:35 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/cicd/</guid><description>&lt;p&gt;&lt;strong&gt;CI/CD&lt;/strong&gt;: continuous integration / continuous delivery.&lt;/p&gt;
&lt;p&gt;What do we care about?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Velocity / Speed&lt;/strong&gt;: If it takes too long, it adds friction.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Correctness / Safety / Reliability&lt;/strong&gt;: Reduce the blast radius. The pipeline
should be readily available.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Architecture (CI):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pre-submit checks&lt;/strong&gt;: At Google, TAP Presubmit. In the open, pre-commit.com.
There&amp;rsquo;s also husky (nodejs centric). And you could always use plain old
vanilla &lt;code&gt;.git/hooks&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Post-submit checks&lt;/strong&gt;: At Google, TAP PostSubmit. In the open, nightly cron
jobs (e.g. with github workflows). There needs to be a notification mechanism.
Email, slack, a CD dashboard.&lt;/li&gt;
&lt;li&gt;Test coverage report&lt;/li&gt;
&lt;li&gt;Formatters, linters, style guide&lt;/li&gt;
&lt;li&gt;Analyzers (static &amp;amp; dynamic)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Architecture (CD):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Canary (mitigate risks) ‚Äì guinea pigs. Smoke testing.&lt;/li&gt;
&lt;li&gt;Gradual rollouts ‚Äì replace little by little -&amp;gt; rolling update.&lt;/li&gt;
&lt;li&gt;Blue-green deployments ‚Äì maintain two sets of deployments, switch them
dynamically. Zero-downtime, instant rollback, isolation for testing.&lt;/li&gt;
&lt;li&gt;Feature flags ‚Äì dynamically toggle code paths on-demand (e.g. launchdarkly.com).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Testing pipeline ‚Äì Pyramid of testing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Small, frequent, fast.&lt;/li&gt;
&lt;li&gt;Big, occasional, slow.&lt;/li&gt;
&lt;li&gt;Unit tests (single module) -&amp;gt; integration tests (various modules) -&amp;gt;
end-to-end tests (various parts of the system) -&amp;gt; smoke tests (sanity check).&lt;/li&gt;
&lt;li&gt;Mocks, fakes, stubs.&lt;/li&gt;
&lt;li&gt;RpcReplay (Tin)&lt;/li&gt;
&lt;li&gt;Non-determinism: e.g. time, snynchronization, network, load, race conditions.&lt;/li&gt;
&lt;li&gt;Run tests locally vs in CI. Run tests hermetically, in an isolated fashion.
Chrome for Testing.&lt;/li&gt;
&lt;li&gt;Multiple live environments: dev -&amp;gt; staging -&amp;gt; preprod -&amp;gt; prod, or daily-7,
daily-6, &amp;hellip;, daily-1. Simpler: staging vs prod. Prod should be
access-restricted / gated. Minimize permissions. Principle of least privilege.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Infrastructure as Code (IaC): the best ever!!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ansible, Chef, Puppet, SaltStack, Pyinfra.&lt;/li&gt;
&lt;li&gt;Terraform, OpenTofu and friends: Pulumi (programming languages instead of HCL
e.g. python, typescript), Terraform CDK.&lt;/li&gt;
&lt;li&gt;Crossplane (Kubernetes IaC).&lt;/li&gt;
&lt;li&gt;Declarative vs Imperative.&lt;/li&gt;
&lt;li&gt;Idempotency.&lt;/li&gt;
&lt;li&gt;In general, make updates via git / gitops, and let the harness apply changes
to the cloud infra. Avoid modifying live servers directly (live patching),
unless during emergencies (oncall -&amp;gt; breakglass mechanisms).&lt;/li&gt;
&lt;li&gt;YAML, HCL, JSON. Gluing configuration languages all over the place.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Migrations of new DB schema without downtime?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Decouple the migration from the code deployment&lt;/li&gt;
&lt;li&gt;Make the DB support both schemas (when possible), add new columns&lt;/li&gt;
&lt;li&gt;Deploy the new code (binary change)&lt;/li&gt;
&lt;li&gt;Deprecate the old schema / column&lt;/li&gt;
&lt;li&gt;Once all replicas are updated, remove the old schema / column&lt;/li&gt;
&lt;li&gt;Backwards compatibility for the win!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Slow build times?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Caching (download of dependencies, generated artifacts, generated layers e.g.
docker images)&lt;/li&gt;
&lt;li&gt;Parallelism ‚Äì split + kick off multiple builds / tests (e.g. pytest supports
this)&lt;/li&gt;
&lt;li&gt;Incremental builds ‚Äì e.g. ccache, bazel/blaze, only build the parts of the
graph that have changed&lt;/li&gt;
&lt;li&gt;Only build/test/run modified files -&amp;gt; detect via simple patterns, wildcards&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When chaos ensues, what do you do?&lt;/p&gt;
&lt;p&gt;Roll back immediately! Fix issues later. Do a postmortem analysis later. Easier
when you have cheap and/or automated rollbacks.&lt;/p&gt;
&lt;p&gt;GitOps: ArgoCD, FluxCD. Operator. Agent continually polls, instead of CI pushing
changes. CI does not need access to prod.&lt;/p&gt;
&lt;p&gt;Hermetic / reproducible builds. Code signing. SBOM.&lt;/p&gt;
&lt;p&gt;DORA metrics / product health: deployment frequency, lead time for changes,
change failure rate, time to restore service.&lt;/p&gt;
&lt;p&gt;How to secure CI/CD? Signed commits. Dependency pinning. Dependency cooldowns.
Dependency scanning (some tools available for that). Beware of supply-chain
attacks! Don&amp;rsquo;t store secrets in the repo. Instead, use an external secrets
manager like AWS&amp;rsquo;s, HashiCorp Vault, etc.&lt;/p&gt;
&lt;p&gt;Flaky tests? Quarantine. Disable. Investigate off-line. Do not ever block the
pipeline! Risks losing confidence there.&lt;/p&gt;
&lt;p&gt;Monorepo or various repos? Various repos: harder to maintain consistency,
enforce patterns. Monorepo: LSCs (large-scale changes). CODEOWNERS.&lt;/p&gt;
&lt;p&gt;Security principles?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Confidentiality (pssssh!!)&lt;/li&gt;
&lt;li&gt;Integrity (hashes)&lt;/li&gt;
&lt;li&gt;Availability (99.999%&amp;hellip;)&lt;/li&gt;
&lt;li&gt;Authentication (it&amp;rsquo;s me!)&lt;/li&gt;
&lt;li&gt;Authorization (yes, we can!)&lt;/li&gt;
&lt;li&gt;Non-repudiation (can&amp;rsquo;t deny it!)&lt;/li&gt;
&lt;li&gt;Least privilege. Avoid: security through obscurity.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A kubernetes operator is a specialized controller that aims to reconcile state +
extends the base API with its own CRDs (e.g. external secrets, argocd,
prometheus stack). Watch CRDs, implement lifecycle tasks.&lt;/p&gt;
&lt;p&gt;Do not forget hooks! Even Claude Code has them.&lt;/p&gt;
&lt;p&gt;A Software‚ÄØBill‚ÄØof‚ÄØMaterials is a structured list that enumerates every
component, library, and dependency that makes up a software product. It provides
provenance and version information for each item, enabling stakeholders to
assess security, licensing, and supply‚Äëchain risks. Good for CVEs.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: cicd"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #692: Top K Frequent Words</title><link>https://perrotta.dev/2026/01/leetcode-%23692-top-k-frequent-words/</link><pubDate>Sun, 11 Jan 2026 10:26:15 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23692-top-k-frequent-words/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/top-k-frequent-words"&gt;LeetCode #692: Top K Frequent Words&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter, defaultdict

class Solution:
 def topKFrequent(self, words: List[str], k: int) -&amp;gt; List[str]:
 ## return [word for (word, freq) in Counter(words).most_common()][:k]

 by_freq = defaultdict(list)

 for (word, freq) in Counter(words).most_common():
 by_freq[freq].append(word)

 ans = []

 for (freq, words) in sorted(by_freq.items(), reverse=True):
 ans.extend(sorted(words))
 if len(ans) &amp;gt;= k:
 break

 return ans[:k]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #692: Top K Frequent Words"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>heap</title><link>https://perrotta.dev/2026/01/heap/</link><pubDate>Sun, 11 Jan 2026 09:49:57 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/heap/</guid><description>&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import heapq
# note: NOT from collections import heapq
# mnemonic: &amp;#34;heap priority queue -&amp;gt; heap pq&amp;#34;

pq = [3, 2, 1, 5]
assert heapq.heapify(pq) is None
assert pq == [1, 2, 3, 5]

assert heapq.heappop(pq) == 1 # min heap!
assert heapq.heappop(pq) == 2 # min heap!

pq = [3, 2, 1, 5]
pq = [-num for num in pq]
assert heapq.heapify(pq) is None
assert -heapq.heappop(pq) == 5 # max heap trick
assert -heapq.heappop(pq) == 3 # max heap trick

# built heap from scratch
pq = []
for num in range(5):
 heapq.heappush(pq, num)
assert heapq.heappop(pq) == 0

assert heapq.heappushpop(pq, 6) == 1
assert heapq.heappop(pq) == 2

pq = []
for num in range(5):
 heapq.heappush(pq, num)
assert heapq.heappop(pq) == 0

# heappoppush, essentially ‚Äì why did they name it as heapreplace?
assert heapq.heapreplace(pq, -1) == 1

assert heapq.nlargest(2, pq) == [4, 3]
assert heapq.nsmallest(2, pq) == [-1, 2]

assert pq[0] == -1 # .peek() essentially&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: heap"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #170: Two Sum III - Data structure design</title><link>https://perrotta.dev/2026/01/leetcode-%23170-two-sum-iii-data-structure-design/</link><pubDate>Sun, 11 Jan 2026 08:08:13 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23170-two-sum-iii-data-structure-design/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/two-sum-iii---data-structure-design"&gt;LeetCode #170: Two Sum III ‚Äî Data structure design&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class TwoSum:

 def __init__(self):
 self.s = Counter()


 def add(self, number: int) -&amp;gt; None:
 self.s[number] &amp;#43;= 1


 def find(self, value: int) -&amp;gt; bool:
 for num in self.s:
 if (value - num) == num:
 if self.s[num] &amp;gt; 1:
 return True
 elif value - num in self.s:
 return True

 return False


# Your TwoSum object will be instantiated and called as such:
# obj = TwoSum()
# obj.add(number)
# param_2 = obj.find(value)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #170: Two Sum III - Data structure design"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>deque</title><link>https://perrotta.dev/2026/01/deque/</link><pubDate>Sun, 11 Jan 2026 07:25:28 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/deque/</guid><description>&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

d = deque()
d.append(1)
d.appendleft(2)
assert d == deque([2, 1])
assert list(d) == [2, 1]

d.popleft()
assert d == deque([1])

d = deque(range(4))
d.rotate(1)
assert d == deque([3, 0, 1, 2])

d = deque(range(4))
d.rotate(-1)
assert d == deque([1, 2, 3, 0])

d = deque(maxlen=3)
d.extend(range(4))
assert d == deque([1, 2, 3])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: deque"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>chain map</title><link>https://perrotta.dev/2026/01/chain-map/</link><pubDate>Sat, 10 Jan 2026 18:16:15 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/chain-map/</guid><description>&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import ChainMap

a = {1: 2}
b = {1: 3}
c = {2: 4}

# a has more priority than b, which has more priority than c
d = ChainMap(a, b, c)

assert len(d) == 2
assert d[1] == 2
assert d[2] == 4
d[1] = 3
assert d[1] == 3
assert a[1] == 3
d[2] = 10
assert d[2] == 10
assert a[2] == 10
assert c[2] == 4

del d[2]
assert 2 not in a

e = d.new_child({1: 10})
assert e[1] == 10&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: chain map"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #347: Top K Frequent Elements</title><link>https://perrotta.dev/2026/01/leetcode-%23347-top-k-frequent-elements/</link><pubDate>Sat, 10 Jan 2026 02:09:59 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23347-top-k-frequent-elements/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/top-k-frequent-elements"&gt;LeetCode #347: Top K Frequent Elements&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;Counter&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Solution:
 def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
 return [k for (k, v) in Counter(nums).most_common()[:k]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;defaultdict(int)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

class Solution:
 def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
 c = defaultdict(int)
 for num in nums:
 c[num] &amp;#43;= 1

 return [k for (k, v) in (sorted(c.items(), key=lambda item: item[1], reverse=True))[:k]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With max heap:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter
import heapq

class Solution:
 def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
 # c = defaultdict(int)
 # for num in nums:
 # c[num] &amp;#43;= 1

 # return [k for (k, v) in (sorted(c.items(), key=lambda item: item[1], reverse=True))[:k]]

 counter = Counter(nums)

 class Pair:
 def __init__(self, num, freq):
 self.num = num
 self.freq = freq

 def __lt__(self, other):
 if not isinstance(other, Pair):
 raise ValueError
 # note: &amp;gt; instead of &amp;lt; because we want the TOP elements ‚Äì max heap
 return self.freq &amp;gt; other.freq

 pq = []

 for (num, freq) in counter.items():
 pq.append(Pair(num, freq))

 heapq.heapify(pq)

 ans = []

 for _ in range(k):
 pair = heapq.heappop(pq)
 ans.append(pair.num)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Simpler:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter
import heapq

class Solution:
 def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
 # c = defaultdict(int)
 # for num in nums:
 # c[num] &amp;#43;= 1

 # return [k for (k, v) in (sorted(c.items(), key=lambda item: item[1], reverse=True))[:k]]

 counter = Counter(nums)

 class Pair:
 def __init__(self, num, freq):
 self.num = num
 self.freq = freq

 def __lt__(self, other):
 if not isinstance(other, Pair):
 raise ValueError
 return self.freq &amp;lt; other.freq

 pq = []

 for (num, freq) in counter.items():
 pq.append(Pair(num, freq))

 heapq.heapify(pq)

 ans = []

 return [pair.num for pair in heapq.nlargest(k, pq)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #347: Top K Frequent Elements"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #694: Number of Distinct Islands</title><link>https://perrotta.dev/2026/01/leetcode-%23694-number-of-distinct-islands/</link><pubDate>Sat, 10 Jan 2026 01:50:25 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23694-number-of-distinct-islands/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/number-of-distinct-islands"&gt;LeetCode #694: Number of Distinct Islands&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wrong answer&lt;/strong&gt;: 696 / 760 testcases passed. Directions do not uniquely
identify shapes. Counterexample:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;1 1 1 1
1 0 0 1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;These produce the same directions.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

class Solution:
 def numDistinctIslands(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 ans: set[str] = set()

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def bfs(x, y):
 queue = deque([(x, y)])
 h = [str((0, 0))] # hash

 while queue:
 (x, y) = queue.popleft()

 # if not within_bounds(x, y):
 # continue

 ## if grid[x][y] == -1:
 ## continue

 grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )

 if within_bounds(neighbor[0], neighbor[1]) and grid[neighbor[0]][neighbor[1]] == 1:
 queue.append((neighbor[0], neighbor[1]))
 h.append(str(dir))

 ans.add(&amp;#39;&amp;#39;.join(h))


 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if cell == 1:
 bfs(x, y)

 return len(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Instead, store relative positions. Memory limit exceeded: 714 / 760 testcases
passed.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

class Solution:
 def numDistinctIslands(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 ans: set[str] = set()

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def bfs(initial_x, initial_y):
 queue = deque([(initial_x, initial_y)])
 h = [str((0, 0))] # hash

 while queue:
 (x, y) = queue.popleft()

 # if not within_bounds(x, y):
 # continue

 ## if grid[x][y] == -1:
 ## continue

 grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )

 if within_bounds(neighbor[0], neighbor[1]) and grid[neighbor[0]][neighbor[1]] == 1:
 queue.append((neighbor[0], neighbor[1]))
 h.append(str((neighbor[0] - initial_x, neighbor[1] - initial_y)))

 ans.add(&amp;#39;&amp;#39;.join(h))


 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if cell == 1:
 bfs(x, y)

 return len(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;We need to mark cells as visited right away, before queueing them:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

class Solution:
 def numDistinctIslands(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 ans: set[str] = set()

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def bfs(initial_x, initial_y):
 queue = deque([(initial_x, initial_y)])
 h = [(0, 0)] # hash
 grid[initial_x][initial_y] = -1

 while queue:
 (x, y) = queue.popleft()

 # if not within_bounds(x, y):
 # continue

 ## if grid[x][y] == -1:
 ## continue

 ## grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )

 if within_bounds(neighbor[0], neighbor[1]) and grid[neighbor[0]][neighbor[1]] == 1:
 queue.append((neighbor[0], neighbor[1]))
 grid[neighbor[0]][neighbor[1]] = -1
 h.append((neighbor[0] - initial_x, neighbor[1] - initial_y))

 ## ans.add(frozenset(h))
 ans.add(tuple(sorted(h))) # supposedly faster


 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if cell == 1:
 bfs(x, y)

 return len(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #694: Number of Distinct Islands"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1254: Number of Closed Islands</title><link>https://perrotta.dev/2026/01/leetcode-%231254-number-of-closed-islands/</link><pubDate>Sat, 10 Jan 2026 01:23:06 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231254-number-of-closed-islands/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/number-of-closed-islands"&gt;LeetCode #1254: Number of Closed Islands&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Recursive:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def closedIsland(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def dfs(x, y, poisoned=False):
 if not within_bounds(x, y):
 return True

 if grid[x][y] in [-1, 1]:
 return False

 grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )
 if dfs(neighbor[0], neighbor[1]):
 poisoned = True

 return poisoned

 ans = 0

 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if grid[x][y] == 0:
 if not dfs(x, y):
 ans &amp;#43;= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Iterative:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def closedIsland(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def dfs(x, y):
 valid = True

 stack = [(x, y)]

 while stack:
 (x, y) = stack.pop()

 if not within_bounds(x, y):
 valid = False
 continue

 if grid[x][y] in [-1, 1]:
 continue

 ## assert grid[x][y] == 0
 grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )
 ## if not within_bounds(neighbor[0], neighbor[1]):
 ## return False
 stack.append((neighbor[0], neighbor[1]))

 return valid

 ans = 0

 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if grid[x][y] == 0:
 ans &amp;#43;= dfs(x, y)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1254: Number of Closed Islands"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #200: Number of Islands</title><link>https://perrotta.dev/2026/01/leetcode-%23200-number-of-islands/</link><pubDate>Sat, 10 Jan 2026 00:24:09 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23200-number-of-islands/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/number-of-islands"&gt;LeetCode #200: Number of Islands&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numIslands(self, grid: List[List[str]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def dfs(x, y):
 if not within_bounds(x, y):
 return

 if grid[x][y] in [&amp;#34;-1&amp;#34;, &amp;#34;0&amp;#34;]:
 return

 grid[x][y] = &amp;#34;-1&amp;#34;

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )
 dfs(neighbor[0], neighbor[1])

 ans = 0

 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if grid[x][y] == &amp;#34;1&amp;#34;:
 dfs(x, y)
 ans &amp;#43;= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Pass tuples around:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numIslands(self, grid: List[List[str]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 def within_bounds(coords):
 (a, b) = coords
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def dfs(coords):
 (x, y) = coords
 if not within_bounds(coords):
 return

 if grid[x][y] in [&amp;#34;-1&amp;#34;, &amp;#34;0&amp;#34;]:
 return

 grid[x][y] = &amp;#34;-1&amp;#34;

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )
 dfs(neighbor)

 ans = 0

 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if grid[x][y] == &amp;#34;1&amp;#34;:
 dfs((x, y))
 ans &amp;#43;= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #200: Number of Islands"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1244: Design A Leaderboard</title><link>https://perrotta.dev/2026/01/leetcode-%231244-design-a-leaderboard/</link><pubDate>Sat, 10 Jan 2026 00:12:45 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231244-design-a-leaderboard/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-a-leaderboard"&gt;LeetCode #1244: Design A Leaderboard&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;With Counter:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Leaderboard:

 def __init__(self):
 self.counter = Counter()

 def addScore(self, playerId: int, score: int) -&amp;gt; None:
 self.counter[playerId] &amp;#43;= score

 def top(self, K: int) -&amp;gt; int:
 return sum(v for (k, v) in self.counter.most_common()[:K])

 def reset(self, playerId: int) -&amp;gt; None:
 del self.counter[playerId]
 ## self.counter[playerId] = 0


# Your Leaderboard object will be instantiated and called as such:
# obj = Leaderboard()
# obj.addScore(playerId,score)
# param_2 = obj.top(K)
# obj.reset(playerId)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With priority queue (heap):&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

class Leaderboard:

 def __init__(self):
 self.d = defaultdict(int)

 def addScore(self, playerId: int, score: int) -&amp;gt; None:
 self.d[playerId] &amp;#43;= score

 def top(self, K: int) -&amp;gt; int:
 pq = []

 for score in self.d.values():
 heapq.heappush(pq, score)
 if len(pq) &amp;gt; K:
 heapq.heappop(pq)

 return sum(pq)

 def reset(self, playerId: int) -&amp;gt; None:
 del self.d[playerId]


# Your Leaderboard object will be instantiated and called as such:
# obj = Leaderboard()
# obj.addScore(playerId,score)
# param_2 = obj.top(K)
# obj.reset(playerId)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1244: Design A Leaderboard"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #2490: Circular Sentence</title><link>https://perrotta.dev/2026/01/leetcode-%232490-circular-sentence/</link><pubDate>Sat, 10 Jan 2026 00:05:44 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%232490-circular-sentence/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/circular-sentence"&gt;LeetCode #2490: Circular Sentence&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def isCircularSentence(self, sentence: str) -&amp;gt; bool:
 # case sensitive

 words = sentence.strip().split(&amp;#39; &amp;#39;)

 for word1, word2 in zip(
 words,
 words[1:] &amp;#43; [words[0]]
 ):
 if word1[-1] != word2[0]:
 return False

 return True&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #2490: Circular Sentence"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #286: Walls and Gates</title><link>https://perrotta.dev/2026/01/leetcode-%23286-walls-and-gates/</link><pubDate>Fri, 09 Jan 2026 23:57:56 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23286-walls-and-gates/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/walls-and-gates"&gt;LeetCode #286: Walls and Gates&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Level order traversal:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

class Solution:
 def wallsAndGates(self, rooms: List[List[int]]) -&amp;gt; None:
 &amp;#34;&amp;#34;&amp;#34;
 Do not return anything, modify rooms in-place instead.
 &amp;#34;&amp;#34;&amp;#34;
 m = len(rooms)
 n = len(rooms[0])

 INF = 2 ** 31 - 1

 def bfs(x, y):
 queue = deque([(x, y)])

 dirs = [
 (0, 1),
 (1, 0),
 (0, -1),
 (-1, 0),
 ]

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 level = 0
 while queue:
 level &amp;#43;= 1
 num_elements = len(queue)

 for _ in range(num_elements):
 (x, y) = queue.popleft()

 for dir in dirs:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )

 if within_bounds(neighbor[0], neighbor[1]):
 value = rooms[neighbor[0]][neighbor[1]]

 if value == 0 or value == -1:
 continue

 if level &amp;lt; value:
 rooms[neighbor[0]][neighbor[1]] = level
 queue.append((neighbor[0], neighbor[1]))



 for x, row in enumerate(rooms):
 for y, cell in enumerate(row):
 if cell == 0:
 bfs(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #286: Walls and Gates"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1472: Design Browser History</title><link>https://perrotta.dev/2026/01/leetcode-%231472-design-browser-history/</link><pubDate>Fri, 09 Jan 2026 22:07:44 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231472-design-browser-history/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-browser-history"&gt;LeetCode #1472: Design Browser History&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class BrowserHistory:

 def __init__(self, homepage: str):
 self.history = [homepage]
 self.pos = 0

 # example.com &amp;lt;-
 # example.org
 # foo.example.com &amp;lt;=


 def visit(self, url: str) -&amp;gt; None:
 if self.pos == (len(self.history) - 1):
 self.history.append(url)
 self.pos &amp;#43;= 1
 else:
 self.pos &amp;#43;= 1
 self.history[self.pos] = url
 self.history = self.history[:self.pos &amp;#43; 1]


 def back(self, steps: int) -&amp;gt; str:
 steps = min(steps, self.pos)
 self.pos -= steps
 return self.history[self.pos]


 def forward(self, steps: int) -&amp;gt; str:
 steps = min(steps, len(self.history) - 1 - self.pos)
 self.pos &amp;#43;= steps
 return self.history[self.pos]


# Your BrowserHistory object will be instantiated and called as such:
# obj = BrowserHistory(homepage)
# obj.visit(url)
# param_2 = obj.back(steps)
# param_3 = obj.forward(steps)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1472: Design Browser History"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1188: Design Bounded Blocking Queue</title><link>https://perrotta.dev/2026/01/leetcode-%231188-design-bounded-blocking-queue/</link><pubDate>Fri, 09 Jan 2026 21:58:29 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231188-design-bounded-blocking-queue/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-bounded-blocking-queue"&gt;LeetCode #1188: Design Bounded Blocking Queue&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque
from threading import Lock, Condition

class BoundedBlockingQueue(object):

 def __init__(self, capacity: int):
 self.q = deque()
 self.capacity = capacity
 self.lock = Lock()
 self.not_full = Condition(self.lock)
 self.not_empty = Condition(self.lock)


 def enqueue(self, element: int) -&amp;gt; None:
 self.not_full.acquire()

 while self.size() == self.capacity:
 self.not_full.wait()

 self.q.append(element)
 self.not_empty.notify()
 self.not_full.release()

 def dequeue(self) -&amp;gt; int:
 self.not_empty.acquire()

 while self.size() == 0:
 self.not_empty.wait()

 element = self.q.popleft()
 self.not_full.notify()
 self.not_empty.release()

 return element


 def size(self) -&amp;gt; int:
 return len(self.q)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1188: Design Bounded Blocking Queue"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1756: Design Most Recently Used Queue</title><link>https://perrotta.dev/2026/01/leetcode-%231756-design-most-recently-used-queue/</link><pubDate>Fri, 09 Jan 2026 21:53:51 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231756-design-most-recently-used-queue/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-most-recently-used-queue"&gt;LeetCode #1756: Design Most Recently Used Queue&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class MRUQueue:

 def __init__(self, n: int):
 self.arr = list(range(1, n &amp;#43; 1))

 def fetch(self, k: int) -&amp;gt; int:
 # 0-indexed
 k -= 1

 assert 0 &amp;lt;= k &amp;lt; len(self.arr)

 el = self.arr[k]

 del self.arr[k]
 self.arr.append(el)

 return el

# Your MRUQueue object will be instantiated and called as such:
# obj = MRUQueue(n)
# param_1 = obj.fetch(k)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1756: Design Most Recently Used Queue"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #622: Design Circular Queue</title><link>https://perrotta.dev/2026/01/leetcode-%23622-design-circular-queue/</link><pubDate>Fri, 09 Jan 2026 04:35:00 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23622-design-circular-queue/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-circular-queue"&gt;LeetCode #622: Design Circular Queue&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class MyCircularQueue:

 def __init__(self, k: int):
 self.q = [None] * k
 self.k = k

 self.start = 0
 self.end = 0
 self.count = 0

 ## -- queue

 ## . . .
 ## se

 ## 1 . .
 ## s e

 ## 1 . 2
 ## s e

 ## -- dequeue

 ## 1 . 2
 ## s e

 ## . . 2
 ## e s

 def enQueue(self, value: int) -&amp;gt; bool:
 if self.isFull():
 return False

 self.q[self.end] = value
 self.end = (self.end - 1) % self.k
 self.count &amp;#43;= 1
 return True


 def deQueue(self) -&amp;gt; bool:
 if self.isEmpty():
 return False

 self.start = (self.start - 1) % self.k
 self.count -= 1
 return True


 def Front(self) -&amp;gt; int:
 if self.isEmpty():
 return -1

 return self.q[self.start]


 def Rear(self) -&amp;gt; int:
 if self.isEmpty():
 return -1

 return self.q[(self.end &amp;#43; 1) % self.k]


 def isEmpty(self) -&amp;gt; bool:
 return self.count == 0


 def isFull(self) -&amp;gt; bool:
 return self.count == self.k


# Your MyCircularQueue object will be instantiated and called as such:
# obj = MyCircularQueue(k)
# param_1 = obj.enQueue(value)
# param_2 = obj.deQueue()
# param_3 = obj.Front()
# param_4 = obj.Rear()
# param_5 = obj.isEmpty()
# param_6 = obj.isFull()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #622: Design Circular Queue"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #641: Design Circular Deque</title><link>https://perrotta.dev/2026/01/leetcode-%23641-design-circular-deque/</link><pubDate>Fri, 09 Jan 2026 04:20:38 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23641-design-circular-deque/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-circular-deque"&gt;LeetCode #641: Design Circular Deque&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class MyCircularDeque:

 def __init__(self, k: int):
 self.q = [None] * k
 self.k = k

 self.start = 0
 self.end = 0
 self.count = 0

 ## . . . .
 ## se

 ## . 1 . .
 ## s e

 ## . 2 3 .
 ## s e

 def insertFront(self, value: int) -&amp;gt; bool:
 if self.isEmpty():
 self.q[self.start] = value
 self.start = (self.start - 1) % self.k
 self.end = (self.end &amp;#43; 1) % self.k
 self.count &amp;#43;= 1
 return True

 if self.isFull():
 return False

 self.q[self.start] = value
 self.start = (self.start - 1) % self.k
 self.count &amp;#43;= 1
 return True


 def insertLast(self, value: int) -&amp;gt; bool:
 if self.isEmpty():
 self.q[self.end] = value
 self.start = (self.start - 1) % self.k
 self.end = (self.end &amp;#43; 1) % self.k
 self.count &amp;#43;= 1
 return True

 if self.isFull():
 return False

 self.q[self.end] = value
 self.end = (self.end &amp;#43; 1) % self.k
 self.count &amp;#43;= 1
 return True


 def deleteFront(self) -&amp;gt; bool:
 if self.isEmpty():
 return False

 self.start = (self.start &amp;#43; 1) % self.k
 self.count -= 1
 ## self.q[self.start] = None

 if self.count == 0:
 self.end = self.start

 return True


 def deleteLast(self) -&amp;gt; bool:
 if self.isEmpty():
 return False

 self.end = (self.end - 1) % self.k
 self.count -= 1
 ## self.q[self.end] = None

 if self.count == 0:
 self.start = self.end

 return True

 def getFront(self) -&amp;gt; int:
 if self.isEmpty():
 return -1
 return self.q[(self.start &amp;#43; 1) % self.k]


 def getRear(self) -&amp;gt; int:
 if self.isEmpty():
 return -1
 return self.q[self.end - 1 % self.k]


 def isEmpty(self) -&amp;gt; bool:
 return self.count == 0


 def isFull(self) -&amp;gt; bool:
 return self.count == self.k



# Your MyCircularDeque object will be instantiated and called as such:
# obj = MyCircularDeque(k)
# param_1 = obj.insertFront(value)
# param_2 = obj.insertLast(value)
# param_3 = obj.deleteFront()
# param_4 = obj.deleteLast()
# param_5 = obj.getFront()
# param_6 = obj.getRear()
# param_7 = obj.isEmpty()
# param_8 = obj.isFull()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #641: Design Circular Deque"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #211: Design Add and Search Words Data Structure</title><link>https://perrotta.dev/2026/01/leetcode-%23211-design-add-and-search-words-data-structure/</link><pubDate>Thu, 08 Jan 2026 03:43:06 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23211-design-add-and-search-words-data-structure/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-add-and-search-words-data-structure"&gt;LeetCode #211: Design Add and Search Words Data Structure&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

class Node:
 def __init__(self):
 self.children = {}
 self.end = False

class WordDictionary:

 def __init__(self):
 self.root = Node()

 def addWord(self, word: str) -&amp;gt; None:
 node = self.root
 ## &amp;#34;hello&amp;#34;
 for c in word:
 if c not in node.children:
 node.children[c] = Node()
 node = node.children[c]
 node.end = True

 def search(self, word: str) -&amp;gt; bool:
 def node_search(node, word: str) -&amp;gt; bool:
 for i, c in enumerate(word):
 if c == &amp;#39;.&amp;#39;:
 for child in node.children.values():
 if node_search(child, word[i &amp;#43; 1:]):
 return True
 return False

 if c not in node.children:
 return False
 node = node.children[c]

 return node.end

 return node_search(self.root, word)


# Your WordDictionary object will be instantiated and called as such:
# obj = WordDictionary()
# obj.addWord(word)
# param_2 = obj.search(word)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #211: Design Add and Search Words Data Structure"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>int</title><link>https://perrotta.dev/2026/01/int/</link><pubDate>Thu, 08 Jan 2026 00:50:53 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><guid>https://perrotta.dev/2026/01/int/</guid><description>&lt;p&gt;Integers, bits and bytes:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;assert int(&amp;#39;10&amp;#39;) == 10
assert int(&amp;#39;010&amp;#39;) == 10
assert int(&amp;#39;0x10&amp;#39;, base=16) == 16
assert int(&amp;#39;10&amp;#39;, base=16) == 16
assert int(&amp;#39;0o10&amp;#39;, base=8) == 8
assert int(&amp;#39;10&amp;#39;, base=8) == 8
assert int(&amp;#39;0b10&amp;#39;, base=2) == 2
assert int(&amp;#39;10&amp;#39;, base=2) == 2

assert bin(10) == &amp;#34;0b1010&amp;#34;
assert bin(1) == &amp;#34;0b1&amp;#34;
assert bin(0) == &amp;#34;0b0&amp;#34;

assert oct(10) == &amp;#34;0o12&amp;#34;

assert hex(10) == &amp;#34;0xa&amp;#34;
assert int(&amp;#39;0xFF&amp;#39;, base=16) == 255

assert abs(-10) == 10

assert 5 % 3 == 2 ## mod

assert 5 ** 2 == 25

## 0b110
assert (6).bit_count() == 2
assert int(6).bit_count() == 2
# assert 6.bit_count() == 2 ## this fails

assert int(6).bit_length() == 3

def bit_length(n):
 assert isinstance(n, int)
 ans = 0
 while n &amp;gt; 0:
 n &amp;gt;&amp;gt;= 1
 ans &amp;#43;= 1
 return ans

assert bit_length(6) == 3
assert bit_length(7) == 3
assert bit_length(8) == 4

def bit_count(n):
 assert isinstance(n, int)
 ans = 0
 while n &amp;gt; 0:
 ans &amp;#43;= n &amp;amp; 1
 n &amp;gt;&amp;gt;= 1
 return ans

assert bit_count(6) == 2
assert bit_count(7) == 3
assert bit_count(8) == 1

from math import floor, ceil

assert floor(3.5) == 3
assert ceil(3.5) == 4

assert floor(3) == 3
assert ceil(3) == 3

assert float(3.4).__round__() == 3
assert round(3.4) == 3
assert round(3.7) == 4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: int"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #2965: Find Missing and Repeated Values</title><link>https://perrotta.dev/2026/01/leetcode-%232965-find-missing-and-repeated-values/</link><pubDate>Thu, 08 Jan 2026 00:24:02 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%232965-find-missing-and-repeated-values/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/find-missing-and-repeated-values"&gt;LeetCode #2965: Find Missing and Repeated Values&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Two sets:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def findMissingAndRepeatedValues(self, grid: List[List[int]]) -&amp;gt; List[int]:
 seen = set()
 numbers = set(range(1, len(grid) ** 2 &amp;#43; 1))

 a = b = None

 for row in grid:
 for num in row:
 if num in seen:
 a = num
 continue
 seen.add(num)
 numbers.discard(num)

 assert len(numbers) == 1
 b = numbers.pop()

 return [a, b]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #2965: Find Missing and Repeated Values"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1033: Moving Stones Until Consecutive</title><link>https://perrotta.dev/2026/01/leetcode-%231033-moving-stones-until-consecutive/</link><pubDate>Wed, 07 Jan 2026 23:53:36 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231033-moving-stones-until-consecutive/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/moving-stones-until-consecutive"&gt;LeetCode #1033: Moving Stones Until Consecutive&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Convoluted:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numMovesStones(self, a: int, b: int, c: int) -&amp;gt; List[int]:
 (a, b, c) = sorted([a, b, c])

 ans_max = ((c - b) - 1) &amp;#43; ((b - a) - 1)

 ans_min = 0
 while not ((b - a) == 1 and (c - b) == 1): ## 3 4 5
 ## 3 10 50

 if (b - a) == 1 or (c - b) == 1:
 ans_min &amp;#43;= 1
 break

 # find smallest interval with a gap
 ## (3, 10)
 if (c - b == 1) or (b - a) &amp;lt;= (c - b): # left
 e1 = a
 e2 = b
 ms = c
 else: ## right
 e1 = b
 e2 = c
 ms = a

 # move the other stone (ms) to the middle of (e1, e2)
 ms = (e1 &amp;#43; e2) // 2

 # update a, b, c; then keep going
 a, b, c = e1, ms, e2
 assert a &amp;lt; b
 assert b &amp;lt; c

 ans_min &amp;#43;= 1
 if ans_min == 2:
 break

 return [ans_min, ans_max]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;min_ans&lt;/code&gt; will be up to 2. That will significantly simplify everything!&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numMovesStones(self, a: int, b: int, c: int) -&amp;gt; List[int]:
 (a, b, c) = sorted([a, b, c])

 ans_max = ((c - b) - 1) &amp;#43; ((b - a) - 1)

 ans_min = 0
 if ((b - a) == 1 and (c - b) == 1): ## 3 4 5
 ans_min = 0
 elif (b - a) in [1, 2] or (c - b) in [1, 2]: ## 3 4 6
 ans_min = 1
 else:
 ans_min = 2

 return [ans_min, ans_max]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1033: Moving Stones Until Consecutive"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #771: Jewels and Stones</title><link>https://perrotta.dev/2026/01/leetcode-%23771-jewels-and-stones/</link><pubDate>Wed, 07 Jan 2026 01:18:30 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23771-jewels-and-stones/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/jewels-and-stones"&gt;LeetCode #771: Jewels and Stones&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Cozy:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numJewelsInStones(self, jewels: str, stones: str) -&amp;gt; int:
 s = set(jewels)

 ans = 0

 for stone in stones:
 if stone in s:
 ans &amp;#43;= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;One-liner:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numJewelsInStones(self, jewels: str, stones: str) -&amp;gt; int:
 s = set(jewels)
 return sum(stone in s for stone in stones)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #771: Jewels and Stones"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #652: Find Duplicate Subtrees</title><link>https://perrotta.dev/2026/01/leetcode-%23652-find-duplicate-subtrees/</link><pubDate>Wed, 07 Jan 2026 00:49:44 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23652-find-duplicate-subtrees/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/find-duplicate-subtrees"&gt;LeetCode #652: Find Duplicate Subtrees&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Original, 119 / 175 testcases passed:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

# Definition for a binary tree node.
# class TreeNode:
# def __init__(self, val=0, left=None, right=None):
# self.val = val
# self.left = left
# self.right = right
class Solution:
 def findDuplicateSubtrees(self, root: Optional[TreeNode]) -&amp;gt; List[Optional[TreeNode]]:
 mappings = defaultdict(list)

 def dfs(node):
 if not node:
 return

 mappings[node.val].append(node)

 dfs(node.left)
 dfs(node.right)

 dfs(root)

 ans = set()

 def duplicate_subtree(node1, node2):
 if not node1 and not node2:
 return True

 if not node1 and node2:
 return False

 if node1 and not node2:
 return False

 return node1.val == node2.val and duplicate_subtree(node1.left, node2.left) and duplicate_subtree(node1.right, node2.right)

 for nodes in mappings.values():
 for i, node1 in enumerate(nodes[:-1]):
 for node2 in nodes[i &amp;#43; 1:]:
 if duplicate_subtree(node1, node2):
 ans.add(node1)

 return list(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With proper serialization:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;from collections import Counter

class Solution:
 def findDuplicateSubtrees(self, root: Optional[TreeNode]) -&amp;gt; List[Optional[TreeNode]]:
 # serial -&amp;gt; count
 seen = Counter()

 # serial -&amp;gt; node
 node_from_serial = {}

 def dfs(node) -&amp;gt; str:
 &amp;#34;&amp;#34;&amp;#34;Return the serialized representation of the node.&amp;#34;&amp;#34;&amp;#34;
 if not node:
 return &amp;#34;null&amp;#34;

 s = f&amp;#34;{node.val},{dfs(node.left)},{dfs(node.right)}&amp;#34;

 node_from_serial[s] = node

 seen[s] &amp;#43;= 1

 return s

 dfs(root)

 ans = []

 for (serial, count) in seen.items():
 if count &amp;gt;= 2:
 ans.append(node_from_serial[serial])

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Optimized:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Solution:
 def findDuplicateSubtrees(self, root: Optional[TreeNode]) -&amp;gt; List[Optional[TreeNode]]:
 # serial -&amp;gt; count
 seen = Counter()

 ans = []

 def dfs(node) -&amp;gt; str:
 &amp;#34;&amp;#34;&amp;#34;Return the serialized representation of the node.&amp;#34;&amp;#34;&amp;#34;
 if not node:
 return &amp;#34;null&amp;#34;

 s = f&amp;#34;{node.val},{dfs(node.left)},{dfs(node.right)}&amp;#34;

 seen[s] &amp;#43;= 1

 if seen[s] == 2:
 ans.append(node)

 return s

 dfs(root)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #652: Find Duplicate Subtrees"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #36: Valid Sudoku</title><link>https://perrotta.dev/2026/01/leetcode-%2336-valid-sudoku/</link><pubDate>Wed, 07 Jan 2026 00:10:01 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%2336-valid-sudoku/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/valid-sudoku"&gt;LeetCode #36: Valid Sudoku&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def isValidSudoku(self, board: List[List[str]]) -&amp;gt; bool:
 m = len(board)
 n = len(board[0])

 def is_valid(a):
 a = [el for el in a if el != &amp;#34;.&amp;#34;]
 ## [1, 2, 2] -&amp;gt; 3
 ## {1, 2} -&amp;gt; 2
 ##
 ## [1, 2]
 ## {1, 2}
 return len(a) - len(set(a)) == 0

 for row in board:
 if not is_valid(row):
 return False

 for col in zip(*board):
 if not is_valid(col):
 return False

 subgrids_i = [
 [0, 0],
 [0, 3],
 [0, 6],
 [3, 0],
 [3, 3],
 [3, 6],
 [6, 0],
 [6, 3],
 [6, 6],
 ]

 for subgrid_i in subgrids_i:
 subgrid = []

 for x in range(3):
 for y in range(3):
 ix = subgrid_i[0] &amp;#43; x
 iy = subgrid_i[1] &amp;#43; y
 subgrid.append(board[ix][iy])

 if not is_valid(subgrid):
 return False

 return True&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #36: Valid Sudoku"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #49: Group Anagrams</title><link>https://perrotta.dev/2026/01/leetcode-%2349-group-anagrams/</link><pubDate>Tue, 06 Jan 2026 23:55:13 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%2349-group-anagrams/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/group-anagrams"&gt;LeetCode #49: Group Anagrams&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict
from collections.abc import Hashable

def is_hashable(obj) -&amp;gt; bool:
 return isinstance(obj, Hashable)

class Solution:
 def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]:
 seen = defaultdict(list)

 for s in strs:
 cs = &amp;#39;&amp;#39;.join(sorted(s)) # canonical
 seen[cs].append(s)

 return list(seen.values())&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #49: Group Anagrams"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #359: Logger Rate Limiter</title><link>https://perrotta.dev/2026/01/leetcode-%23359-logger-rate-limiter/</link><pubDate>Tue, 06 Jan 2026 23:45:02 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23359-logger-rate-limiter/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/logger-rate-limiter"&gt;LeetCode #359: Logger Rate Limiter&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Logger:

 def __init__(self):
 self.log = {}


 def shouldPrintMessage(self, timestamp: int, message: str) -&amp;gt; bool:
 if message not in self.log:
 self.log[message] = timestamp
 return True

 if timestamp - self.log[message] &amp;lt; 10:
 return False

 self.log[message] = timestamp
 return True



# Your Logger object will be instantiated and called as such:
# obj = Logger()
# param_1 = obj.shouldPrintMessage(timestamp,message)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #359: Logger Rate Limiter"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #2215: Find the Difference of Two Arrays</title><link>https://perrotta.dev/2026/01/leetcode-%232215-find-the-difference-of-two-arrays/</link><pubDate>Tue, 06 Jan 2026 23:30:46 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%232215-find-the-difference-of-two-arrays/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/find-the-difference-of-two-arrays"&gt;LeetCode #2215: Find the Difference of Two Arrays&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def findDifference(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[List[int]]:
 s1 = set(nums1)
 s2 = set(nums2)

 return [list(s1 - s2), list(s2 - s1)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #2215: Find the Difference of Two Arrays"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #219: Contains Duplicate II</title><link>https://perrotta.dev/2026/01/leetcode-%23219-contains-duplicate-ii/</link><pubDate>Tue, 06 Jan 2026 21:10:50 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23219-contains-duplicate-ii/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/contains-duplicate-ii"&gt;LeetCode #219: Contains Duplicate II&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

class Solution:
 def containsNearbyDuplicate(self, nums: List[int], k: int) -&amp;gt; bool:
 d = defaultdict(list)
 for i, num in enumerate(nums):
 d[num].append(i)

 for values in d.values():
 values.sort()
 # 1 3 4
 for a, b in zip(values[:-1], values[1:]):
 if abs(a - b) &amp;lt;= k:
 return True

 return False&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #219: Contains Duplicate II"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>