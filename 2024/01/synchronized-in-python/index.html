<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>★ Synchronized in Python | Not Just Serendipity</title>
<meta name=keywords content="dev,bestof"><meta name=description content="
In Java, you can make a variable thread safe by just adding the synchronized
keyword. Is there anything that can achieve the same results in
Python?
"><meta name=author content="Thiago Perrotta"><link rel=canonical href=https://thiagowfx.github.io/2024/01/synchronized-in-python/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://thiagowfx.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://thiagowfx.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://thiagowfx.github.io/favicon.ico><link rel=apple-touch-icon href=https://thiagowfx.github.io/apple-touch-icon.png><link rel=mask-icon href=https://thiagowfx.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>body{font-family:Crimson Pro,Vollkorn,Alegreya,Iowan Old Style,Apple Garamond,Baskerville,Times New Roman,Noto Serif,Droid Serif,Times,Source Serif Pro,serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}h1,h2,h3,h4,h5,h6,footer,nav,.toc,.post-meta{font-family:Inter,Fira Sans,Lato,system-ui,-apple-system,BlinkMacSystemFont,Avenir Next,Avenir,Segoe UI,Helvetica Neue,Helvetica,Ubuntu,Roboto,Noto,Cantarell,Arial,sans-serif}code,pre{font-family:Fira Code,PT Mono,IBM Plex Mono,Menlo,Consolas,Monaco,Liberation Mono,Ubuntu Mono,Lucida Console,monospace}</style><meta property="og:title" content="★ Synchronized in Python"><meta property="og:description" content="
In Java, you can make a variable thread safe by just adding the synchronized
keyword. Is there anything that can achieve the same results in
Python?
"><meta property="og:type" content="article"><meta property="og:url" content="https://thiagowfx.github.io/2024/01/synchronized-in-python/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-15T14:42:51-03:00"><meta property="article:modified_time" content="2024-01-15T14:42:51-03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="★ Synchronized in Python"><meta name=twitter:description content="
In Java, you can make a variable thread safe by just adding the synchronized
keyword. Is there anything that can achieve the same results in
Python?
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://thiagowfx.github.io/posts/"},{"@type":"ListItem","position":2,"name":"★ Synchronized in Python","item":"https://thiagowfx.github.io/2024/01/synchronized-in-python/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"★ Synchronized in Python","name":"★ Synchronized in Python","description":" In Java, you can make a variable thread safe by just adding the synchronized keyword. Is there anything that can achieve the same results in Python?\n","keywords":["dev","bestof"],"articleBody":" In Java, you can make a variable thread safe by just adding the synchronized keyword. Is there anything that can achieve the same results in Python?\nWithout having prior knowledge of any python libraries to do so, the primitive interface I would expect resembles the following:\nclass Foo(object): def __init__(self): self.lock = Lock() def perform_mutation(self, bytes): print(bytes) def write(self, bytes): self.lock.acquire() self.perform_mutation(bytes) self.lock.release() This isn’t robust: if an exception happens in perform_mutation the lock would never be released. A small improvement we can make is to wrap it with try/finally:\nclass Foo(object): def __init__(self): self.lock = Lock() def perform_mutation(self, bytes): print(bytes) def write(self, bytes): self.lock.acquire() try: self.perform_mutation(bytes) finally: self.lock.release() However it turns out there’s a more pythonic way to do so:\nfrom threading import Lock class Foo(object): def __init__(self): self.lock = Lock() def perform_mutation(self, bytes): print(bytes) def write(self, bytes): with self.lock: self.perform_mutation(bytes) How can we test this? First, let’s use a single thread.\nif __name__ == \"__main__\": foo = Foo() foo.write(\"hello from the main thread\") Now let’s use multiple threads:\nif __name__ == \"__main__\": foo = Foo() threads = [] for i in range(10): thread = Thread(target=foo.write, args=(f\"hello from thread {i}\",)) threads.append(thread) # Start all threads for thread in threads: thread.start() # Wait for all threads to finish for thread in threads: thread.join() Without the lock this is one of the results I get locally:\n% python3 lock.py hello from thread 0 hello from thread 1 hello from thread 2 hello from thread 3 hello from thread 4 hello from thread 6 hello from thread 8 hello from thread 7 hello from thread 5 hello from thread 9 With the lock I always get the following, as you would predict:\n% python3 lock.py hello from thread 0 hello from thread 1 hello from thread 2 hello from thread 3 hello from thread 4 hello from thread 5 hello from thread 6 hello from thread 7 hello from thread 8 hello from thread 9 We could go one level deeper in the abstraction by using a @synchronized decorator:\nclass Foo(object): def perform_mutation(self, bytes): print(bytes) @synchronized def write(self, bytes): self.perform_mutation(bytes) How do we implement it?\ndef synchronized(member): @wraps(member) def wrapper(*args, **kwargs): lock = vars(member).get(\"_synchronized_lock\", None) if lock is None: lock = vars(member).setdefault(\"_synchronized_lock\", Lock()) with lock: return member(*args, **kwargs) return wrapper One last concept to learn: RLock a.k.a. reentrant lock.\nConsider the following program:\nfrom threading import Lock, Thread class Foo: def __init__(self): self.lock = Lock() def changeA(self, bytes): with self.lock: print(bytes) def changeB(self, bytes): with self.lock: print(bytes) def changeAandB(self, bytes): with self.lock: print(bytes) self.changeA(bytes) # a usual lock would block here self.changeB(bytes) Invoked as follows:\nfoo = Foo() threads = [] for i in range(5): thread = Thread(target=foo.changeA, args=(f\"hello from thread {i} A\",)) threads.append(thread) thread = Thread(target=foo.changeB, args=(f\"hello from thread {i} B\",)) threads.append(thread) thread = Thread(target=foo.changeAandB, args=(f\"hello from thread {i} AB\",)) threads.append(thread) # Start all threads for thread in threads: thread.start() # Wait for all threads to finish for thread in threads: thread.join() It will not work as expected. As soon as the first changeAandB gets called, its inner self.changeA call will block. This is because the lock can only be acquired once.\nIn this specific example, the straightforward way to fix the issue is to use an RLock: self.lock = RLock(). The reentrant lock can be locked multiple times.\nReferences https://theorangeduck.com/page/synchronized-python https://stackoverflow.com/questions/29158282/how-to-create-a-synchronized-function-across-all-instances https://stackoverflow.com/questions/53026622/python-equivalent-of-java-synchronized https://stackoverflow.com/questions/16567958/when-and-how-to-use-pythons-rlock ","wordCount":"553","inLanguage":"en","datePublished":"2024-01-15T14:42:51-03:00","dateModified":"2024-01-15T14:42:51-03:00","author":{"@type":"Person","name":"Thiago Perrotta"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://thiagowfx.github.io/2024/01/synchronized-in-python/"},"publisher":{"@type":"Person","name":"Not Just Serendipity","logo":{"@type":"ImageObject","url":"https://thiagowfx.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://thiagowfx.github.io/ accesskey=h title="Not Just Serendipity (Alt + H)"><img src=https://thiagowfx.github.io/apple-touch-icon.png alt aria-label=logo height=32>Not Just Serendipity</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://thiagowfx.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://thiagowfx.github.io/archives/ title=archives><span>archives</span></a></li><li><a href=https://thiagowfx.github.io/tags/bestof/ title=bestof><span>bestof</span></a></li><li><a href=https://thiagowfx.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://thiagowfx.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>★ Synchronized in Python</h1><div class=post-meta><span title='2024-01-15 14:42:51 -0300 -0300'>January 15, 2024</span>&nbsp;·&nbsp;553 words&nbsp;·&nbsp;Thiago Perrotta</div></header><div class=post-content><blockquote><p><a href=https://stackoverflow.com/questions/53026622/python-equivalent-of-java-synchronized>In Java, you can make a variable thread safe by just adding the <code>synchronized</code>
keyword. Is there anything that can achieve the same results in
Python?</a></p></blockquote><p>Without having prior knowledge of any python libraries to do so, the primitive interface
I would expect resembles the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>(object):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> Lock()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>perform_mutation</span>(self, bytes):
</span></span><span style=display:flex><span>    print(bytes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>write</span>(self, bytes):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>lock<span style=color:#f92672>.</span>acquire()
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>perform_mutation(bytes)
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>lock<span style=color:#f92672>.</span>release()
</span></span></code></pre></div><p>This isn&rsquo;t robust: if an exception happens in <code>perform_mutation</code> the lock would
never be released. A small improvement we can make is to wrap it with
<code>try/finally</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>(object):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> Lock()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>perform_mutation</span>(self, bytes):
</span></span><span style=display:flex><span>    print(bytes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>write</span>(self, bytes):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>lock<span style=color:#f92672>.</span>acquire()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>      self<span style=color:#f92672>.</span>perform_mutation(bytes)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>:
</span></span><span style=display:flex><span>      self<span style=color:#f92672>.</span>lock<span style=color:#f92672>.</span>release()
</span></span></code></pre></div><p>However it turns out there&rsquo;s a more pythonic way to do so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> threading <span style=color:#f92672>import</span> Lock
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>(object):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> Lock()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>perform_mutation</span>(self, bytes):
</span></span><span style=display:flex><span>    print(bytes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>write</span>(self, bytes):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>      self<span style=color:#f92672>.</span>perform_mutation(bytes)
</span></span></code></pre></div><p>How can we test this? First, let&rsquo;s use a single thread.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>  foo <span style=color:#f92672>=</span> Foo()
</span></span><span style=display:flex><span>  foo<span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#34;hello from the main thread&#34;</span>)
</span></span></code></pre></div><p>Now let&rsquo;s use multiple threads:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;__main__&#34;</span>:
</span></span><span style=display:flex><span>  foo <span style=color:#f92672>=</span> Foo()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  threads <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
</span></span><span style=display:flex><span>    thread <span style=color:#f92672>=</span> Thread(target<span style=color:#f92672>=</span>foo<span style=color:#f92672>.</span>write, args<span style=color:#f92672>=</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;hello from thread </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>,))
</span></span><span style=display:flex><span>    threads<span style=color:#f92672>.</span>append(thread)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Start all threads</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>    thread<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Wait for all threads to finish</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>    thread<span style=color:#f92672>.</span>join()
</span></span></code></pre></div><p>Without the lock this is one of the results I get locally:</p><pre tabindex=0><code>% python3 lock.py
hello from thread 0
hello from thread 1
hello from thread 2
hello from thread 3
hello from thread 4
hello from thread 6
hello from thread 8
hello from thread 7
hello from thread 5
hello from thread 9
</code></pre><p>With the lock I always get the following, as you would predict:</p><pre tabindex=0><code>% python3 lock.py
hello from thread 0
hello from thread 1
hello from thread 2
hello from thread 3
hello from thread 4
hello from thread 5
hello from thread 6
hello from thread 7
hello from thread 8
hello from thread 9
</code></pre><p>We could go one level deeper in the abstraction by using a <code>@synchronized</code> decorator:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>(object):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>perform_mutation</span>(self, bytes):
</span></span><span style=display:flex><span>    print(bytes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@synchronized</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>write</span>(self, bytes):
</span></span><span style=display:flex><span>    self<span style=color:#f92672>.</span>perform_mutation(bytes)
</span></span></code></pre></div><p>How do we implement it?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>synchronized</span>(member):
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@wraps</span>(member)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>wrapper</span>(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs):
</span></span><span style=display:flex><span>        lock <span style=color:#f92672>=</span> vars(member)<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;_synchronized_lock&#34;</span>, <span style=color:#66d9ef>None</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> lock <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>            lock <span style=color:#f92672>=</span> vars(member)<span style=color:#f92672>.</span>setdefault(<span style=color:#e6db74>&#34;_synchronized_lock&#34;</span>, Lock())
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> lock:
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> member(<span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> wrapper
</span></span></code></pre></div><p>One last concept to learn: <code>RLock</code> a.k.a. reentrant lock.</p><p>Consider the following program:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span><span style=color:#f92672>from</span> threading <span style=color:#f92672>import</span> Lock, Thread
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> Lock()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>changeA</span>(self, bytes):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>            print(bytes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>changeB</span>(self, bytes):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>            print(bytes)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>changeAandB</span>(self, bytes):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>            print(bytes)
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>changeA(bytes) <span style=color:#75715e># a usual lock would block here</span>
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>changeB(bytes)
</span></span></code></pre></div><p>Invoked as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python3 data-lang=python3><span style=display:flex><span>foo <span style=color:#f92672>=</span> Foo()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>threads <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>5</span>):
</span></span><span style=display:flex><span>    thread <span style=color:#f92672>=</span> Thread(target<span style=color:#f92672>=</span>foo<span style=color:#f92672>.</span>changeA, args<span style=color:#f92672>=</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;hello from thread </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> A&#34;</span>,))
</span></span><span style=display:flex><span>    threads<span style=color:#f92672>.</span>append(thread)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    thread <span style=color:#f92672>=</span> Thread(target<span style=color:#f92672>=</span>foo<span style=color:#f92672>.</span>changeB, args<span style=color:#f92672>=</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;hello from thread </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> B&#34;</span>,))
</span></span><span style=display:flex><span>    threads<span style=color:#f92672>.</span>append(thread)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    thread <span style=color:#f92672>=</span> Thread(target<span style=color:#f92672>=</span>foo<span style=color:#f92672>.</span>changeAandB, args<span style=color:#f92672>=</span>(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;hello from thread </span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74> AB&#34;</span>,))
</span></span><span style=display:flex><span>    threads<span style=color:#f92672>.</span>append(thread)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Start all threads</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>    thread<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Wait for all threads to finish</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> thread <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>    thread<span style=color:#f92672>.</span>join()
</span></span></code></pre></div><p>It will not work as expected. As soon as the first <code>changeAandB</code> gets called, its inner
<code>self.changeA</code> call will block. This is because the lock can only be acquired once.</p><p>In this specific example, the straightforward way to fix the issue is to use an <code>RLock</code>:
<code>self.lock = RLock()</code>. The reentrant lock can be locked multiple times.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li><a href=https://theorangeduck.com/page/synchronized-python>https://theorangeduck.com/page/synchronized-python</a></li><li><a href=https://stackoverflow.com/questions/29158282/how-to-create-a-synchronized-function-across-all-instances>https://stackoverflow.com/questions/29158282/how-to-create-a-synchronized-function-across-all-instances</a></li><li><a href=https://stackoverflow.com/questions/53026622/python-equivalent-of-java-synchronized>https://stackoverflow.com/questions/53026622/python-equivalent-of-java-synchronized</a></li><li><a href=https://stackoverflow.com/questions/16567958/when-and-how-to-use-pythons-rlock>https://stackoverflow.com/questions/16567958/when-and-how-to-use-pythons-rlock</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://thiagowfx.github.io/tags/dev/>dev</a></li><li><a href=https://thiagowfx.github.io/tags/bestof/>bestof</a></li></ul><nav class=paginav><a class=prev href=https://thiagowfx.github.io/2024/01/why-do-you-need-to-know-my-last-name/><span class=title>« Prev</span><br><span>Why do you need to know my last name?</span>
</a><a class=next href=https://thiagowfx.github.io/2024/01/python-all-hail-to-cache-memoization/><span class=title>Next »</span><br><span>Python: all hail to cache memoization</span></a></nav></footer><div style=text-align:center><a href="mailto:tbperrotta@gmail.com?subject=RE: Not%20Just%20Serendipity comment for '%e2%98%85%20Synchronized%20in%20Python'" target=_blank><button>Reply via email</button></a></div></article></main><footer class=footer><span>Copyright © 2021 - 2024 Thiago Perrotta • <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a> • <a href=/index.xml>RSS</a> •</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>