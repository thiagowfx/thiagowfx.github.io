<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Advent of Code: Day 4 | not just serendipity</title>
<meta name=keywords content="dev"><meta name=description content="Link to Day #4 puzzle."><meta name=author content="Thiago Perrotta"><link rel=canonical href=https://www.perrotta.dev/2024/12/advent-of-code-day-4/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://www.perrotta.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.perrotta.dev/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://www.perrotta.dev/favicon.ico><link rel=apple-touch-icon href=https://www.perrotta.dev/apple-touch-icon.png><link rel=mask-icon href=https://www.perrotta.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.perrotta.dev/2024/12/advent-of-code-day-4/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>body{font-family:Crimson Pro,Vollkorn,Alegreya,Iowan Old Style,Apple Garamond,Baskerville,Times New Roman,Noto Serif,Droid Serif,Times,Source Serif Pro,serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}h1,h2,h3,h4,h5,h6,footer,nav,.toc,.post-meta{font-family:Inter,Fira Sans,Lato,system-ui,-apple-system,BlinkMacSystemFont,Avenir Next,Avenir,Segoe UI,Helvetica Neue,Helvetica,Ubuntu,Roboto,Noto,Cantarell,Arial,sans-serif}code,pre{font-family:Fira Code,PT Mono,IBM Plex Mono,Menlo,Consolas,Monaco,Liberation Mono,Ubuntu Mono,Lucida Console,monospace}</style><meta property="og:url" content="https://www.perrotta.dev/2024/12/advent-of-code-day-4/"><meta property="og:site_name" content="not just serendipity"><meta property="og:title" content="Advent of Code: Day 4"><meta property="og:description" content="Link to Day #4 puzzle."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-06T11:44:39+01:00"><meta property="article:modified_time" content="2024-12-06T11:44:39+01:00"><meta property="article:tag" content="Dev"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code: Day 4"><meta name=twitter:description content="Link to Day #4 puzzle."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.perrotta.dev/posts/"},{"@type":"ListItem","position":2,"name":"Advent of Code: Day 4","item":"https://www.perrotta.dev/2024/12/advent-of-code-day-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Advent of Code: Day 4","name":"Advent of Code: Day 4","description":"Link to Day #4 puzzle.\n","keywords":["dev"],"articleBody":"Link to Day #4 puzzle.\nIt‚Äôs a pretty typical 2D matrix search problem, or a graph search problem, if you will.\nThe problem is naturally unraveled into the following searches:\nhorizontally horizontally, reversed vertically vertically, reversed diagonally, all 4 directions (NW, NE, SW, SE) It‚Äôs possible to write a single pair of for loops that addresses the general case. The (classic) idea is to think of all 8 compass directions to move along the matrix:\n(1, 0) (-1, 0) (0, 1) (0, -1) (1, 1) (-1, -1) (-1, 1) (1, -1) Within the inner iteration, change x += dx and y += dy (or i += di, j += dj, naming is hard). I did this many times in C++ though, and I want to write elegant Python code.\nTherefore I came up with the following solution instead, with nested list comprehensions:\ndef search_horizontal(matrix, keyword): return sum((True for row in matrix for i in range(len(row) - len(keyword) + 1) if \"\".join(row[i:i + len(keyword)]) in [keyword, keyword[::-1]])) It follows the same principle as the original intent, however it leverages list slices so that we can omit the dx/dy step.\nThe vertical search is pretty straightforward: it is just a matter of running the horizontal search in the transposed matrix (zip(*matrix)).\nI must confess that using zip to transpose matrices always felt magical and a mere coincidence that it just works‚Ñ¢. Ruby has a .transpose method, which is more readable.\nFor the diagonal search, I couldn‚Äôt think of an elegant list comprehension manner to address it. Is it even possible to ‚Äú2D slice‚Äù in Python?\nAfter-the-fact I decided to ask ChatGPT, and it is indeed possible, but it requires NumPy:\nIf a is 2-D, returns the diagonal of a with the given offset, i.e., the collection of elements of the form a[i, i+offset]. If a has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing axis1 and axis2 and appending an index to the right equal to the size of the resulting diagonals.\nThe method call resembles numpy.array([[1, 2], [3, 4]]).diagonal(offset=1), perhaps with the aid of .flip() to account for the other direction.\nAnyway, my plain diagonal search is:\ndef search_diagonal(matrix, keyword): rows = len(matrix) cols = len(matrix[0]) count = 0 for i in range(rows): for j in range(cols): if i + len(keyword) \u003c= rows and j + len(keyword) \u003c= cols: if \"\".join(matrix[i + k][j + k] for k in range(len(keyword))) in [keyword, keyword[::-1]]: count += 1 if i + len(keyword) \u003c= rows and j - len(keyword) \u003e= -1: if \"\".join(matrix[i + k][j - k] for k in range(len(keyword))) in [keyword, keyword[::-1]]: count += 1 return count Part two is fundamentally a different problem.\nOne way to address it is to search for all 'A' characters, and then look around its ‚Äúedges‚Äù to see if they contain exactly two 'M' and two 'S', and that they are properly arranged:\ndef search_double_mas(matrix): rows = len(matrix) cols = len(matrix[0]) count = 0 for i in range(1, rows - 1): for j in range(1, cols - 1): if matrix[i][j] != 'A': continue # look at a QWERTY keyboard to make sense of these variable names q = matrix[i - 1][j - 1] e = matrix[i - 1][j + 1] z = matrix[i + 1][j - 1] c = matrix[i + 1][j + 1] edges = [q, e, z, c] if edges.count('M') != 2 or edges.count('S') != 2: continue if q == e or q == z: count += 1 return count I couldn‚Äôt find an opportunity for reuse of the solution from part one.\nThe full solution:\n#!/usr/bin/env python3 import sys def search_horizontal(matrix, keyword): return sum((True for row in matrix for i in range(len(row) - len(keyword) + 1) if \"\".join(row[i:i + len(keyword)]) in [keyword, keyword[::-1]])) def search_vertical(matrix, keyword): return search_horizontal(zip(*matrix), keyword) def search_diagonal(matrix, keyword): rows = len(matrix) cols = len(matrix[0]) count = 0 for i in range(rows): for j in range(cols): if i + len(keyword) \u003c= rows and j + len(keyword) \u003c= cols: if \"\".join(matrix[i + k][j + k] for k in range(len(keyword))) in [keyword, keyword[::-1]]: count += 1 if i + len(keyword) \u003c= rows and j - len(keyword) \u003e= -1: if \"\".join(matrix[i + k][j - k] for k in range(len(keyword))) in [keyword, keyword[::-1]]: count += 1 return count def search_double_mas(matrix): rows = len(matrix) cols = len(matrix[0]) count = 0 for i in range(1, rows - 1): for j in range(1, cols - 1): if matrix[i][j] != 'A': continue # look at a QWERTY keyboard to make sense of these variable names q = matrix[i - 1][j - 1] e = matrix[i - 1][j + 1] z = matrix[i + 1][j - 1] c = matrix[i + 1][j + 1] edges = [q, e, z, c] if edges.count('M') != 2 or edges.count('S') != 2: continue if q == e or q == z: count += 1 return count def main(): with open(sys.argv[1]) as input: lines = input.read().splitlines() keyword = \"XMAS\" # ['abcd', 'efgh', 'ijkl'] -\u003e [['a', 'b', 'c', 'd'], ['e', 'f', 'g', 'h'], ['i', 'j', 'k', 'l']] matrix = [list(line) for line in lines] # part one print(search_horizontal(matrix, keyword) + search_vertical(matrix, keyword) + search_diagonal(matrix, keyword)) # part two print(search_double_mas(matrix)) if __name__ == '__main__': main() ","wordCount":"884","inLanguage":"en","datePublished":"2024-12-06T11:44:39+01:00","dateModified":"2024-12-06T11:44:39+01:00","author":{"@type":"Person","name":"Thiago Perrotta"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.perrotta.dev/2024/12/advent-of-code-day-4/"},"publisher":{"@type":"Person","name":"not just serendipity","logo":{"@type":"ImageObject","url":"https://www.perrotta.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.perrotta.dev/ accesskey=h title="not just serendipity (Alt + H)"><img src=https://www.perrotta.dev/apple-touch-icon.png alt aria-label=logo height=32>not just serendipity</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.perrotta.dev/posts/ title=posts><span>posts</span></a></li><li><a href=https://www.perrotta.dev/tags/bestof/ title="bestof ‚òÖ"><span>bestof ‚òÖ</span></a></li><li><a href=https://www.perrotta.dev/tags/serenity/ title=serenity><span>serenity</span></a></li><li><a href=https://www.perrotta.dev/archives/ title=archives><span>archives</span></a></li><li><a href=https://www.perrotta.dev/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://www.perrotta.dev/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Advent of Code: Day 4</h1><div class=post-meta><span title='2024-12-06 11:44:39 +0100 +0100'>December 6, 2024</span>&nbsp;¬∑&nbsp;884 words&nbsp;¬∑&nbsp;Thiago Perrotta</div></header><div class=post-content><p>Link to <a href=https://adventofcode.com/2024/day/4>Day #4</a> puzzle.</p><p>It&rsquo;s a pretty typical 2D matrix search problem, or a graph search problem, if
you will.</p><p>The problem is naturally unraveled into the following searches:</p><ul><li>horizontally</li><li>horizontally, reversed</li><li>vertically</li><li>vertically, reversed</li><li>diagonally, all 4 directions (NW, NE, SW, SE)</li></ul><p>It&rsquo;s possible to write a single pair of for loops that addresses the general
case. The (classic) idea is to think of all 8 compass directions to move along
the matrix:</p><ul><li>(1, 0)</li><li>(-1, 0)</li><li>(0, 1)</li><li>(0, -1)</li><li>(1, 1)</li><li>(-1, -1)</li><li>(-1, 1)</li><li>(1, -1)</li></ul><p>Within the inner iteration, change <code>x += dx</code> and <code>y += dy</code> (or <code>i += di</code>, <code>j += dj</code>, naming is hard). I did this many times in C++ though, and I want to write
elegant Python code.</p><p>Therefore I came up with the following solution instead, with nested list
comprehensions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_horizontal</span>(matrix, keyword):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum((<span style=color:#66d9ef>True</span> <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> matrix <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(row) <span style=color:#f92672>-</span> len(keyword) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(row[i:i <span style=color:#f92672>+</span> len(keyword)]) <span style=color:#f92672>in</span> [keyword, keyword[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]))
</span></span></code></pre></div><p>It follows the same principle as the original intent, however it leverages
list slices so that we can omit the <code>dx/dy</code> step.</p><p>The vertical search is pretty straightforward: it is just a matter of running
the horizontal search in the transposed matrix (<code>zip(*matrix)</code>).</p><p>I must confess that using <code>zip</code> to transpose matrices always felt magical and a
mere coincidence that it just works‚Ñ¢. Ruby has a <code>.transpose</code> method, which is
more readable.</p><p>For the diagonal search, I couldn&rsquo;t think of an elegant list comprehension
manner to address it. Is it even possible to &ldquo;2D slice&rdquo; in Python?</p><p>After-the-fact I decided to ask ChatGPT, and it is indeed possible, but it
requires NumPy:</p><blockquote><p>If a is 2-D, returns the diagonal of a with the given offset, i.e., the
collection of elements of the form a[i, i+offset]. If a has more than two
dimensions, then the axes specified by axis1 and axis2 are used to determine
the 2-D sub-array whose diagonal is returned. The shape of the resulting array
can be determined by removing axis1 and axis2 and appending an index to the
right equal to the size of the resulting diagonals.</p></blockquote><p>The method call resembles <code>numpy.array([[1, 2], [3, 4]]).diagonal(offset=1)</code>,
perhaps with the aid of <code>.flip()</code> to account for the other direction.</p><p>Anyway, my plain diagonal search is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_diagonal</span>(matrix, keyword):
</span></span><span style=display:flex><span>    rows <span style=color:#f92672>=</span> len(matrix)
</span></span><span style=display:flex><span>    cols <span style=color:#f92672>=</span> len(matrix[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(rows):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(cols):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i <span style=color:#f92672>+</span> len(keyword) <span style=color:#f92672>&lt;=</span> rows <span style=color:#f92672>and</span> j <span style=color:#f92672>+</span> len(keyword) <span style=color:#f92672>&lt;=</span> cols:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(matrix[i <span style=color:#f92672>+</span> k][j <span style=color:#f92672>+</span> k] <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(len(keyword))) <span style=color:#f92672>in</span> [keyword, keyword[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]:
</span></span><span style=display:flex><span>                    count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i <span style=color:#f92672>+</span> len(keyword) <span style=color:#f92672>&lt;=</span> rows <span style=color:#f92672>and</span> j <span style=color:#f92672>-</span> len(keyword) <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(matrix[i <span style=color:#f92672>+</span> k][j <span style=color:#f92672>-</span> k] <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(len(keyword))) <span style=color:#f92672>in</span> [keyword, keyword[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]:
</span></span><span style=display:flex><span>                    count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> count
</span></span></code></pre></div><p>Part two is fundamentally a different problem.</p><p>One way to address it is to search for all <code>'A'</code> characters, and then look
around its &ldquo;edges&rdquo; to see if they contain exactly two <code>'M'</code> and two <code>'S'</code>, and
that they are properly arranged:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_double_mas</span>(matrix):
</span></span><span style=display:flex><span>    rows <span style=color:#f92672>=</span> len(matrix)
</span></span><span style=display:flex><span>    cols <span style=color:#f92672>=</span> len(matrix[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, rows <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, cols <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> matrix[i][j] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;A&#39;</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># look at a QWERTY keyboard to make sense of these variable names</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>=</span> matrix[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            e <span style=color:#f92672>=</span> matrix[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            z <span style=color:#f92672>=</span> matrix[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> matrix[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            edges <span style=color:#f92672>=</span> [q, e, z, c]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> edges<span style=color:#f92672>.</span>count(<span style=color:#e6db74>&#39;M&#39;</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>or</span> edges<span style=color:#f92672>.</span>count(<span style=color:#e6db74>&#39;S&#39;</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> q <span style=color:#f92672>==</span> e <span style=color:#f92672>or</span> q <span style=color:#f92672>==</span> z:
</span></span><span style=display:flex><span>                count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> count
</span></span></code></pre></div><p>I couldn&rsquo;t find an opportunity for reuse of the solution from part one.</p><p>The full solution:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_horizontal</span>(matrix, keyword):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum((<span style=color:#66d9ef>True</span> <span style=color:#66d9ef>for</span> row <span style=color:#f92672>in</span> matrix <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(row) <span style=color:#f92672>-</span> len(keyword) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(row[i:i <span style=color:#f92672>+</span> len(keyword)]) <span style=color:#f92672>in</span> [keyword, keyword[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_vertical</span>(matrix, keyword):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> search_horizontal(zip(<span style=color:#f92672>*</span>matrix), keyword)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_diagonal</span>(matrix, keyword):
</span></span><span style=display:flex><span>    rows <span style=color:#f92672>=</span> len(matrix)
</span></span><span style=display:flex><span>    cols <span style=color:#f92672>=</span> len(matrix[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(rows):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(cols):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i <span style=color:#f92672>+</span> len(keyword) <span style=color:#f92672>&lt;=</span> rows <span style=color:#f92672>and</span> j <span style=color:#f92672>+</span> len(keyword) <span style=color:#f92672>&lt;=</span> cols:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(matrix[i <span style=color:#f92672>+</span> k][j <span style=color:#f92672>+</span> k] <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(len(keyword))) <span style=color:#f92672>in</span> [keyword, keyword[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]:
</span></span><span style=display:flex><span>                    count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> i <span style=color:#f92672>+</span> len(keyword) <span style=color:#f92672>&lt;=</span> rows <span style=color:#f92672>and</span> j <span style=color:#f92672>-</span> len(keyword) <span style=color:#f92672>&gt;=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>.</span>join(matrix[i <span style=color:#f92672>+</span> k][j <span style=color:#f92672>-</span> k] <span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(len(keyword))) <span style=color:#f92672>in</span> [keyword, keyword[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]]:
</span></span><span style=display:flex><span>                    count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>search_double_mas</span>(matrix):
</span></span><span style=display:flex><span>    rows <span style=color:#f92672>=</span> len(matrix)
</span></span><span style=display:flex><span>    cols <span style=color:#f92672>=</span> len(matrix[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, rows <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, cols <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> matrix[i][j] <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;A&#39;</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># look at a QWERTY keyboard to make sense of these variable names</span>
</span></span><span style=display:flex><span>            q <span style=color:#f92672>=</span> matrix[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            e <span style=color:#f92672>=</span> matrix[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            z <span style=color:#f92672>=</span> matrix[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> matrix[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            edges <span style=color:#f92672>=</span> [q, e, z, c]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> edges<span style=color:#f92672>.</span>count(<span style=color:#e6db74>&#39;M&#39;</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>or</span> edges<span style=color:#f92672>.</span>count(<span style=color:#e6db74>&#39;S&#39;</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> q <span style=color:#f92672>==</span> e <span style=color:#f92672>or</span> q <span style=color:#f92672>==</span> z:
</span></span><span style=display:flex><span>                count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> count
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>]) <span style=color:#66d9ef>as</span> input:
</span></span><span style=display:flex><span>        lines <span style=color:#f92672>=</span> input<span style=color:#f92672>.</span>read()<span style=color:#f92672>.</span>splitlines()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    keyword <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;XMAS&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># [&#39;abcd&#39;, &#39;efgh&#39;, &#39;ijkl&#39;] -&gt; [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], [&#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;], [&#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;]]</span>
</span></span><span style=display:flex><span>    matrix <span style=color:#f92672>=</span> [list(line) <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> lines]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># part one</span>
</span></span><span style=display:flex><span>    print(search_horizontal(matrix, keyword) <span style=color:#f92672>+</span> search_vertical(matrix, keyword) <span style=color:#f92672>+</span> search_diagonal(matrix, keyword))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># part two</span>
</span></span><span style=display:flex><span>    print(search_double_mas(matrix))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.perrotta.dev/tags/dev/>Dev</a></li></ul></footer></article></main><footer class=footer><span>Copyright ¬© 2021 - 2025 Thiago Perrotta ¬∑ <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a> ¬∑ <a href=/index.xml>RSS</a> ¬∑ Made with ‚ô• in üá®üá¶</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>