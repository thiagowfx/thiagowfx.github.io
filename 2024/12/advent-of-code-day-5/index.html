<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://perrotta.dev/favicon.ico><title>Advent of Code: Day 5 | not just serendipity</title>
<meta name=title content="Advent of Code: Day 5"><meta name=description content="Link to Day #5 puzzle.
It is a topological sort problem, plain and simple.
In part one all we care about is whether certain input sequences are valid,
within the sort constraints. It&rsquo;s very straightforward to verify that by
exhaustively checking all constraints (&ldquo;edges&rdquo;):
import sys

def is_correct(update, edges):
    position = defaultdict(lambda: sys.maxsize, {node: i for (i, node) in enumerate(update)})

    for (first, second) in edges:
        if first in update and second in update and position[first] > position[second]:
            return False
    return True
position is a dictionary representing in which index (position) each element
occurs. I make use of a defaultdict with a very large value set by default
(instead of a vanilla dict) to avoid the need to explicitly check for element
presence."><meta name=keywords content="dev,"><meta property="og:url" content="https://perrotta.dev/2024/12/advent-of-code-day-5/"><meta property="og:site_name" content="not just serendipity"><meta property="og:title" content="Advent of Code: Day 5"><meta property="og:description" content="Link to Day #5 puzzle.
It is a topological sort problem, plain and simple.
In part one all we care about is whether certain input sequences are valid, within the sort constraints. It’s very straightforward to verify that by exhaustively checking all constraints (“edges”):
import sys def is_correct(update, edges): position = defaultdict(lambda: sys.maxsize, {node: i for (i, node) in enumerate(update)}) for (first, second) in edges: if first in update and second in update and position[first] > position[second]: return False return True position is a dictionary representing in which index (position) each element occurs. I make use of a defaultdict with a very large value set by default (instead of a vanilla dict) to avoid the need to explicitly check for element presence."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-08T23:24:27+01:00"><meta property="article:modified_time" content="2024-12-08T23:24:27+01:00"><meta property="article:tag" content="Dev"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code: Day 5"><meta name=twitter:description content="Link to Day #5 puzzle.
It is a topological sort problem, plain and simple.
In part one all we care about is whether certain input sequences are valid, within the sort constraints. It’s very straightforward to verify that by exhaustively checking all constraints (“edges”):
import sys def is_correct(update, edges): position = defaultdict(lambda: sys.maxsize, {node: i for (i, node) in enumerate(update)}) for (first, second) in edges: if first in update and second in update and position[first] > position[second]: return False return True position is a dictionary representing in which index (position) each element occurs. I make use of a defaultdict with a very large value set by default (instead of a vanilla dict) to avoid the need to explicitly check for element presence."><meta itemprop=name content="Advent of Code: Day 5"><meta itemprop=description content="Link to Day #5 puzzle.
It is a topological sort problem, plain and simple.
In part one all we care about is whether certain input sequences are valid, within the sort constraints. It’s very straightforward to verify that by exhaustively checking all constraints (“edges”):
import sys def is_correct(update, edges): position = defaultdict(lambda: sys.maxsize, {node: i for (i, node) in enumerate(update)}) for (first, second) in edges: if first in update and second in update and position[first] > position[second]: return False return True position is a dictionary representing in which index (position) each element occurs. I make use of a defaultdict with a very large value set by default (instead of a vanilla dict) to avoid the need to explicitly check for element presence."><meta itemprop=datePublished content="2024-12-08T23:24:27+01:00"><meta itemprop=dateModified content="2024-12-08T23:24:27+01:00"><meta itemprop=wordCount content="427"><meta itemprop=keywords content="Dev"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Crimson Pro,Vollkorn,Alegreya,Iowan Old Style,Apple Garamond,Baskerville,Times New Roman,Noto Serif,Droid Serif,Times,Source Serif Pro,serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}h1,h2,h3,h4,h5,h6,footer,nav{font-family:Inter,Fira Sans,Lato,system-ui,-apple-system,BlinkMacSystemFont,Avenir Next,Avenir,Segoe UI,Helvetica Neue,Helvetica,Ubuntu,Roboto,Noto,Cantarell,Arial,sans-serif}footer{font-size:small}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}li code,p code{font-size:small}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}code,pre{font-family:Fira Code,PT Mono,IBM Plex Mono,Menlo,Consolas,Monaco,Liberation Mono,Ubuntu Mono,Lucida Console,monospace}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#444}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}}</style><link rel=apple-touch-icon href=https://perrotta.dev/apple-touch-icon.png></head><body><header><a href=/ class=title><h2>not just serendipity</h2></a><nav><a href=/>Home</a>
<a href=/posts/>Blog</a>
<a href=/tags/bestof/>★</a></nav></header><main><h1>Advent of Code: Day 5</h1><p><i><time datetime=2024-12-08 pubdate>08 Dec, 2024
</time>• 427 words</i></p><content><p>Link to <a href=https://adventofcode.com/2024/day/5>Day #5</a> puzzle.</p><p>It is a topological sort problem, plain and simple.</p><p>In part one all we care about is whether certain input sequences are valid,
within the sort constraints. It&rsquo;s very straightforward to verify that by
exhaustively checking all constraints (&ldquo;edges&rdquo;):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_correct</span>(update, edges):
</span></span><span style=display:flex><span>    position <span style=color:#f92672>=</span> defaultdict(<span style=color:#66d9ef>lambda</span>: sys<span style=color:#f92672>.</span>maxsize, {node: i <span style=color:#66d9ef>for</span> (i, node) <span style=color:#f92672>in</span> enumerate(update)})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (first, second) <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> first <span style=color:#f92672>in</span> update <span style=color:#f92672>and</span> second <span style=color:#f92672>in</span> update <span style=color:#f92672>and</span> position[first] <span style=color:#f92672>&gt;</span> position[second]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span></code></pre></div><p><code>position</code> is a dictionary representing in which index (position) each element
occurs. I make use of a <code>defaultdict</code> with a very large value set by default
(instead of a vanilla <code>dict</code>) to avoid the need to explicitly check for element
presence.</p><p>In part two we need to perform the actual topological sort. Or&mldr;do we? Doing
toposort would be the most efficient way to resolve it, however, in this case,
plain brute force is good enough:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>toposort</span>(update, edges):
</span></span><span style=display:flex><span>    position <span style=color:#f92672>=</span> defaultdict(<span style=color:#66d9ef>lambda</span>: sys<span style=color:#f92672>.</span>maxsize, {node: i <span style=color:#66d9ef>for</span> (i, node) <span style=color:#f92672>in</span> enumerate(update)})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    change <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> change:
</span></span><span style=display:flex><span>        change <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (first, second) <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> first <span style=color:#f92672>in</span> update <span style=color:#f92672>and</span> second <span style=color:#f92672>in</span> update <span style=color:#f92672>and</span> position[first] <span style=color:#f92672>&gt;=</span> position[second]:
</span></span><span style=display:flex><span>                position[first] <span style=color:#f92672>=</span> position[second] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                change <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sorted(update, key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> x: position[x])
</span></span></code></pre></div><p>Once again, we iterate through all the input constraints until we find a
violation. Whenever we find one, we fix the position of the element in the wrong
order by updating it to occur before the other element. We repeat this procedure
until there are no more violations.</p><p>The full source:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> defaultdict
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_correct</span>(update, edges):
</span></span><span style=display:flex><span>    position <span style=color:#f92672>=</span> defaultdict(<span style=color:#66d9ef>lambda</span>: sys<span style=color:#f92672>.</span>maxsize, {node: i <span style=color:#66d9ef>for</span> (i, node) <span style=color:#f92672>in</span> enumerate(update)})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (first, second) <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> first <span style=color:#f92672>in</span> update <span style=color:#f92672>and</span> second <span style=color:#f92672>in</span> update <span style=color:#f92672>and</span> position[first] <span style=color:#f92672>&gt;</span> position[second]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>toposort</span>(update, edges):
</span></span><span style=display:flex><span>    position <span style=color:#f92672>=</span> defaultdict(<span style=color:#66d9ef>lambda</span>: sys<span style=color:#f92672>.</span>maxsize, {node: i <span style=color:#66d9ef>for</span> (i, node) <span style=color:#f92672>in</span> enumerate(update)})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    change <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> change:
</span></span><span style=display:flex><span>        change <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (first, second) <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> first <span style=color:#f92672>in</span> update <span style=color:#f92672>and</span> second <span style=color:#f92672>in</span> update <span style=color:#f92672>and</span> position[first] <span style=color:#f92672>&gt;=</span> position[second]:
</span></span><span style=display:flex><span>                position[first] <span style=color:#f92672>=</span> position[second] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                change <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sorted(update, key<span style=color:#f92672>=</span><span style=color:#66d9ef>lambda</span> x: position[x])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(sys<span style=color:#f92672>.</span>argv[<span style=color:#ae81ff>1</span>]) <span style=color:#66d9ef>as</span> input:
</span></span><span style=display:flex><span>        lines <span style=color:#f92672>=</span> input<span style=color:#f92672>.</span>read()<span style=color:#f92672>.</span>splitlines()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    edges <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    updates <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> lines:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#34;|&#34;</span> <span style=color:#f92672>in</span> line:
</span></span><span style=display:flex><span>            edges<span style=color:#f92672>.</span>append(list(map(int, line<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;|&#34;</span>))))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> len(line) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            updates<span style=color:#f92672>.</span>append(list(map(int, line<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#34;,&#34;</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    total_one <span style=color:#f92672>=</span> total_two <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> update <span style=color:#f92672>in</span> updates:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_correct(update, edges):
</span></span><span style=display:flex><span>            total_one <span style=color:#f92672>+=</span> update[len(update) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            sorted_update <span style=color:#f92672>=</span> toposort(update, edges)
</span></span><span style=display:flex><span>            total_two <span style=color:#f92672>+=</span> sorted_update[len(sorted_update) <span style=color:#f92672>//</span> <span style=color:#ae81ff>2</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># part one</span>
</span></span><span style=display:flex><span>    print(total_one)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># part two</span>
</span></span><span style=display:flex><span>    print(total_two)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div></content><p><a href=https://perrotta.dev/tags/dev/>#dev</a></p></main><footer><span>Copyright © 2021 - 2025 <a href=mailto:tbperrotta@gmail.com>Thiago Perrotta</a> · <a href=/index.xml>RSS</a> · a fork of <a href=https://github.com/janraasch/hugo-bearblog/>hugo ʕ•ᴥ•ʔ bear</a></span></footer></body></html>