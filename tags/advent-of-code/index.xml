<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet type="text/xsl" href="https://perrotta.dev/rss.xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Advent-of-Code on ¬¨ just serendipity üçÄ</title><link>https://perrotta.dev/</link><description>Recent content in Advent-of-Code on ¬¨ just serendipity üçÄ</description><generator>Hugo</generator><language>en</language><managingEditor>serendipity@perrotta.dev (Thiago Perrotta)</managingEditor><webMaster>serendipity@perrotta.dev (Thiago Perrotta)</webMaster><copyright>¬© 2013 - 2026 Thiago Perrotta ¬∑
[some rights reserved](https://creativecommons.org/licenses/by-nc-sa/4.0/) ¬∑
a fork of [hugo  ï‚Ä¢·¥•‚Ä¢ î bear](https://github.com/janraasch/hugo-bearblog/)</copyright><lastBuildDate>Mon, 16 Feb 2026 01:27:22 +0100</lastBuildDate><atom:link href="https://perrotta.dev/tags/advent-of-code/index.xml" rel="self" type="application/rss+xml"/><item><title>Advents</title><link>https://perrotta.dev/2024/12/advents/</link><pubDate>Fri, 27 Dec 2024 20:36:42 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advents/</guid><description>&lt;p&gt;Too many advents:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://adventofcode.com/"&gt;Advent of Code&lt;/a&gt;: my favorite. See &lt;a href="https://perrotta.dev/categories/coding/"&gt;coding&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jimmyhmiller.github.io/advent-of-papers"&gt;Advent of Papers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.debugdecember.com/"&gt;Debug December&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://htmhell.dev/adventcalendar/"&gt;HTMLHell Advent Calendar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Surely you will never run out of daily technical challenges to do in December!&lt;/p&gt;
&lt;p&gt;And don&amp;rsquo;t forget about the likes of &lt;a href="https://wordly.org/"&gt;Wordly&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advents"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 17</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-17/</link><pubDate>Wed, 25 Dec 2024 16:13:30 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-17/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/17"&gt;Day #17&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s a simulation problem, a quite delightful one to implement.&lt;/p&gt;
&lt;p&gt;Using python data classes would have been natural, but I went full imperative in
this one.&lt;/p&gt;
&lt;p&gt;Part 2 would require clever backwards computation, and I wasn&amp;rsquo;t interested in
doing so. I liked the approach from &lt;a href="https://todd.ginsberg.com/post/advent-of-code/2024/day17/"&gt;Todd
Ginsberg&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The full solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 a, b, c = [int(line.split()[2]) for line in lines[0:3]]
 program = [int(op) for op in lines[4].split()[1].split(&amp;#34;,&amp;#34;)]
 ip = 0
 stdout = []

 def combo(operand):
 assert 0 &amp;lt;= operand &amp;lt; 7

 if 0 &amp;lt;= operand &amp;lt;= 3:
 return operand
 elif operand == 4:
 return a
 elif operand == 5:
 return b
 elif operand == 6:
 return c

 while ip &amp;lt; len(program) - 1:
 opcode = program[ip]
 operand = program[ip &amp;#43; 1]

 # adv, division
 if opcode == 0:
 numerator = a
 denominator = 2 ** combo(operand)
 a = numerator // denominator
 # bxl, bitwise xor
 elif opcode == 1:
 b ^= operand
 # bst, modulo
 elif opcode == 2:
 b = combo(operand) % 8
 # jnz
 elif opcode == 3:
 if a != 0:
 ip = operand
 continue
 # bxc, bitwise xor
 elif opcode == 4:
 b ^= c
 # out
 elif opcode == 5:
 stdout.append(combo(operand) % 8)
 # bdv
 elif opcode == 6:
 numerator = a
 denominator = 2 ** combo(operand)
 b = numerator // denominator
 # cdv
 elif opcode == 7:
 numerator = a
 denominator = 2 ** combo(operand)
 c = numerator // denominator

 ip &amp;#43;= 2

 # part one
 print(&amp;#34;,&amp;#34;.join(map(str, stdout)))

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 17"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 9</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-9/</link><pubDate>Wed, 25 Dec 2024 16:09:53 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-9/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/9"&gt;Day #9&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;A disk fragmentation problem.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s mostly an ad-hoc problem, there isn&amp;rsquo;t much commentary to make.&lt;/p&gt;
&lt;p&gt;Part two was quite annoying so I simply skipped it.&lt;/p&gt;
&lt;p&gt;The full solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

def expand(disk: list[int]) -&amp;gt; str:
 output = []
 fill = True
 d = 0

 for n in disk:
 if fill:
 output &amp;#43;= [str(s) for s in n * [d]]
 d &amp;#43;= 1
 else:
 output &amp;#43;= n * &amp;#39;.&amp;#39;
 fill = not fill

 return output

def defrag(disk: str) -&amp;gt; str:
 p = expand(disk)

 left = 0
 right = len(p) - 1

 while left &amp;lt; right:
 if p[left] == &amp;#39;.&amp;#39;:
 p[left], p[right] = p[right], p[left]
 right -= 1
 while p[right] == &amp;#39;.&amp;#39; and left &amp;lt; right:
 right -= 1

 left &amp;#43;= 1

 return p

def checksum(disk):
 total = 0

 for i, d in enumerate(disk):
 if d == &amp;#39;.&amp;#39;:
 break
 total &amp;#43;= i * int(d)

 return total

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 disk = [int(x) for x in lines[0]]

 # part one
 print(checksum(defrag(disk)))

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 9"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 8</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-8/</link><pubDate>Fri, 20 Dec 2024 22:47:51 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-8/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/8"&gt;Day #8&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;This is a problem in a 2D grid. I like to start by making a frequency map
(dictionary) from the frequencies to the coordinates where they occur:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python3"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python3&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python3"&gt;from collections import defaultdict

# {&amp;#39;0&amp;#39;: ((1,8), ...)}
freq_map = defaultdict(tuple)
for x, line in enumerate(lines):
 for y, field in enumerate(line):
 if field.isalnum():
 freq_map[field] &amp;#43;= ((x, y),)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Then it&amp;rsquo;s just a matter of going through every coordinate pair for a given
frequency. &lt;code&gt;combinations()&lt;/code&gt; from &lt;code&gt;itertools&lt;/code&gt; is great for that:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python3"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python3&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python3"&gt;from itertools import combinations

antinodes = set()

for all_coords in freq_map.values():
 for coord1, coord2 in combinations(all_coords, 2):
 antinodes.update(compute_antinodes(coord1, coord2, len(lines), len(lines[0])))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The meat of the code lives in &lt;code&gt;compute_antinodes&lt;/code&gt;. We need to compute two
coordinates and check whether they are within bounds:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python3"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python3&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python3"&gt;def within_bounds(x, y, height, width):
 return 0 &amp;lt;= x &amp;lt; height and 0 &amp;lt;= y &amp;lt; width

def compute_antinodes(coord1, coord2, height, width):
 x1, y1 = coord1
 x2, y2 = coord2

 dx = x2 - x1
 assert dx &amp;gt;= 0

 dy = y2 - y1

 antinodes = ()

 for (x0, y0, direction) in ((x1, y1, -1), (x2, y2, &amp;#43;1)):
 x, y = x0 &amp;#43; direction * dx, y0 &amp;#43; direction * dy
 if within_bounds(x, y, height, width):
 antinodes &amp;#43;= ((x, y),)

 return antinodes&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;assert&lt;/code&gt;ion gives us peace of mind.&lt;/p&gt;
&lt;p&gt;The answer is the number of &lt;code&gt;antinodes&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For part two, we need to extend the &lt;code&gt;compute_antinodes&lt;/code&gt; logic to keep going
until it gets out-of-bounds:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python3"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python3&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python3"&gt;def compute_antinodes(coord1, coord2, height, width, unbounded=False):
 x1, y1 = coord1
 x2, y2 = coord2

 dx = x2 - x1
 assert dx &amp;gt;= 0

 dy = y2 - y1

 if unbounded:
 antinodes = ((x1, y1), (x2, y2))
 else:
 antinodes = ()

 for (x0, y0, direction) in ((x1, y1, -1), (x2, y2, &amp;#43;1)):
 steps = 1
 while True:
 x, y = x0 &amp;#43; direction * steps * dx, y0 &amp;#43; direction * steps * dy
 if within_bounds(x, y, height, width):
 antinodes &amp;#43;= ((x, y),)
 steps &amp;#43;= 1
 else:
 break

 return antinodes&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The full solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python3"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python3&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python3"&gt;#!/usr/bin/env python3
from collections import defaultdict
from itertools import combinations

import sys

def within_bounds(x, y, height, width):
 return 0 &amp;lt;= x &amp;lt; height and 0 &amp;lt;= y &amp;lt; width

def compute_antinodes(coord1, coord2, height, width, unbounded=False):
 x1, y1 = coord1
 x2, y2 = coord2

 dx = x2 - x1
 assert dx &amp;gt;= 0

 dy = y2 - y1

 if unbounded:
 antinodes = ((x1, y1), (x2, y2))
 else:
 antinodes = ()

 for (x0, y0, direction) in ((x1, y1, -1), (x2, y2, &amp;#43;1)):
 steps = 1
 while True:
 x, y = x0 &amp;#43; direction * steps * dx, y0 &amp;#43; direction * steps * dy
 if within_bounds(x, y, height, width):
 antinodes &amp;#43;= ((x, y),)
 steps &amp;#43;= 1
 else:
 break

 return antinodes

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 # {&amp;#39;0&amp;#39;: ((1,8), ...)}
 freq_map = defaultdict(tuple)
 for x, line in enumerate(lines):
 for y, field in enumerate(line):
 if field.isalnum():
 freq_map[field] &amp;#43;= ((x, y),)

 antinodes = set()

 for all_coords in freq_map.values():
 for coord1, coord2 in combinations(all_coords, 2):
 antinodes.update(compute_antinodes(coord1, coord2, len(lines), len(lines[0])))

 # part one
 print(len(antinodes))

 antinodes = set()

 for all_coords in freq_map.values():
 for coord1, coord2 in combinations(all_coords, 2):
 antinodes.update(compute_antinodes(coord1, coord2, len(lines), len(lines[0]), unbounded=True))

 # part two
 print(len(antinodes))

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Instead of using tuples or coordinates all over the place, we could simply have
modified the map inplace, and then iterated over it in the end to count the
antinodes. I like the tuple abstraction better, and it&amp;rsquo;s quite efficient anyway.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 8"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>‚òÖ Just</title><link>https://perrotta.dev/2024/12/just/</link><pubDate>Fri, 13 Dec 2024 01:16:41 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>advent-of-code</category><category>bestof</category><category>dev</category><guid>https://perrotta.dev/2024/12/just/</guid><description>&lt;p&gt;&lt;a href="https://github.com/casey/just"&gt;Just&lt;/a&gt; is a command runner, a modern replacement
for GNU Make.&lt;/p&gt;
&lt;p&gt;It is written in Rust, has sensible defaults, and lots of syntactic sugar.
A good analogy is &lt;code&gt;fish&lt;/code&gt; versus &lt;code&gt;bash&lt;/code&gt; when comparing &lt;code&gt;just&lt;/code&gt; to &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s very easy to learn from its
&lt;a href="https://github.com/casey/just?tab=readme-ov-file"&gt;README.md&lt;/a&gt; alone as it&amp;rsquo;s
quite comprehensive. There&amp;rsquo;s also a &lt;a href="https://just.systems/man/en/"&gt;gitbook&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://til.simonwillison.net/django/just-with-django"&gt;Simon Willison&lt;/a&gt; prompted
me to try it out.&lt;/p&gt;
&lt;p&gt;As an exercise I decided to convert the &lt;code&gt;Makefile&lt;/code&gt; used to manage this blog into
a &lt;code&gt;Justfile&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The original &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="makefile"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;makefile&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-makefile"&gt;# Sitemap URL
SITEMAP = https://perrotta.dev/sitemap.xml

# Hugo port
PORT := 1313

# Abort if hugo is not installed.
ifeq (, $(shell which hugo))
 $(error &amp;#34;No hugo in $$PATH, install it first&amp;#34;)
endif

all:
	hugo server --bind=&amp;#34;0.0.0.0&amp;#34; --buildDrafts --port $(PORT) --watch

build:
	hugo --environment production --gc --minify

clean:
	$(RM) -r public/ resources/

ping:
	# Ping Google about changes in the sitemap
	curl -sS -o /dev/null &amp;#34;https://www.google.com/ping?sitemap=$(SITEMAP)&amp;#34;
	# Ping Bing (DuckDuckGo, etc) about changes in the sitemap
	curl -sS -o /dev/null &amp;#34;https://www.bing.com/ping?sitemap=$(SITEMAP)&amp;#34;

.PHONY: all build clean ping&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Initially I asked ChatGPT to convert it to a &lt;code&gt;Justfile&lt;/code&gt; but it was a disaster,
even after a couple of iterations. Then I did it myself&lt;sup id="fnref:1"&gt;&lt;a href="https://perrotta.dev/2024/12/just/#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;. The &lt;code&gt;Justfile&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="justfile"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;justfile&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-justfile"&gt;set dotenv-load

watch:
	hugo server --buildDrafts --port ${PORT:-1313} --watch

build:
	hugo --environment production --gc --minify

# Create a new post. Usage: `just new &amp;#34;advent of code day 8&amp;#34;`
new post:
	hugo new content/posts/`date &amp;#34;&amp;#43;%Y-%m-%d&amp;#34;`-{{ kebabcase(post) }}.md

clean:
	rm -rf public/ resources/

# Ping Google and Bing about changes in the sitemap
ping sitemap=&amp;#34;https://perrotta.dev/sitemap.xml&amp;#34;:
	curl -sS -o /dev/null &amp;#34;https://www.google.com/ping?sitemap={{ sitemap }}&amp;#34;
	curl -sS -o /dev/null &amp;#34;https://www.bing.com/ping?sitemap={{ sitemap }}&amp;#34;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The main differences:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Environment variables: use &lt;code&gt;{{ foo }}&lt;/code&gt; instead of &lt;code&gt;$(FOO)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Exception: environment variables loaded from &lt;code&gt;.env&lt;/code&gt; (via &lt;code&gt;set dotenv-load&lt;/code&gt;)
use &lt;code&gt;$FOO&lt;/code&gt; or &lt;code&gt;${FOO}&lt;/code&gt; instead, like POSIX shell variables&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;rm -rf&lt;/code&gt; instead of &lt;code&gt;$(RM) -r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Rules accept parameters. Look at &lt;code&gt;new post&lt;/code&gt; as an example. Example usage:
&lt;code&gt;just new &amp;quot;advent of code day 8&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run shell commands within rules with backticks. &lt;code&gt;$(cmd)&lt;/code&gt; does not work.&lt;/li&gt;
&lt;li&gt;Some handy out-of-the-box functions such as &lt;code&gt;kebabcase()&lt;/code&gt;. No need to
implement this kind of string manipulation in plain shell script!&lt;/li&gt;
&lt;li&gt;Documentation comments above rules are recognized. They are displayed as help
/ usage text when running &lt;code&gt;just -l&lt;/code&gt;. No need for hacky &lt;a href="https://perrotta.dev/2024/08/self-documented-makefiles/"&gt;self-documented
&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt; setups!&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% just -l
Available recipes:
 build
 clean
 new post # Create a new post. Usage: `just new &amp;#34;advent of code day 8&amp;#34;`
 ping sitemap=&amp;#34;https://perrotta.dev/sitemap.xml&amp;#34; # Ping Google and Bing about changes in the sitemap
 watch&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;With a bit of LLM prompting in lieu of Google or Stack Overflow searches.&amp;#160;&lt;a href="https://perrotta.dev/2024/12/just/#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Just"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/bestof/"&gt;#bestof&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 7</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-7/</link><pubDate>Thu, 12 Dec 2024 23:12:31 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-7/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/7"&gt;Day #7&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Part one: dynamic programming!&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def calibrate_one(test_value, operands):

 @lru_cache(maxsize=None)
 def dp_calibrate(acc, index):
 if acc == test_value and index == len(operands):
 return True

 if acc &amp;gt; test_value or index == len(operands):
 return False

 return dp_calibrate(acc &amp;#43; operands[index], index &amp;#43; 1) or dp_calibrate(acc * operands[index], index &amp;#43; 1)

 return dp_calibrate(operands[0], 1)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;I learned this style from &lt;a href="https://neetcode.io/"&gt;NeetCode&lt;/a&gt;. An inner function to
drive the memoization alongside &lt;code&gt;lru_cache&lt;/code&gt;. Beautiful!&lt;/p&gt;
&lt;p&gt;In my initial solution I passed the whole operands tuple as the second argument.
Later on I changed it to pass the current index in the tuple, which is simpler.&lt;/p&gt;
&lt;p&gt;Part two is a natural extension of part one, with an extra operator:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def calibrate_two(test_value, operands):

 @lru_cache(maxsize=None)
 def dp_calibrate(acc, index):
 if index == len(operands):
 return acc == test_value

 if acc &amp;gt; test_value:
 return False

 return dp_calibrate(acc &amp;#43; operands[index], index &amp;#43; 1) or dp_calibrate(acc * operands[index], index &amp;#43; 1) or dp_calibrate(int(str(acc) &amp;#43; str(operands[index])), index &amp;#43; 1)

 return dp_calibrate(operands[0], 1)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The full solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys
from functools import lru_cache

def calibrate_one(test_value, operands):

 @lru_cache(maxsize=None)
 def dp_calibrate(acc, index):
 if acc == test_value and index == len(operands):
 return True

 if acc &amp;gt; test_value or index == len(operands):
 return False

 return dp_calibrate(acc &amp;#43; operands[index], index &amp;#43; 1) or dp_calibrate(acc * operands[index], index &amp;#43; 1)

 return dp_calibrate(operands[0], 1)

def calibrate_two(test_value, operands):

 @lru_cache(maxsize=None)
 def dp_calibrate(acc, index):
 if index == len(operands):
 return acc == test_value

 if acc &amp;gt; test_value:
 return False

 return dp_calibrate(acc &amp;#43; operands[index], index &amp;#43; 1) or dp_calibrate(acc * operands[index], index &amp;#43; 1) or dp_calibrate(int(str(acc) &amp;#43; str(operands[index])), index &amp;#43; 1)

 return dp_calibrate(operands[0], 1)

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 total_one = total_two = 0

 for line in lines:
 test_value, operands = line.split(&amp;#39;:&amp;#39;)
 test_value = int(test_value)
 operands = [int(x) for x in operands.split()]

 if calibrate_one(test_value, operands):
 total_one &amp;#43;= test_value

 if calibrate_two(test_value, operands):
 total_two &amp;#43;= test_value

 # part one
 print(total_one)

 # part two
 print(total_two)

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 7"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code: discussion group</title><link>https://perrotta.dev/2024/12/advent-of-code-discussion-group/</link><pubDate>Thu, 12 Dec 2024 19:30:53 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-discussion-group/</guid><description>&lt;p&gt;Assuming you are following this year&amp;rsquo;s advent of code, you are welcome to join
&lt;a href="https://t.me/&amp;#43;mtPcW45EuFBjNGMx"&gt;our Telegram discussion group&lt;/a&gt;&lt;sup id="fnref:1"&gt;&lt;a href="https://perrotta.dev/2024/12/advent-of-code-discussion-group/#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;. It is
a supergroup, one of its channels is &lt;code&gt;#adventofcode&lt;/code&gt;.&lt;/p&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;It&amp;rsquo;s a moderated group, and this invitation link will expire within 2
weeks of the time of this post.&amp;#160;&lt;a href="https://perrotta.dev/2024/12/advent-of-code-discussion-group/#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code: discussion group"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 11</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-11/</link><pubDate>Thu, 12 Dec 2024 19:15:35 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-11/</guid><description>&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/11"&gt;Day #11&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Part one can be done with a simulation.&lt;/p&gt;
&lt;p&gt;It is very delightful to do it in python: lists are quite flexible, and
converting from integers to strings and vice-versa is seamless. Counting the
number of digits of &lt;code&gt;x&lt;/code&gt; is just a matter of &lt;code&gt;len(str(x))&lt;/code&gt;. In C++ it&amp;rsquo;s a bit
kludgier with &lt;code&gt;std::string(x).size()&lt;/code&gt; and &lt;code&gt;std::stoi(s)&lt;/code&gt;, but then you need to
remember which header to import&lt;sup id="fnref:1"&gt;&lt;a href="https://perrotta.dev/2024/12/advent-of-code-2024-day-11/#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;I thought of using &lt;code&gt;reduce&lt;/code&gt; to do &lt;code&gt;blink(blink(stone))...&lt;/code&gt; and so on:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;print(len(reduce(lambda stone: blink(stone), range(25), stones)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;nonetheless it&amp;rsquo;s more readable to simply use a plain &lt;code&gt;for-range&lt;/code&gt; loop:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;for _ in range(25):
 stones = blink(stones)
print(len(stones))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The secret sauce is in &lt;code&gt;blink&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def blink(stones):
 stones_next = []

 for stone in stones:
 s = str(stone)

 if stone == 0:
 stones_next.append(1)

 elif len(s) % 2 == 0:
 index = len(s) // 2
 stones_next.append(int(s[:index]))
 stones_next.append(int(s[index:]))

 else:
 stones_next.append(stone * 2024)

 return stones_next&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;For part two we need to be cleverer. In principle the same approach would work,
however it takes too long to process due to its exponential nature. In my laptop
I can get up to the 42nd &lt;code&gt;blink&lt;/code&gt; iteration without losing my patience to wait
even longer.&lt;/p&gt;
&lt;p&gt;The main observation to account for is that we only care about the length of the
stone sequence, hence the original task transforms into a simple 2D dynamic
programming problem.&lt;/p&gt;
&lt;p&gt;I call:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;print(dp_blink(stones, 75))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Which is defined this way:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def dp_blink(stones, times):
 from functools import lru_cache

 @lru_cache(maxsize=None)
 def dp(stone: int, times: int) -&amp;gt; int:
 if times == 0:
 return 1

 return sum([dp(stone, times - 1) for stone in blink([stone])])

 return sum([dp(stone, times) for stone in stones])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The DP consists of the stone, and how many times are left for you to blink at it.&lt;/p&gt;
&lt;p&gt;The full solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

def blink(stones):
 stones_next = []

 for stone in stones:
 s = str(stone)

 if stone == 0:
 stones_next.append(1)

 elif len(s) % 2 == 0:
 index = len(s) // 2
 stones_next.append(int(s[:index]))
 stones_next.append(int(s[index:]))

 else:
 stones_next.append(stone * 2024)

 return stones_next

def dp_blink(stones, times):
 from functools import lru_cache

 @lru_cache(maxsize=None)
 def dp(stone: int, times: int) -&amp;gt; int:
 if times == 0:
 return 1

 return sum([dp(stone, times - 1) for stone in blink([stone])])

 return sum([dp(stone, times) for stone in stones])

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 stones = [int(stone) for stone in lines[0].split()]

 for _ in range(25):
 stones = blink(stones)

 # part one
 print(len(stones))

 # This is very slow, with an exponential complexity runtime.
 # What did you expect?
 #
 # for i in range(50): # 50 = 75 - 25
 # print(i)
 # stones = blink(stones)

 # # part two
 # print(len(stones))

 stones = [int(stone) for stone in lines[0].split()]

 # part two
 print(dp_blink(stones, 75))

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;It&amp;rsquo;s &lt;code&gt;#include &amp;lt;string&amp;gt;&lt;/code&gt;.&amp;#160;&lt;a href="https://perrotta.dev/2024/12/advent-of-code-2024-day-11/#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 11"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 6</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-6/</link><pubDate>Thu, 12 Dec 2024 15:26:35 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-6/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/6"&gt;Day #6&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Part one is a classic 2D matrix (graph) traversal problem.&lt;/p&gt;
&lt;p&gt;To store state I created a &lt;code&gt;visited&lt;/code&gt; set with the &lt;code&gt;(x, y)&lt;/code&gt; coordinates.
Alternatively I could have changed the input inplace, but I didn&amp;rsquo;t want to deal
with the immutability of python strings, i.e. given:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;l = [&amp;#34;.....&amp;#34;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;you can&amp;rsquo;t simply do &lt;code&gt;l[0][0] = 'X'&lt;/code&gt;, because python strings are immutable. We
could define a new string and assign it to &lt;code&gt;l[0]&lt;/code&gt;, or we could change the input
to:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;l = [&amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39;.&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;so that replacing characters becomes trivial.&lt;/p&gt;
&lt;p&gt;The full solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

def find(lines, c):
 for i, line in enumerate(lines):
 if c in line:
 return i, line.index(c)
 raise ValueError(f&amp;#39;Could not find {c} in lines&amp;#39;)

def move(pos, dir, lines, visited):
 dirs_clockwise = ((1, 0), (0, -1), (-1, 0), (0, 1))

 while True:
 next_pos = pos[0] &amp;#43; dir[0], pos[1] &amp;#43; dir[1]

 if next_pos[0] &amp;lt; 0 or next_pos[0] &amp;gt;= len(lines) or next_pos[1] &amp;lt; 0 or next_pos[1] &amp;gt;= len(lines[0]):
 break

 if lines[next_pos[0]][next_pos[1]] in &amp;#39;.^&amp;#39;:
 pos = next_pos
 visited.add(pos)
 elif lines[next_pos[0]][next_pos[1]] == &amp;#39;#&amp;#39;:
 dir = dirs_clockwise[(dirs_clockwise.index(dir) &amp;#43; 1) % 4]

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 pos = find(lines, &amp;#39;^&amp;#39;)
 dir = (-1, 0) # up

 visited = set((pos,))

 move(pos, dir, lines, visited)

 # part one
 print(len(visited))

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;I did not solve part two yet. I know how to do it, but my initial approach is
too brute force to my taste. Perhaps I&amp;rsquo;ll come up with something clever later
on.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 6"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 5</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-5/</link><pubDate>Sun, 08 Dec 2024 23:24:27 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-5/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/5"&gt;Day #5&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;It is a topological sort problem, plain and simple.&lt;/p&gt;
&lt;p&gt;In part one all we care about is whether certain input sequences are valid,
within the sort constraints. It&amp;rsquo;s very straightforward to verify that by
exhaustively checking all constraints (&amp;ldquo;edges&amp;rdquo;):&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import sys

def is_correct(update, edges):
 position = defaultdict(lambda: sys.maxsize, {node: i for (i, node) in enumerate(update)})

 for (first, second) in edges:
 if first in update and second in update and position[first] &amp;gt; position[second]:
 return False
 return True&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;position&lt;/code&gt; is a dictionary representing in which index (position) each element
occurs. I make use of a &lt;code&gt;defaultdict&lt;/code&gt; with a very large value set by default
(instead of a vanilla &lt;code&gt;dict&lt;/code&gt;) to avoid the need to explicitly check for element
presence.&lt;/p&gt;
&lt;p&gt;In part two we need to perform the actual topological sort. Or&amp;hellip;do we? Doing
toposort would be the most efficient way to resolve it, however, in this case,
plain brute force is good enough:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def toposort(update, edges):
 position = defaultdict(lambda: sys.maxsize, {node: i for (i, node) in enumerate(update)})

 change = True
 while change:
 change = False
 for (first, second) in edges:
 if first in update and second in update and position[first] &amp;gt;= position[second]:
 position[first] = position[second] - 1
 change = True

 return sorted(update, key=lambda x: position[x])&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Once again, we iterate through all the input constraints until we find a
violation. Whenever we find one, we fix the position of the element in the wrong
order by updating it to occur before the other element. We repeat this procedure
until there are no more violations.&lt;/p&gt;
&lt;p&gt;The full source:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
from collections import defaultdict
import sys

def is_correct(update, edges):
 position = defaultdict(lambda: sys.maxsize, {node: i for (i, node) in enumerate(update)})

 for (first, second) in edges:
 if first in update and second in update and position[first] &amp;gt; position[second]:
 return False
 return True

def toposort(update, edges):
 position = defaultdict(lambda: sys.maxsize, {node: i for (i, node) in enumerate(update)})

 change = True
 while change:
 change = False
 for (first, second) in edges:
 if first in update and second in update and position[first] &amp;gt;= position[second]:
 position[first] = position[second] - 1
 change = True

 return sorted(update, key=lambda x: position[x])

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 edges = []
 updates = []

 for line in lines:
 if &amp;#34;|&amp;#34; in line:
 edges.append(list(map(int, line.split(&amp;#34;|&amp;#34;))))
 elif len(line) == 0:
 continue
 else:
 updates.append(list(map(int, line.split(&amp;#34;,&amp;#34;))))

 total_one = total_two = 0
 for update in updates:
 if is_correct(update, edges):
 total_one &amp;#43;= update[len(update) // 2]
 else:
 sorted_update = toposort(update, edges)
 total_two &amp;#43;= sorted_update[len(sorted_update) // 2]

 # part one
 print(total_one)

 # part two
 print(total_two)

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 5"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 4</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-4/</link><pubDate>Fri, 06 Dec 2024 11:44:39 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-4/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/4"&gt;Day #4&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s a pretty typical 2D matrix search problem, or a graph search problem, if
you will.&lt;/p&gt;
&lt;p&gt;The problem is naturally unraveled into the following searches:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;horizontally&lt;/li&gt;
&lt;li&gt;horizontally, reversed&lt;/li&gt;
&lt;li&gt;vertically&lt;/li&gt;
&lt;li&gt;vertically, reversed&lt;/li&gt;
&lt;li&gt;diagonally, all 4 directions (NW, NE, SW, SE)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It&amp;rsquo;s possible to write a single pair of for loops that addresses the general
case. The (classic) idea is to think of all 8 compass directions to move along
the matrix:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1, 0)&lt;/li&gt;
&lt;li&gt;(-1, 0)&lt;/li&gt;
&lt;li&gt;(0, 1)&lt;/li&gt;
&lt;li&gt;(0, -1)&lt;/li&gt;
&lt;li&gt;(1, 1)&lt;/li&gt;
&lt;li&gt;(-1, -1)&lt;/li&gt;
&lt;li&gt;(-1, 1)&lt;/li&gt;
&lt;li&gt;(1, -1)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Within the inner iteration, change &lt;code&gt;x += dx&lt;/code&gt; and &lt;code&gt;y += dy&lt;/code&gt; (or &lt;code&gt;i += di&lt;/code&gt;, &lt;code&gt;j += dj&lt;/code&gt;, naming is hard). I did this many times in C++ though, and I want to write
elegant Python code.&lt;/p&gt;
&lt;p&gt;Therefore I came up with the following solution instead, with nested list
comprehensions:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def search_horizontal(matrix, keyword):
 return sum((True for row in matrix for i in range(len(row) - len(keyword) &amp;#43; 1) if &amp;#34;&amp;#34;.join(row[i:i &amp;#43; len(keyword)]) in [keyword, keyword[::-1]]))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;It follows the same principle as the original intent, however it leverages
list slices so that we can omit the &lt;code&gt;dx/dy&lt;/code&gt; step.&lt;/p&gt;
&lt;p&gt;The vertical search is pretty straightforward: it is just a matter of running
the horizontal search in the transposed matrix (&lt;code&gt;zip(*matrix)&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;I must confess that using &lt;code&gt;zip&lt;/code&gt; to transpose matrices always felt magical and a
mere coincidence that it just works‚Ñ¢. Ruby has a &lt;code&gt;.transpose&lt;/code&gt; method, which is
more readable.&lt;/p&gt;
&lt;p&gt;For the diagonal search, I couldn&amp;rsquo;t think of an elegant list comprehension
manner to address it. Is it even possible to &amp;ldquo;2D slice&amp;rdquo; in Python?&lt;/p&gt;
&lt;p&gt;After-the-fact I decided to ask ChatGPT, and it is indeed possible, but it
requires NumPy:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If a is 2-D, returns the diagonal of a with the given offset, i.e., the
collection of elements of the form a[i, i+offset]. If a has more than two
dimensions, then the axes specified by axis1 and axis2 are used to determine
the 2-D sub-array whose diagonal is returned. The shape of the resulting array
can be determined by removing axis1 and axis2 and appending an index to the
right equal to the size of the resulting diagonals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The method call resembles &lt;code&gt;numpy.array([[1, 2], [3, 4]]).diagonal(offset=1)&lt;/code&gt;,
perhaps with the aid of &lt;code&gt;.flip()&lt;/code&gt; to account for the other direction.&lt;/p&gt;
&lt;p&gt;Anyway, my plain diagonal search is:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def search_diagonal(matrix, keyword):
 rows = len(matrix)
 cols = len(matrix[0])

 count = 0

 for i in range(rows):
 for j in range(cols):
 if i &amp;#43; len(keyword) &amp;lt;= rows and j &amp;#43; len(keyword) &amp;lt;= cols:
 if &amp;#34;&amp;#34;.join(matrix[i &amp;#43; k][j &amp;#43; k] for k in range(len(keyword))) in [keyword, keyword[::-1]]:
 count &amp;#43;= 1
 if i &amp;#43; len(keyword) &amp;lt;= rows and j - len(keyword) &amp;gt;= -1:
 if &amp;#34;&amp;#34;.join(matrix[i &amp;#43; k][j - k] for k in range(len(keyword))) in [keyword, keyword[::-1]]:
 count &amp;#43;= 1

 return count&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Part two is fundamentally a different problem.&lt;/p&gt;
&lt;p&gt;One way to address it is to search for all &lt;code&gt;'A'&lt;/code&gt; characters, and then look
around its &amp;ldquo;edges&amp;rdquo; to see if they contain exactly two &lt;code&gt;'M'&lt;/code&gt; and two &lt;code&gt;'S'&lt;/code&gt;, and
that they are properly arranged:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def search_double_mas(matrix):
 rows = len(matrix)
 cols = len(matrix[0])

 count = 0

 for i in range(1, rows - 1):
 for j in range(1, cols - 1):
 if matrix[i][j] != &amp;#39;A&amp;#39;:
 continue

 # look at a QWERTY keyboard to make sense of these variable names
 q = matrix[i - 1][j - 1]
 e = matrix[i - 1][j &amp;#43; 1]
 z = matrix[i &amp;#43; 1][j - 1]
 c = matrix[i &amp;#43; 1][j &amp;#43; 1]
 edges = [q, e, z, c]

 if edges.count(&amp;#39;M&amp;#39;) != 2 or edges.count(&amp;#39;S&amp;#39;) != 2:
 continue

 if q == e or q == z:
 count &amp;#43;= 1

 return count&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;I couldn&amp;rsquo;t find an opportunity for reuse of the solution from part one.&lt;/p&gt;
&lt;p&gt;The full solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

def search_horizontal(matrix, keyword):
 return sum((True for row in matrix for i in range(len(row) - len(keyword) &amp;#43; 1) if &amp;#34;&amp;#34;.join(row[i:i &amp;#43; len(keyword)]) in [keyword, keyword[::-1]]))

def search_vertical(matrix, keyword):
 return search_horizontal(zip(*matrix), keyword)

def search_diagonal(matrix, keyword):
 rows = len(matrix)
 cols = len(matrix[0])

 count = 0

 for i in range(rows):
 for j in range(cols):
 if i &amp;#43; len(keyword) &amp;lt;= rows and j &amp;#43; len(keyword) &amp;lt;= cols:
 if &amp;#34;&amp;#34;.join(matrix[i &amp;#43; k][j &amp;#43; k] for k in range(len(keyword))) in [keyword, keyword[::-1]]:
 count &amp;#43;= 1
 if i &amp;#43; len(keyword) &amp;lt;= rows and j - len(keyword) &amp;gt;= -1:
 if &amp;#34;&amp;#34;.join(matrix[i &amp;#43; k][j - k] for k in range(len(keyword))) in [keyword, keyword[::-1]]:
 count &amp;#43;= 1

 return count

def search_double_mas(matrix):
 rows = len(matrix)
 cols = len(matrix[0])

 count = 0

 for i in range(1, rows - 1):
 for j in range(1, cols - 1):
 if matrix[i][j] != &amp;#39;A&amp;#39;:
 continue

 # look at a QWERTY keyboard to make sense of these variable names
 q = matrix[i - 1][j - 1]
 e = matrix[i - 1][j &amp;#43; 1]
 z = matrix[i &amp;#43; 1][j - 1]
 c = matrix[i &amp;#43; 1][j &amp;#43; 1]
 edges = [q, e, z, c]

 if edges.count(&amp;#39;M&amp;#39;) != 2 or edges.count(&amp;#39;S&amp;#39;) != 2:
 continue

 if q == e or q == z:
 count &amp;#43;= 1

 return count

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 keyword = &amp;#34;XMAS&amp;#34;

 # [&amp;#39;abcd&amp;#39;, &amp;#39;efgh&amp;#39;, &amp;#39;ijkl&amp;#39;] -&amp;gt; [[&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;], [&amp;#39;e&amp;#39;, &amp;#39;f&amp;#39;, &amp;#39;g&amp;#39;, &amp;#39;h&amp;#39;], [&amp;#39;i&amp;#39;, &amp;#39;j&amp;#39;, &amp;#39;k&amp;#39;, &amp;#39;l&amp;#39;]]
 matrix = [list(line) for line in lines]

 # part one
 print(search_horizontal(matrix, keyword) &amp;#43; search_vertical(matrix, keyword) &amp;#43; search_diagonal(matrix, keyword))

 # part two
 print(search_double_mas(matrix))

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 4"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 3</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-3/</link><pubDate>Tue, 03 Dec 2024 16:41:23 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-3/</guid><description>&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/3"&gt;Day #3&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s a pretty typical regex problem.
To choose not to use regex is to endeavour in pain.&lt;/p&gt;
&lt;p&gt;The regex for part one to extract all occurrences of &lt;code&gt;mul&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python3"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python3&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python3"&gt;r&amp;#39;mul\(\d&amp;#43;,\d&amp;#43;\)&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Note that with &lt;code&gt;r&lt;/code&gt; there is no need to escape the backslashes in Python.&lt;/p&gt;
&lt;p&gt;Later on I extract the numbers with &lt;code&gt;r'\d+'&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If we really wanted we could do everything with a single regex by using
capturing groups, however it would become less readable.&lt;/p&gt;
&lt;p&gt;Once the numbers are captured, it&amp;rsquo;s just a matter of accumulating their product.&lt;/p&gt;
&lt;p&gt;I craft and test my regex with the support of &lt;a href="https://regex101.com/"&gt;https://regex101.com/&lt;/a&gt; and then
follow up with the Python interpreter in my laptop.&lt;/p&gt;
&lt;p&gt;Part two adds two more operators, which we can easily account for with an or
(&lt;code&gt;|&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The full solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import re
import sys

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 prod = prod_two = 0

 for memory in lines:
 ops = re.findall(r&amp;#39;mul\(\d&amp;#43;,\d&amp;#43;\)&amp;#39;, memory)

 for op in ops:
 (f1, f2) = map(int, re.findall(r&amp;#39;\d&amp;#43;&amp;#39;, op))
 prod &amp;#43;= f1 * f2

 # part one
 print(prod)

 enabled = True
 for memory in lines:
 ops = re.findall(r&amp;#34;mul\(\d&amp;#43;,\d&amp;#43;\)|do\(\)|don&amp;#39;t\(\)&amp;#34;, memory)

 for op in ops:
 if &amp;#34;don&amp;#39;t&amp;#34; in op:
 enabled = False
 elif &amp;#34;do&amp;#34; in op:
 enabled = True
 elif &amp;#39;mul&amp;#39; in op:
 (f1, f2) = map(int, re.findall(r&amp;#39;\d&amp;#43;&amp;#39;, op))

 if enabled:
 prod_two &amp;#43;= f1 * f2

 # part two
 print(prod_two)

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;I intended to use &lt;a href="https://docs.python.org/3/whatsnew/3.10.html"&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; merely
for style points however it&amp;rsquo;s only available from Python 3.10+, thus I sticked
with a mere &lt;code&gt;if-elif&lt;/code&gt; construct.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 3"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 2</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-2/</link><pubDate>Tue, 03 Dec 2024 01:15:00 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-2/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/2"&gt;Day #2&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;The first part is straightforward. It felt right to use &lt;a href="https://docs.python.org/3/library/itertools.html#itertools.pairwise"&gt;&lt;code&gt;pairwise&lt;/code&gt;&lt;/a&gt; to compute the differences between each adjacent pair:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;diffs = [(b - a) for (a,b) in pairwise(map(int, line.split(&amp;#39; &amp;#39;)))]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Then we combine it with &lt;code&gt;all&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def is_safe(diffs):
 return all(1 &amp;lt;= n &amp;lt;= 3 for n in diffs) or all(-3 &amp;lt;= n &amp;lt;= -1 for n in diffs)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Note that it is necessary to use two &lt;code&gt;all&lt;/code&gt; expressions. It feels tempting to do:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;all(1 &amp;lt;= n &amp;lt;= 3 or -3 &amp;lt;= n &amp;lt;= -1 for n in diffs)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;however that&amp;rsquo;s incorrect. For example: &lt;code&gt;diffs = [1, -1, 1, -1]&lt;/code&gt; with an input
such as &lt;code&gt;[1, 2, 1, 2]&lt;/code&gt; would pass the test even though it shouldn&amp;rsquo;t.&lt;/p&gt;
&lt;p&gt;It also feels tempting to use &lt;code&gt;abs()&lt;/code&gt; but then an additional check would be
necessary to ensure the diffs are either all positive or all negative.&lt;/p&gt;
&lt;p&gt;The second part was trickier.&lt;/p&gt;
&lt;p&gt;Initially I was doing:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;list(1 &amp;lt;= n &amp;lt;= 3 for n in diffs).count(False) &amp;lt;= 1 or list(-3 &amp;lt;= n &amp;lt;= -1 for n in diffs).count(False) &amp;lt;= 1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;but then I realized I misunderstood the problem.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;1 2 7 8 9&lt;/code&gt; line, whose diff is &lt;code&gt;[1, 5, 1, 1]&lt;/code&gt;, illustrates it well: in
principle it would pass the test by dropping &amp;ldquo;5&amp;rdquo; from the diff. However, that
cannot be correct, because &lt;code&gt;2 -&amp;gt; 8&lt;/code&gt; is too big of a jump.&lt;/p&gt;
&lt;p&gt;The brute force way is to drop elements one by one, splitting the original list
into two, and then checking &lt;code&gt;is_safe&lt;/code&gt; in the merged sublists. That would
require computing &lt;code&gt;diffs&lt;/code&gt; every time, which would yield an &lt;code&gt;O(n^2)&lt;/code&gt; solution.&lt;/p&gt;
&lt;p&gt;We can do better by pre-computing &lt;code&gt;diffs&lt;/code&gt; only once, and then adding a bit of
manipulation to reconstruct what the merged diffs would be. The end goal is to
compute this:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python3"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python3&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python3"&gt;is_safe(diffs[:i-1] &amp;#43; [l[i&amp;#43;1] - l[i-1]] &amp;#43; diffs[i&amp;#43;1:]):&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;i.e. the left part of &lt;code&gt;diffs&lt;/code&gt;, the right part of &lt;code&gt;diffs&lt;/code&gt;, and a rolling diff
element in the middle.&lt;/p&gt;
&lt;p&gt;The full solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

from itertools import pairwise

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 safe = 0
 safe_damp = 0

 def is_safe(diffs):
 return all(1 &amp;lt;= n &amp;lt;= 3 for n in diffs) or all(-3 &amp;lt;= n &amp;lt;= -1 for n in diffs)

 for line in lines:
 l = list(map(int, line.split(&amp;#39; &amp;#39;)))
 diffs = [(b - a) for (a,b) in pairwise(l)]

 is_this_safe = is_safe(diffs)
 if is_this_safe:
 safe &amp;#43;= 1
 safe_damp &amp;#43;= 1
 continue

 for i in range(len(l)):
 if i == 0:
 if is_safe(diffs[1:]):
 safe_damp &amp;#43;= 1
 break
 elif i == len(l) - 1:
 if is_safe(diffs[:-1]):
 safe_damp &amp;#43;= 1
 break
 else:
 if is_safe(diffs[:i-1] &amp;#43; [l[i&amp;#43;1] - l[i-1]] &amp;#43; diffs[i&amp;#43;1:]):
 safe_damp &amp;#43;= 1
 break

 # part one
 print(safe)

 # part two
 print(safe_damp)

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;A few notes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;there&amp;rsquo;s no need for &lt;code&gt;pairwise&lt;/code&gt;; a plain &lt;code&gt;for-range&lt;/code&gt; loop would have done the
job just fine; &lt;code&gt;pairwise&lt;/code&gt; is stylish though&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 3&lt;/code&gt; is syntactic sugar for &lt;code&gt;1 &amp;lt;= n and n &amp;lt;= 3&lt;/code&gt;. Python is sweet.&lt;/li&gt;
&lt;li&gt;part two could become a bit more elegant by introducing another helper
function&lt;/li&gt;
&lt;li&gt;naming is hard&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pairwise&lt;/code&gt; is only available from Python 3.10+. macOS 15 (Sequoia) ships with
Python 3.9. Oh well&amp;hellip;I needed to use the Python binary from homebrew.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 2"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2024: Day 1</title><link>https://perrotta.dev/2024/12/advent-of-code-2024-day-1/</link><pubDate>Sun, 01 Dec 2024 22:29:19 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2024/12/advent-of-code-2024-day-1/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2024/day/1"&gt;Day #1&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;This is just a warm-up.&lt;/p&gt;
&lt;p&gt;Given two lists of integers, iterate over them and sum the absolute difference
between each pair. &lt;code&gt;zip&lt;/code&gt; + &lt;code&gt;sum&lt;/code&gt; is the perfect pair&lt;sup id="fnref:1"&gt;&lt;a href="https://perrotta.dev/2024/12/advent-of-code-2024-day-1/#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt; for the job.&lt;/p&gt;
&lt;p&gt;Part two: iterate over the left list whilst accumulating how often the element
appears in the right list. &amp;ldquo;How often&amp;rdquo; has, almost always, the smell of a
&lt;a href="https://docs.python.org/3/library/collections.html#collections.Counter"&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The full solution&lt;sup id="fnref:2"&gt;&lt;a href="https://perrotta.dev/2024/12/advent-of-code-2024-day-1/#fn:2" class="footnote-ref" role="doc-noteref"&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

from collections import Counter

def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 left = []
 right = []

 for line in lines:
 l, r = map(int, line.split())
 left.append(l)
 right.append(r)

 left.sort()
 right.sort()

 # part one
 print(sum(abs(l - r) for (l, r) in zip(left, right)))

 freqs = Counter(right)

 # part two
 print(sum(l * freqs[l] for l in left))

if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=3WpdCZC9q6w"&gt;I&amp;rsquo;m not sure I like it, And I&amp;rsquo;m so tired of
fighting&lt;/a&gt;&amp;#160;&lt;a href="https://perrotta.dev/2024/12/advent-of-code-2024-day-1/#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;The git repository is ever-evolving and the source of truth, whereas the
blog post is a snapshot. I&amp;rsquo;ll experiment with cross-posting solutions here
even though it duplicates the repository ones.&amp;#160;&lt;a href="https://perrotta.dev/2024/12/advent-of-code-2024-day-1/#fnref:2" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2024: Day 1"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2023: Day 1</title><link>https://perrotta.dev/2023/12/advent-of-code-2023-day-1/</link><pubDate>Mon, 04 Dec 2023 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2023/12/advent-of-code-2023-day-1/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2023/day/1"&gt;Day #1&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;The first part is straightforward: extract the first and last digit from each
line and sum them.&lt;/p&gt;
&lt;p&gt;Part two gets trickier: we need to handle spelled-out digits like &amp;ldquo;one&amp;rdquo;, &amp;ldquo;two&amp;rdquo;,
etc. The naive approach of replacing spellings with digits fails for overlapping
cases like &amp;ldquo;eightwothree&amp;rdquo; which should yield 83, not 23.&lt;/p&gt;
&lt;p&gt;The solution: find the leftmost and rightmost match among all digit spellings
and numeric digits, then combine them.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys


def get_calibration_value(line: str) -&amp;gt; int:
 &amp;#34;&amp;#34;&amp;#34;
 Extract the first and the last digit from the string, and return a number
 composed by them, in that order.
 &amp;#39;1abc2&amp;#39; -&amp;gt; 12
 &amp;#34;&amp;#34;&amp;#34;
 digits = [c for c in line if c.isdigit()]
 return int(digits[0] &amp;#43; digits[-1])


SPELLINGS = {
 # &amp;#39;zero&amp;#39;: &amp;#39;0&amp;#39;, # not in the problem statement
 &amp;#39;one&amp;#39;: &amp;#39;1&amp;#39;,
 &amp;#39;two&amp;#39;: &amp;#39;2&amp;#39;,
 &amp;#39;three&amp;#39;: &amp;#39;3&amp;#39;,
 &amp;#39;four&amp;#39;: &amp;#39;4&amp;#39;,
 &amp;#39;five&amp;#39;: &amp;#39;5&amp;#39;,
 &amp;#39;six&amp;#39;: &amp;#39;6&amp;#39;,
 &amp;#39;seven&amp;#39;: &amp;#39;7&amp;#39;,
 &amp;#39;eight&amp;#39;: &amp;#39;8&amp;#39;,
 &amp;#39;nine&amp;#39;: &amp;#39;9&amp;#39;,
}


# This attempt is incorrect because of the following test case:
# eightwothree -&amp;gt; eigh23 -&amp;gt; 23
# Whereas it should have been 83.
def get_calibration_value_with_spellings_attempt_1(line: str) -&amp;gt; int:
 for spelling, digit in SPELLINGS.items():
 line = line.replace(spelling, digit)

 return get_calibration_value(line)


def get_calibration_value_with_spellings(line: str) -&amp;gt; int:
 targets = set(list(SPELLINGS.keys()) &amp;#43; list(SPELLINGS.values()))

 # from the left
 indices = {}
 for target in targets:
 index = line.find(target)
 if index != -1:
 indices[target] = index

 [target_min, _] = min(list(indices.items()), key=lambda x: x[1])

 # from the right
 indices = {}
 for target in targets:
 index = line.rfind(target)
 if index != -1:
 indices[target] = index

 [target_max, _] = max(list(indices.items()), key=lambda x: x[1])

 if target_min in SPELLINGS:
 target_min = SPELLINGS[target_min]

 if target_max in SPELLINGS:
 target_max = SPELLINGS[target_max]

 return int(target_min &amp;#43; target_max)


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 # Part I
 print(sum([get_calibration_value(line) for line in lines]))

 # Part II
 print(sum([get_calibration_value_with_spellings(line) for line in lines]))


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2023: Day 1"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 10</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-10/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-10/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/10"&gt;Day #10&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Calculate signal strength and render CRT output.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 X = 1
 cycle = 1
 cycle_to_X = {cycle: X}

 for line in lines:
 if line == &amp;#39;noop&amp;#39;:
 cycle &amp;#43;= 1
 else:
 increment = int(line.split(&amp;#39; &amp;#39;)[1])
 X &amp;#43;= increment
 cycle &amp;#43;= 2
 cycle_to_X[cycle] = X

 strength = 0

 for multiple in range(20, max(cycle_to_X.keys()), 40):
 if multiple in cycle_to_X:
 strength &amp;#43;= multiple * cycle_to_X[multiple]
 else:
 predecessor = max(
 [key for key in cycle_to_X.keys() if key &amp;lt; multiple])
 strength &amp;#43;= multiple * cycle_to_X[predecessor]

 # Part 1
 print(strength)


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 10"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 9</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-9/</link><pubDate>Mon, 12 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-9/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/9"&gt;Day #9&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Simulate rope physics with head and tail.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

DIRECTIONS = {
 &amp;#39;L&amp;#39;: (-1, 0), # left
 &amp;#39;R&amp;#39;: (&amp;#43;1, 0), # right
 &amp;#39;D&amp;#39;: (0, -1), # down
 &amp;#39;U&amp;#39;: (0, &amp;#43;1), # up
}


def execute_move(H, T, direction, num_moves, visited):
 for _ in range(num_moves):
 # overlapping: only move head
 if H == T:
 H = (H[0] &amp;#43; DIRECTIONS[direction][0],
 H[1] &amp;#43; DIRECTIONS[direction][1])
 # next to each other in a &amp;#39;&amp;#43;&amp;#39; fashion: move T only if H moves in same direction
 elif abs(H[0] - T[0]) &amp;#43; abs(H[1] - T[1]) == 1:
 H = (H[0] &amp;#43; DIRECTIONS[direction][0],
 H[1] &amp;#43; DIRECTIONS[direction][1])
 if abs(H[0] - T[0]) == 2 or abs(H[1] - T[1]) == 2:
 T = (T[0] &amp;#43; DIRECTIONS[direction][0],
 T[1] &amp;#43; DIRECTIONS[direction][1])
 visited.add(T)
 # next to each other in an &amp;#39;x&amp;#39; fashion: move T only if H moves farther away
 else:
 H_prev = H
 H = (H[0] &amp;#43; DIRECTIONS[direction][0],
 H[1] &amp;#43; DIRECTIONS[direction][1])
 if (abs(H[0] - T[0]) &amp;#43; abs(H[1] - T[1])) == 3:
 T = H_prev
 visited.add(T)

 return H, T, visited


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 # Initial position of Head and Tail.
 H = T = (0, 0)

 # Tuple with (x, y) coordinates, assume (0, 0) is the starting point.
 visited = {(0, 0)}

 for line in lines:
 direction, num_moves = line.split(&amp;#39; &amp;#39;)
 H, T, visited = execute_move(H, T, direction, int(num_moves), visited)

 # Part 1
 print(len(visited))


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 9"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 8</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-8/</link><pubDate>Sun, 11 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-8/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/8"&gt;Day #8&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Count visible trees and find best scenic score.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import itertools
import sys

DIRECTIONS = [
 [-1, 0], # left
 [&amp;#43;1, 0], # right
 [0, -1], # down
 [0, &amp;#43;1], # up
]


def is_visible(lines, x, y, is_scenic):
 this_tree = lines[y][x]
 scenic = 1

 for direction in DIRECTIONS:
 visible = True

 step = 1
 while True:
 next_x = x &amp;#43; step * direction[0]
 next_y = y &amp;#43; step * direction[1]

 if 0 &amp;lt;= next_x &amp;lt; len(lines[0]) and 0 &amp;lt;= next_y &amp;lt; len(lines):
 next_tree = lines[next_y][next_x]
 if next_tree &amp;gt;= this_tree:
 visible = False
 break
 step &amp;#43;= 1
 else:
 step -= 1
 break

 scenic *= step

 if visible and not is_scenic:
 return visible

 return scenic if is_scenic else visible


def compute_inner_visible_trees(lines, *, is_scenic):
 &amp;#34;&amp;#34;&amp;#34;
 Cartesian product: [y][x]
 0 ---&amp;gt; x
 |
 |
 y v
 &amp;#34;&amp;#34;&amp;#34;
 if is_scenic:
 return max(int(is_visible(lines, x, y, is_scenic)) for (x, y) in itertools.product(range(1, len(lines[0]) - 1), range(1, len(lines) - 1)))
 else:
 return sum(int(is_visible(lines, x, y, is_scenic)) for (x, y) in itertools.product(range(1, len(lines[0]) - 1), range(1, len(lines) - 1)))


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 outer_visible_trees = 2 * (len(lines) &amp;#43; len(lines[0])) - 4

 # Part 1
 print(outer_visible_trees &amp;#43; compute_inner_visible_trees(lines, is_scenic=False))

 # Part 2
 print(compute_inner_visible_trees(lines, is_scenic=True))


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 8"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 7</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-7/</link><pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-7/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/7"&gt;Day #7&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Find small directories and directory to delete for update.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
from collections import defaultdict
import sys


def exec_cd(directory, pwd):
 if directory == &amp;#39;..&amp;#39;:
 pwd = &amp;#39;/&amp;#39;.join(pwd.split(&amp;#39;/&amp;#39;)[:-2]) &amp;#43; &amp;#39;/&amp;#39;
 elif directory == &amp;#39;/&amp;#39;:
 pwd = &amp;#39;/&amp;#39;
 else:
 pwd &amp;#43;= directory &amp;#43; &amp;#39;/&amp;#39;
 return pwd


def parse_line(line, FILE_TO_SIZE, pwd):
 if line.startswith(&amp;#39;$ cd &amp;#39;):
 dir = line.split(&amp;#39;$ cd &amp;#39;)[1]
 pwd = exec_cd(dir, pwd)
 elif line.startswith(&amp;#39;$ ls&amp;#39;):
 pass
 elif line.startswith(&amp;#39;dir &amp;#39;):
 dir = pwd &amp;#43; line.split(&amp;#39;dir &amp;#39;)[1]
 else:
 size, file_basename = line.split(&amp;#39; &amp;#39;)
 file = pwd &amp;#43; file_basename
 FILE_TO_SIZE[file] = int(size)
 return pwd


def parse_input(lines, *, FILE_TO_SIZE, pwd):
 for line in lines:
 pwd = parse_line(line, FILE_TO_SIZE, pwd)
 return FILE_TO_SIZE


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 FILE_TO_SIZE = parse_input(lines, FILE_TO_SIZE={}, pwd=&amp;#39;/&amp;#39;)
 DIRECTORY_TO_SIZE = defaultdict(int)

 for file, size in FILE_TO_SIZE.items():
 components = file.split(&amp;#39;/&amp;#39;)[:-1]
 for i in range(1, len(components) &amp;#43; 1):
 directory = &amp;#39;/&amp;#39;.join(components[:i])
 DIRECTORY_TO_SIZE[directory] &amp;#43;= FILE_TO_SIZE[file]

 # Minor fixes for &amp;#39;/&amp;#39; canonicalization
 DIRECTORY_TO_SIZE[&amp;#39;/&amp;#39;] = DIRECTORY_TO_SIZE[&amp;#39;&amp;#39;]
 del DIRECTORY_TO_SIZE[&amp;#39;&amp;#39;]

 # Part 1
 print(sum([value for value in DIRECTORY_TO_SIZE.values() if value &amp;lt;= 100000]))

 # Part 2
 TOTAL_DISK = 70000000
 USED_DISK = DIRECTORY_TO_SIZE[&amp;#39;/&amp;#39;]
 AVAILABLE_DISK = TOTAL_DISK - USED_DISK

 print(next(value for value in sorted(DIRECTORY_TO_SIZE.values())
 if (AVAILABLE_DISK &amp;#43; value) &amp;gt;= 30000000))


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 7"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 6</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-6/</link><pubDate>Wed, 07 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-6/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/6"&gt;Day #6&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Find start-of-packet and start-of-message markers in data stream.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
from collections import defaultdict
import sys


def all_different(window):
 hash = defaultdict(int)
 for el in window:
 hash[el] &amp;#43;= 1
 return not any(map(lambda x: x &amp;gt; 1, hash.values()))


def find_marker(buffer, size):
 for i in range(len(buffer) - (size - 1)):
 window = buffer[i:i &amp;#43; size]
 if (all_different(window)):
 return i &amp;#43; size


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 buffer = lines[0]

 # Part 1
 print(find_marker(buffer, 4))

 # Part 2
 print(find_marker(buffer, 14))


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 6"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 5</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-5/</link><pubDate>Tue, 06 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-5/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/5"&gt;Day #5&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Rearrange crate stacks. Part two moves crates in order rather than one by one.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import itertools
import sys
from copy import deepcopy


def parse_input(crates_unparsed):
 &amp;#34;&amp;#34;&amp;#34;
 Returns a dictionary in the following form:

 {
 1: &amp;#39;ZN&amp;#39;,
 2: &amp;#39;MCD&amp;#39;,
 3: &amp;#39;P&amp;#39;,
 }
 &amp;#34;&amp;#34;&amp;#34;

 crates = {}

 num_stacks = (len(crates_unparsed[0]) &amp;#43; 1) // 4
 max_height = len(crates_unparsed) - 1

 for i_stack in range(1, num_stacks &amp;#43; 1):
 stack_xaxis = 4 * (i_stack - 1) &amp;#43; 1

 # List comprehension version, not super readable:
 # crates[i_stack] = &amp;#39;&amp;#39;.join(list(filter(lambda x: x != &amp;#39; &amp;#39;, [crates_unparsed[max_height - i][stack_xaxis]
 # for i in range(1, max_height &amp;#43; 1)])))

 crates[i_stack] = &amp;#39;&amp;#39;
 for i in range(1, max_height &amp;#43; 1):
 crate = crates_unparsed[max_height - i][stack_xaxis]
 if crate != &amp;#39; &amp;#39;:
 crates[i_stack] &amp;#43;= crate

 return crates


def move_crates(moves_unparsed, crates, *, reverse):
 for move_unparsed in moves_unparsed:
 _, quantity, _, src, _, dst = move_unparsed.split(&amp;#39; &amp;#39;)
 quantity, src, dst = int(quantity), int(src), int(dst)
 move_crate(crates, quantity, src, dst, reverse)
 return crates


def move_crate(crates, quantity, src, dst, reverse):
 if reverse:
 crates[dst] &amp;#43;= crates[src][(-1) * quantity:][::-1]
 else:
 crates[dst] &amp;#43;= crates[src][(-1) * quantity:]
 crates[src] = crates[src][:(-1) * quantity]


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 crates_unparsed, moves_unparsed = [list(group) for key, group in itertools.groupby(
 lines, lambda a: a == &amp;#34;&amp;#34;) if not key]

 crates = parse_input(crates_unparsed)

 # Part 1
 crates_part1 = move_crates(moves_unparsed, deepcopy(crates), reverse=True)
 print(&amp;#39;&amp;#39;.join([value[-1] for value in crates_part1.values()]))

 # Part 2
 crates_part2 = move_crates(moves_unparsed, deepcopy(crates), reverse=False)
 print(&amp;#39;&amp;#39;.join([value[-1] for value in crates_part2.values()]))


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 5"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 4</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-4/</link><pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-4/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/4"&gt;Day #4&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Find overlapping cleaning assignment pairs.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys


def eitherContains(e1, e2):
 if e1[0] &amp;gt;= e2[0] and e1[1] &amp;lt;= e2[1]:
 return 1
 elif e2[0] &amp;gt;= e1[0] and e2[1] &amp;lt;= e1[1]:
 return 1
 else:
 return 0


def anyOverlap(e1, e2):
 return int((e1[1] &amp;gt;= e2[0]) and (e1[0] &amp;lt;= e2[1]))


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 totalEitherContains = 0
 totalAnyOverlap = 0

 for line in lines:
 # [[&amp;#39;2&amp;#39;, &amp;#39;4&amp;#39;], [&amp;#39;6&amp;#39;, &amp;#39;8&amp;#39;]]
 [e1, e2] = [el.split(&amp;#39;-&amp;#39;) for el in line.split(&amp;#39;,&amp;#39;)]
 # [2, 4], [6, 8]
 e1, e2 = list(map(int, e1)), list(map(int, e2))

 totalEitherContains &amp;#43;= eitherContains(e1, e2)
 totalAnyOverlap &amp;#43;= anyOverlap(e1, e2)

 # Part 1
 print(totalEitherContains)

 # Part 2
 print(totalAnyOverlap)


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 4"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 2</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-2/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-2/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/2"&gt;Day #2&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Rock paper scissors strategy. Part two uses win/draw/lose outcomes.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

MOVE_SCORE = {
 # theirs
 &amp;#39;A&amp;#39;: 1, # rock
 &amp;#39;B&amp;#39;: 2, # paper
 &amp;#39;C&amp;#39;: 3, # scissors

 # mine
 &amp;#39;X&amp;#39;: 1, # rock
 &amp;#39;Y&amp;#39;: 2, # paper
 &amp;#39;Z&amp;#39;: 3, # scissors
}


def battle(theirs, mine):
 if (theirs, mine) in [(&amp;#39;A&amp;#39;, &amp;#39;X&amp;#39;), (&amp;#39;B&amp;#39;, &amp;#39;Y&amp;#39;), (&amp;#39;C&amp;#39;, &amp;#39;Z&amp;#39;)]:
 return 3 # draw
 elif (theirs, mine) in [(&amp;#39;A&amp;#39;, &amp;#39;Z&amp;#39;), (&amp;#39;B&amp;#39;, &amp;#39;X&amp;#39;), (&amp;#39;C&amp;#39;, &amp;#39;Y&amp;#39;)]:
 return 0 # defeat
 else:
 return 6 # victory


def strategy(theirs, mine):
 if mine == &amp;#39;Y&amp;#39;: # draw
 return chr(ord(theirs) &amp;#43; (ord(&amp;#39;X&amp;#39;) - ord(&amp;#39;A&amp;#39;)))
 elif mine == &amp;#39;X&amp;#39;: # lose
 return {&amp;#39;A&amp;#39;: &amp;#39;Z&amp;#39;, &amp;#39;B&amp;#39;: &amp;#39;X&amp;#39;, &amp;#39;C&amp;#39;: &amp;#39;Y&amp;#39;}[theirs]
 else: # win
 assert mine == &amp;#39;Z&amp;#39;
 return {&amp;#39;A&amp;#39;: &amp;#39;Y&amp;#39;, &amp;#39;B&amp;#39;: &amp;#39;Z&amp;#39;, &amp;#39;C&amp;#39;: &amp;#39;X&amp;#39;}[theirs]


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 score1, score2 = 0, 0

 for line in lines:
 theirs, mine = line.split(&amp;#39; &amp;#39;)

 score1 &amp;#43;= MOVE_SCORE[mine] &amp;#43; battle(theirs, mine)

 mine = strategy(theirs, mine)
 score2 &amp;#43;= MOVE_SCORE[mine] &amp;#43; battle(theirs, mine)

 print(score1)
 print(score2)


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 2"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 3</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-3/</link><pubDate>Sat, 03 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-3/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/3"&gt;Day #3&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Find misplaced items in rucksacks. Part two finds common items across three rucksacks.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys


def priority(item):
 if item.islower():
 return ord(item) - ord(&amp;#39;a&amp;#39;) &amp;#43; 1
 else:
 assert item.isupper()
 return ord(item) - ord(&amp;#39;A&amp;#39;) &amp;#43; 27


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 total_priority = 0

 # Part 1
 for line in lines:
 c1 = line[:len(line)//2]
 c2 = line[len(line)//2:]
 item = next(iter(set(c1).intersection(c2)))
 total_priority &amp;#43;= priority(item)

 print(total_priority)

 # Part 2
 print(sum([priority(next(iter(set(line1).intersection(line2).intersection(line3))))
 for (line1, line2, line3) in zip(lines[::3], lines[1::3], lines[2::3])]))


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 3"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2022: Day 1</title><link>https://perrotta.dev/2022/12/advent-of-code-2022-day-1/</link><pubDate>Thu, 01 Dec 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/12/advent-of-code-2022-day-1/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2022/day/1"&gt;Day #1&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Find the elf carrying the most calories. Part two finds the top three elves.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import itertools
import sys


def main():
 with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

 # [&amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;&amp;#39;, &amp;#39;3&amp;#39;] -&amp;gt; [1, 2, &amp;#39;&amp;#39;, 3]
 lines = [int(line) if line != &amp;#34;&amp;#34; else line for line in lines]

 # [1, 2, &amp;#39;&amp;#39;, 3] -&amp;gt; [[1, 2], [3]]
 groups = [list(group) for key, group in itertools.groupby(
 lines, lambda a: a == &amp;#34;&amp;#34;) if not key]

 # Part 1
 calories = [sum(group) for group in groups]

 print(max(calories))

 # Part 2
 print(sum(sorted(calories, reverse=True)[:3]))


if __name__ == &amp;#39;__main__&amp;#39;:
 main()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2022: Day 1"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2021: Day 1</title><link>https://perrotta.dev/2022/11/advent-of-code-2021-day-1/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/11/advent-of-code-2021-day-1/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2021/day/1"&gt;Day #1&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Count the number of times a measurement increases from one to the next. Part two
uses a sliding window of three measurements.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

with open(sys.argv[1]) as input:
 lines = input.readlines()

numbers = [int(line.strip()) for line in lines]

# Part 1
print(sum(y &amp;gt; x for x, y in zip(numbers[:-1], numbers[1:])))

# Part 2
print(sum(y &amp;gt; x for x, y in zip(numbers[:-3], numbers[3:])))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2021: Day 1"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2021: Day 2</title><link>https://perrotta.dev/2022/11/advent-of-code-2021-day-2/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/11/advent-of-code-2021-day-2/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2021/day/2"&gt;Day #2&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Calculate final position using forward, down, and up instructions. Part two introduces an aim variable.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

with open(sys.argv[1]) as input:
 lines = input.readlines()

units = [line.split(&amp;#39; &amp;#39;) for line in lines]

# Part 1
x = sum(int(unit[1]) for unit in units if unit[0] == &amp;#39;forward&amp;#39;)
y = sum(int(unit[1]) if unit[0] == &amp;#39;down&amp;#39; else (-1) * int(unit[1]) if unit[0] == &amp;#39;up&amp;#39; else 0 for unit in units)

print(x * y)

# Part 2
x = 0
y = 0
aim = 0

for unit in units:
 instruction = unit[0]
 distance = int(unit[1])

 if instruction == &amp;#39;forward&amp;#39;:
 x &amp;#43;= distance
 y &amp;#43;= aim * distance
 elif instruction == &amp;#39;up&amp;#39;:
 aim -= distance
 elif instruction == &amp;#39;down&amp;#39;:
 aim &amp;#43;= distance

print(x * y)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2021: Day 2"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2021: Day 3</title><link>https://perrotta.dev/2022/11/advent-of-code-2021-day-3/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/11/advent-of-code-2021-day-3/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2021/day/3"&gt;Day #3&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Calculate power consumption using binary diagnostic data. Part two finds oxygen and CO2 ratings using bit criteria.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import numpy as np
import sys

with open(sys.argv[1]) as input:
 lines = input.readlines()

lines = [list(line.strip()) for line in lines]

# Part 1
transposed = np.array(lines).T.tolist()

gamma_str = &amp;#39;&amp;#39;.join([&amp;#39;1&amp;#39; if col.count(&amp;#39;1&amp;#39;) &amp;gt; col.count(&amp;#39;0&amp;#39;) else &amp;#39;0&amp;#39; for col in transposed])
gamma = int(gamma_str, base = 2)

epsilon_str = &amp;#39;&amp;#39;.join([&amp;#39;0&amp;#39; if c == &amp;#39;1&amp;#39; else &amp;#39;1&amp;#39; for c in gamma_str])
epsilon = int(epsilon_str, base = 2)

print(gamma * epsilon)

# Part 2
def oxygen(lines, depth = 0):
 if len(lines) == 1:
 return int(&amp;#39;&amp;#39;.join(lines[0]), base = 2)

 transposed = np.array(lines).T.tolist()

 most_common = &amp;#39;1&amp;#39; if transposed[depth].count(&amp;#39;1&amp;#39;) &amp;gt;= transposed[depth].count(&amp;#39;0&amp;#39;) else &amp;#39;0&amp;#39;

 return oxygen([line for line in lines if line[depth] == most_common], depth &amp;#43; 1)

def co2(lines, depth = 0):
 if len(lines) == 1:
 return int(&amp;#39;&amp;#39;.join(lines[0]), base = 2)

 transposed = np.array(lines).T.tolist()

 most_common = &amp;#39;1&amp;#39; if transposed[depth].count(&amp;#39;1&amp;#39;) &amp;lt; transposed[depth].count(&amp;#39;0&amp;#39;) else &amp;#39;0&amp;#39;

 return co2([line for line in lines if line[depth] == most_common], depth &amp;#43; 1)

print(oxygen(lines) * co2(lines))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2021: Day 3"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2021: Day 4</title><link>https://perrotta.dev/2022/11/advent-of-code-2021-day-4/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/11/advent-of-code-2021-day-4/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2021/day/4"&gt;Day #4&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Play bingo with submarine boards. Part one finds first winning board, part two finds last winning board.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import re
import sys

with open(sys.argv[1]) as input:
 lines = input.readlines()

draws = list(map(int, lines[0].strip().split(&amp;#39;,&amp;#39;)))

num_boards = len(lines) // 6

boards = [[[[int(el), False] for el in re.split(r&amp;#39;[ ]&amp;#43;&amp;#39;, r.strip())] for r in board] for board in [lines[(6 * n &amp;#43; 2) : 6 * n &amp;#43; 7] for n in range(num_boards)]]

def mark_board(board, draw):
 for row in board:
 for el in row:
 if el[0] == draw:
 el[1] = True
 return

def check_rows(board):
 for row in board:
 if all(marked for _, marked in row):
 return True
 return False

def check_cols(board):
 for col in zip(*board):
 if all(marked for _, marked in col):
 return True
 return False

def check_board(board):
 return check_rows(board) or check_cols(board)

def score(board, draw):
 return sum([n for n, marked in sum(board, []) if not marked]) * draw

def part1(boards, draws):
 for draw in draws:
 for board in boards:
 mark_board(board, draw)
 if check_board(board):
 print(score(board, draw))
 return

def part2(boards, draws):
 finished = [False] * len(boards)

 for draw in draws:
 for i, board in enumerate(boards):
 if finished[i]:
 continue
 mark_board(board, draw)
 if check_board(board):
 finished[i] = True
 if all(finished):
 print(score(board, draw))
 return

part1(boards, draws)
part2(boards, draws)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2021: Day 4"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2021: Day 5</title><link>https://perrotta.dev/2022/11/advent-of-code-2021-day-5/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/11/advent-of-code-2021-day-5/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2021/day/5"&gt;Day #5&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Draw lines on a grid and count overlapping points. Part two includes diagonal lines.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
from collections import defaultdict
from itertools import count, islice
import sys

with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

def direction(a, b):
 &amp;#34;&amp;#34;&amp;#34;
 3, 5 =&amp;gt; &amp;#43;1
 5, 3 =&amp;gt; -1
 5, 5 =&amp;gt; 0
 &amp;#34;&amp;#34;&amp;#34;
 return 1 if b &amp;gt; a else -1 if a &amp;gt; b else 0

def fill(floor, x1, y1, x2, y2):
 for x, y in islice(zip(count(start = x1, step = direction(x1, x2)), count(start = y1, step = direction(y1, y2))), max(abs(x2 - x1), abs(y2 - y1)) &amp;#43; 1):
 floor[(x, y)] &amp;#43;= 1

def part1():
 floor = defaultdict(int)

 for line in lines:
 (x1, y1), (x2, y2) = _, _ = [list(map(int, pair.split(&amp;#39;,&amp;#39;))) for pair in line.split(&amp;#39; -&amp;gt; &amp;#39;)]
 if x1 == x2 or y1 == y2:
 fill(floor, x1, y1, x2, y2)

 print(sum(el &amp;gt;= 2 for el in floor.values()))

def part2():
 floor = defaultdict(int)

 for line in lines:
 (x1, y1), (x2, y2) = _, _ = [list(map(int, pair.split(&amp;#39;,&amp;#39;))) for pair in line.split(&amp;#39; -&amp;gt; &amp;#39;)]
 fill(floor, x1, y1, x2, y2)

 print(sum(el &amp;gt;= 2 for el in floor.values()))

part1()
part2()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2021: Day 5"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2021: Day 6</title><link>https://perrotta.dev/2022/11/advent-of-code-2021-day-6/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/11/advent-of-code-2021-day-6/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2021/day/6"&gt;Day #6&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Simulate lanternfish population growth using a counter to track fish by their internal timer.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
from collections import Counter
import sys

with open(sys.argv[1]) as input:
 numbers = list(map(int, input.read().split(&amp;#39;,&amp;#39;)))

def simulation(days):
 fish = Counter(numbers)

 for _ in range(days):
 next_fish = Counter()
 for timer, count in fish.items():
 if timer == 0:
 next_fish[8] &amp;#43;= fish[timer]
 next_fish[6] &amp;#43;= fish[timer]
 else:
 next_fish[timer - 1] &amp;#43;= fish[timer]
 fish = next_fish

 print(sum(fish.values()))

simulation(80)
simulation(256)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2021: Day 6"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2021: Day 7</title><link>https://perrotta.dev/2022/11/advent-of-code-2021-day-7/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/11/advent-of-code-2021-day-7/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2021/day/7"&gt;Day #7&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Calculate optimal position for crab submarines. Part one uses median, part two uses triangular cost function.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import statistics
import sys

with open(sys.argv[1]) as input:
 numbers = list(map(int, input.read().split(&amp;#39;,&amp;#39;)))

def part1():
 median = int(statistics.median(numbers))
 fuel = int(sum(abs(median - number) for number in numbers))

 print(fuel)

def cost(n):
 return (n * (n &amp;#43; 1)) / 2

def part2():
 fuel = float(&amp;#39;inf&amp;#39;)

 for guess in range(min(numbers), max(numbers) &amp;#43; 1):
 fuel = min(int(sum(cost(abs(guess - number)) for number in numbers)), fuel)

 print(fuel)

part1()
part2()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2021: Day 7"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Advent of Code 2021: Day 8</title><link>https://perrotta.dev/2022/11/advent-of-code-2021-day-8/</link><pubDate>Sat, 26 Nov 2022 00:00:00 +0000</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>dev</category><guid>https://perrotta.dev/2022/11/advent-of-code-2021-day-8/</guid><description>&lt;p&gt;Refer to the &lt;a href="https://perrotta.dev/2022/01/advent-of-code/"&gt;previous post&lt;/a&gt; about AoC,
and to the &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;git repository&lt;/a&gt; with my
solutions in Python 3.&lt;/p&gt;
&lt;p&gt;Link to &lt;a href="https://adventofcode.com/2021/day/8"&gt;Day #8&lt;/a&gt; puzzle.&lt;/p&gt;
&lt;p&gt;Decode seven-segment display signals. Count unique digit segments in output values.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;#!/usr/bin/env python3
import sys

with open(sys.argv[1]) as input:
 lines = input.read().splitlines()

def part1():
 total = 0

 for line in lines:
 outputs = line.split(&amp;#39; | &amp;#39;)[1].split(&amp;#39; &amp;#39;)
 total &amp;#43;= sum(len(output) in [2, 3, 4, 7] for output in outputs)

 print(total)

part1()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code 2021: Day 8"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>‚òÖ Advent of Code</title><link>https://perrotta.dev/2022/01/advent-of-code/</link><pubDate>Fri, 28 Jan 2022 17:44:00 -0500</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>advent-of-code</category><category>bestof</category><category>dev</category><guid>https://perrotta.dev/2022/01/advent-of-code/</guid><description>&lt;p&gt;Last year I found out about &lt;a href="https://adventofcode.com/"&gt;Advent of Code&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="you-said-what"&gt;You said what?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Advent of Code&lt;/strong&gt; by &lt;a href="http://was.tl/"&gt;Eric Wastl&lt;/a&gt; happens every year since 2015, every December from the 1st to
the 25th. Each day there&amp;rsquo;s a new programming challenge&lt;sup id="fnref:1"&gt;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt; split into two
parts. The first part tends to be easier than the second one. The second part
usually builds upon the first one, being a follow-up task that requires more
steps and/or with a higher degree of complexity. You can&amp;rsquo;t always reuse the
bits from the first part to solve the second one though.&lt;/p&gt;
&lt;p&gt;For those familiar with programming contests like &lt;a href="https://icpc.global/"&gt;ACM ICPC&lt;/a&gt; or &lt;a href="https://olimpiada.ic.unicamp.br/"&gt;OBI&lt;/a&gt;, or online judges like &lt;a href="https://www.spoj.com/"&gt;SPOJ&lt;/a&gt; or &lt;a href="https://onlinejudge.org/"&gt;UVa&lt;/a&gt;, advent of code feels like home. The main difference is that there is no time pressure and no need to write spaghetti and unreadable code; in fact, writing readable and elegant solutions is encouraged (&lt;em&gt;citation needed&lt;/em&gt;&amp;hellip;).&lt;/p&gt;
&lt;p&gt;For those familiar with FAANG/Tech whiteboard interviews, advent of code feels a lot like a typical interview. I would even go further and say it&amp;rsquo;s a great way to practice for interviews.&lt;/p&gt;
&lt;p&gt;It is a great moment to either (i) learn a new exciting programming language or (ii) improve your mastery on programming languages that you already know. I know several people (see below) that used AoC&lt;sup id="fnref:2"&gt;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fn:2" class="footnote-ref" role="doc-noteref"&gt;2&lt;/a&gt;&lt;/sup&gt; to learn Rust or Kotlin or whatever else was exciting for them at the time. It&amp;rsquo;s surprising that the official Kotlin Docs even contain a section called &lt;a href="https://kotlinlang.org/docs/advent-of-code.html"&gt;Advent of Code puzzles in idiomatic Kotlin&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some folks go even further and use it to practice their &lt;a href="https://codegolf.stackexchange.com/questions/216024/advent-of-code-2020-day-2-part-1"&gt;code golfing&lt;/a&gt;&lt;sup id="fnref:3"&gt;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fn:3" class="footnote-ref" role="doc-noteref"&gt;3&lt;/a&gt;&lt;/sup&gt; or even &lt;a href="https://ryxcommar.com/2021/12/04/advent-of-code-2021-in-google-sheets-first-4-days/"&gt;Google Sheets&lt;/a&gt; skills. I have a deep amount of respect for them as it&amp;rsquo;s quite a challenge. If you think it stops there, I&amp;rsquo;ve also seen solutions in &lt;a href="https://github.com/phillbush/aoc"&gt;awk&lt;/a&gt; and &lt;a href="https://twitter.com/_rsc/status/1476683352493207561"&gt;sed&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another positive aspect of AoC is that it has an integrated dashboard that tracks your progress as you go. It&amp;rsquo;s a simple element of gamification that immensely improves motivation and fun. You really feel a big desire to collect all those 50 stars&amp;hellip;&lt;/p&gt;
&lt;h2 id="what-about-me"&gt;What about me?&lt;/h2&gt;
&lt;p&gt;My goal for 2021 was relatively less ambitious than that, I just wanted to improve my Python skills, more specifically Python 3. I learned Python 2 during my first year in university and used it sparingly at work and for personal endeavours, but always had a knowledge gap in Python 3.&lt;/p&gt;
&lt;p&gt;I set up a public git repository with &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;my solutions&lt;/a&gt; and aspired to write simple and elegant python, my only &lt;a href="https://frantic.im/no-constraints-no-fun/"&gt;constraint&lt;/a&gt; was to limit myself to what is available in the standard library of a vanilla python3 installation in Alpine linux, with the exception of &lt;a href="https://numpy.org/"&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; which is widespread enough to deserve an entry in my &lt;a href="https://github.com/thiagowfx/adventofcode/blob/master/requirements.txt"&gt;&lt;code&gt;requirements.txt&lt;/code&gt;&lt;/a&gt;, and of course devtools like debuggers, linters and auto formatters as needed.&lt;/p&gt;
&lt;p&gt;As an additional, non-programming challenge I also limited myself to only use the command line. This basically meant no IDEs&lt;sup id="fnref:4"&gt;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fn:4" class="footnote-ref" role="doc-noteref"&gt;4&lt;/a&gt;&lt;/sup&gt;. My programming environment was ultimately &lt;code&gt;ssh&lt;/code&gt; to an Alpine Linux VPS + &lt;code&gt;tmux&lt;/code&gt; + &lt;code&gt;vim&lt;/code&gt;. To make my life easier, one of the first tasks I accomplished was to write a generic &lt;a href="https://github.com/thiagowfx/adventofcode/blob/master/2022/Makefile"&gt;&lt;code&gt;Makefile&lt;/code&gt;&lt;/a&gt; to help me test and run my scripts. A typical invocation would look like:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ make DEBUG=1 DAY=3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;whereas I could choose between the sample input versus the real one with &lt;code&gt;DEBUG&lt;/code&gt;, and the puzzle day with &lt;code&gt;DAY&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Was the experience worth it? &lt;strong&gt;Definitely yes&lt;/strong&gt;! Even though I only completed ~8 puzzles out of the 25 ones due to having my attention split with another project I was working on at the time, the thematic submarine puzzles were hella fun and I learned a lot of python 3 on the way.&lt;/p&gt;
&lt;p&gt;A few highlights of what I learned &lt;em&gt;and used&lt;/em&gt; from my python &lt;code&gt;2to3&lt;/code&gt; transition were f-strings / string interpolation (&lt;code&gt;print(f'The sum is {sum}')&lt;/code&gt;), &amp;ldquo;everything is an iterator now&amp;rdquo; even &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;range&lt;/code&gt;, the standard library is awesome and sometimes you stumble upon useful abstractions like &lt;code&gt;Counter&lt;/code&gt; and &lt;code&gt;defaultdict&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt; is different now (&lt;code&gt;key&lt;/code&gt; instead of comparison function), this &lt;code&gt;pdb&lt;/code&gt; debugger thingy, among other topics I can&amp;rsquo;t remember at the moment. I realized the only concept that was previously familiar was the different syntax of the &lt;code&gt;print&lt;/code&gt; function (you have to use parentheses now).&lt;/p&gt;
&lt;p&gt;In terms of workflow, I also learned that virtual environments are now
supported natively&lt;sup id="fnref:5"&gt;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fn:5" class="footnote-ref" role="doc-noteref"&gt;5&lt;/a&gt;&lt;/sup&gt; (&lt;code&gt;python -m venv&lt;/code&gt;), &lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/"&gt;&lt;code&gt;direnv&lt;/code&gt;&lt;/a&gt; is an amazing tool to
automate/manage environments in git repositories and also happens to have
first-class python integration, &lt;code&gt;pylint&lt;/code&gt; and &lt;code&gt;autopep8&lt;/code&gt; are good integrations
with &lt;code&gt;vim&lt;/code&gt; to help spot basic errors and/or suggest best practices, and &lt;code&gt;numpy&lt;/code&gt; takes forever to build from source.&lt;/p&gt;
&lt;h2 id="what-about-the-community"&gt;What about the community?&lt;/h2&gt;
&lt;p&gt;AoC enjoys a lot of popularity and zeitgeist, especially during times of the COVID-19 pandemic, but even before then. There&amp;rsquo;s a large &lt;a href="https://www.reddit.com/r/adventofcode/"&gt;/r/adventofcode&lt;/a&gt; subreddit community, lots of people share their solution snippets and impressions on Twitter (&lt;a href="https://twitter.com/search?q=%23adventofcode&amp;amp;src=typed_query"&gt;#AdventOfCode&lt;/a&gt;), there&amp;rsquo;s a ton of public git repositories on &lt;a href="https://github.com/search?q=adventofcode"&gt;GitHub&lt;/a&gt; where people share their coding solutions, in pretty much any programming language you can think of, and finally there are many screencasts on &lt;a href="https://www.youtube.com/results?search_query=advent&amp;#43;of&amp;#43;code"&gt;YouTube&lt;/a&gt;. The Internet in the 2020s sparks creativity in every unimaginable corner.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s so much information that it&amp;rsquo;s impossible to stay on top of everything. Here is a small list of repositories that I followed this year, most of those are acquaintances/friends and/or stumbled upon Twitter:&lt;/p&gt;
&lt;p&gt;C++:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/riuri/adventofcode"&gt;https://github.com/riuri/adventofcode&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/sjvrijn/AdventofCode"&gt;https://github.com/sjvrijn/AdventofCode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/oomenn/AOC"&gt;https://github.com/oomenn/AOC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rust:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dimo414/advent-2021"&gt;https://github.com/dimo414/advent-2021&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mfs/aoc"&gt;https://github.com/mfs/aoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Edit (2024-08-06)&lt;/strong&gt;: Additions from 2022:&lt;/p&gt;
&lt;p&gt;C++:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/eariassoto/advent-of-code-cpp"&gt;https://github.com/eariassoto/advent-of-code-cpp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/achrafmam2/adventofcode"&gt;https://github.com/achrafmam2/adventofcode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mcerdeiro/aoc2022"&gt;https://github.com/mcerdeiro/aoc2022&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I find it&amp;rsquo;s really constructive and useful (and also &lt;em&gt;fun&lt;/em&gt;) to peek at other people&amp;rsquo;s solutions after I coded my own. I have extensive (albeit kinda rusty these days) experience with C++ so I wanted to follow at least one repository coded with it; since I wrote my solutions in python it was also a natural choice to follow a few python repositories; and, finally, I wanted to peek at some languages I am not familiar with to get a gist of them. This year I watched Rust and a few bits of Clojure and Kotlin on Twitter.&lt;/p&gt;
&lt;p&gt;Finally, for some extra inspiration, there are also some &lt;em&gt;10x programmers&lt;/em&gt;&lt;sup id="fnref:6"&gt;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fn:6" class="footnote-ref" role="doc-noteref"&gt;6&lt;/a&gt;&lt;/sup&gt; out there that seem to be fans of AoC as well: &lt;a href="https://github.com/norvig/pytudes"&gt;Peter Norvig&lt;/a&gt; and &lt;a href="https://twitter.com/_rsc/status/1466089522718986241"&gt;Russ Cox (&lt;em&gt;rsc&lt;/em&gt;)&lt;/a&gt;. There are probably several others I am not aware of.&lt;/p&gt;
&lt;h2 id="final-remarks"&gt;Final remarks&lt;/h2&gt;
&lt;p&gt;I am hoping to participate in AoC this year (2022) as well, and possibly revisit the 2021 puzzles and resolve the rest of the ones I missed as time permits.&lt;/p&gt;
&lt;p&gt;Hopefully this post encourages and motivates you to try Advent of Code as well! Happy coding.&lt;/p&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Or puzzle, if you will.&amp;#160;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Acronym not to be confused with a certain &lt;del&gt;annoying&lt;/del&gt;^W politician.&amp;#160;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fnref:2" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;For those unfamiliar with the concept, code golfing is all about writing a correct solution with the &lt;strong&gt;fewest&lt;/strong&gt; amount of characters.&amp;#160;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fnref:3" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;For example: PyCharm, and also VSCode, which is getting so big these days I don&amp;rsquo;t even know if it&amp;rsquo;s possible to just call it a simple text editor anymore.&amp;#160;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fnref:4" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:5"&gt;
&lt;p&gt;Back in the days, &lt;code&gt;virtualenvwrapper&lt;/code&gt; was all the rage.&amp;#160;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fnref:5" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:6"&gt;
&lt;p&gt;The &lt;em&gt;10x programmer&lt;/em&gt; thing is a well-known joke however in this instance the mentioned characters are indeed superb programmers that I immensely respect.&amp;#160;&lt;a href="https://perrotta.dev/2022/01/advent-of-code/#fnref:6" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Advent of Code"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/bestof/"&gt;#bestof&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>‚òÖ Direnv: Automate your Environment Variables</title><link>https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/</link><pubDate>Tue, 04 Jan 2022 00:34:07 -0500</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>advent-of-code</category><category>bestof</category><category>dev</category><guid>https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/</guid><description>&lt;p&gt;&lt;a href="https://direnv.net/"&gt;Direnv&lt;/a&gt; is a tool to automate your shell to automatically load and unload environment variables on-the-fly, on a per-project (per-directory) basis.&lt;/p&gt;
&lt;h2 id="preliminaries-is-it-worth-it"&gt;Preliminaries: Is it worth it?&lt;/h2&gt;
&lt;p&gt;Questions I like to ask myself before deciding whether to invest my time into learning and potentially &lt;strong&gt;adopting&lt;/strong&gt; a foreign tool are the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Is it &lt;strong&gt;popular&lt;/strong&gt; &lt;em&gt;and&lt;/em&gt; &lt;strong&gt;stable&lt;/strong&gt; enough?
Is it abandonware?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="popularity"&gt;Popularity&lt;/h3&gt;
&lt;p&gt;Popularity is relative, it doesn&amp;rsquo;t need to be worthy of the Hacker News frontpage nor Hotness on Reddit, but it needs to be widely available in popular Linux distributions and/or package managers, one install command away from my development environment.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://repology.org/"&gt;Repology&lt;/a&gt; is a good proxy for popularity. Looking at &lt;a href="https://repology.org/project/direnv/badges"&gt;direnv&lt;/a&gt; therein, it&amp;rsquo;s available for Alpine, Arch, Debian, Fedora, FreeBSD, HomeBrew, Nix, OpenBSD, Ubuntu&amp;hellip;that&amp;rsquo;s more than enough, we can safely conclude &lt;code&gt;direnv&lt;/code&gt; is widely popular.&lt;/p&gt;
&lt;p&gt;The main takeaway we want to confirm is whether the project isn&amp;rsquo;t too niche and/or an one-man show. Seeing signs of a small-ish community and/or occasional contributions from external users/developers helps build confidence and give credibility to the project.&lt;/p&gt;
&lt;h3 id="stability-and-abandonware"&gt;Stability and Abandonware&lt;/h3&gt;
&lt;p&gt;Stability is easier to define than popularity and can often be determined just by taking a quick glance at the github (or whichever other forge it&amp;rsquo;s hosted in) page of the project.&lt;/p&gt;
&lt;p&gt;At the time of this writing, the latest release of &lt;a href="https://github.com/direnv/direnv"&gt;direnv&lt;/a&gt; was about a week ago (2.30.2, Dec 28th 2021). It&amp;rsquo;s definitely not abandonware and it&amp;rsquo;s well maintained. A few signs that help corroborate that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Several PRs were merged recently&lt;/li&gt;
&lt;li&gt;Its issue tracker is quite active, with a good mix of feature requests and bugs&lt;/li&gt;
&lt;li&gt;I don&amp;rsquo;t like to judge the project based on the number of issues it has, especially if it&amp;rsquo;s popular. Chromium has &lt;a href="https://bugs.chromium.org/p/chromium/issues/list"&gt;60k+&lt;/a&gt; issues at the time of this writing, yet I wouldn&amp;rsquo;t call it &lt;em&gt;bleeding edge&lt;/em&gt;. Common sense applies. Since &lt;code&gt;direnv&lt;/code&gt; has been around for a while and it&amp;rsquo;s relatively popular, 150+ open issue seems acceptable to me.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now that &lt;code&gt;direnv&lt;/code&gt; passed the Litmus test for adoption&lt;sup id="fnref:1"&gt;&lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;, let&amp;rsquo;s get our hands dirty.&lt;/p&gt;
&lt;h2 id="installation"&gt;Installation&lt;/h2&gt;
&lt;p&gt;There&amp;rsquo;s nothing special here, as &lt;code&gt;direnv&lt;/code&gt; is widely packaged. Pick your poison:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ sudo pacman -Syu direnv # Arch Linux
$ doas apk add direnv # Alpine Linux
$ sudo apt install direnv # Debian-based distros&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Is it lightweight?&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ apk info -L direnv
direnv-2.30.1-r0 contains:
usr/bin/direnv&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Hell yes! More lightweight than that? Impossible. It&amp;rsquo;s a single binary thanks to Golang. No tons of files or dependencies. I mean:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ du -sh /usr/bin/direnv
7.5M /usr/bin/direnv&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;it&amp;rsquo;s a 7MB binary, let&amp;rsquo;s not get ahead of ourselves. But that&amp;rsquo;s fine, really, it&amp;rsquo;s just a dev tool, we don&amp;rsquo;t really deploy it to prod.&lt;/p&gt;
&lt;h2 id="use-cases"&gt;Use Cases&lt;/h2&gt;
&lt;p&gt;Everything is controlled with a &lt;code&gt;.envrc&lt;/code&gt; file within a repository root. A typical file could look like this:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;export HOUSE=&amp;#34;ATREIDES&amp;#34;
layout python3&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The &lt;a href="https://direnv.net/"&gt;upstream website&lt;/a&gt; does a great job at summarizing use cases. I am not here to duplicate documentation, so please go ahead and read it. That said, here are some example use cases I found useful:&lt;/p&gt;
&lt;h3 id="use-case-python"&gt;Use Case: Python&lt;/h3&gt;
&lt;p&gt;Python developers often need to create different virtual environments for different projects. For example, I was participating in &lt;a href="https://adventofcode.com/"&gt;Advent of Code&lt;/a&gt; last year and wrote my solutions in Python 3: &lt;a href="https://github.com/thiagowfx/adventofcode"&gt;https://github.com/thiagowfx/adventofcode&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Each day&lt;sup id="fnref:2"&gt;&lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/#fn:2" class="footnote-ref" role="doc-noteref"&gt;2&lt;/a&gt;&lt;/sup&gt; I would &lt;code&gt;cd ~/projects/adventofcode&lt;/code&gt;, and then do &lt;code&gt;source ~/.venv/bin/activate&lt;/code&gt;. And guess what, that&amp;rsquo;s for the first terminal where I&amp;rsquo;d run &lt;code&gt;make&lt;/code&gt;, I&amp;rsquo;d also spawn a second one with &lt;code&gt;vim&lt;/code&gt;, thereby needing to activate the virtual environment twice.&lt;/p&gt;
&lt;p&gt;And this is assuming the virtual environment already exists. If it didn&amp;rsquo;t ‚Äî for example, after a vanilla &lt;code&gt;git clone&lt;/code&gt;, I&amp;rsquo;d have to do &lt;code&gt;python -m venv .venv&lt;/code&gt; first.&lt;/p&gt;
&lt;p&gt;Quickly all of this became repetitive and annoying. I kinda &amp;ldquo;cheated&amp;rdquo; and stopped using the virtualenv for a few days, relying on my Linux distribution package manager instead:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% apk add py3-{autopep8,pyflakes,numpy,pylint}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;This way, my&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import numpy&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;would correctly work and not yell that &lt;code&gt;numpy&lt;/code&gt; was nowhere to be found.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s not very clean, but it worked. However eventually I wanted to become cleaner and leaner and automate my virtual environment setup. I uninstalled the aforementioned packages after a few days:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;% apk del py3-{autopep8,pyflakes,numpy,pylint}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;therefore forcing me to come up with a better setup. I always had direnv in my TODO list, and this was the perfect moment to try it out.&lt;/p&gt;
&lt;p&gt;How does &lt;code&gt;direnv&lt;/code&gt; address this?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add the &lt;code&gt;direnv&lt;/code&gt; hook to your shell. I actively use two shells&lt;sup id="fnref:3"&gt;&lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/#fn:3" class="footnote-ref" role="doc-noteref"&gt;3&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;bash&lt;/code&gt; and &lt;code&gt;zsh&lt;/code&gt;, so I did it twice and then added it to my &lt;a href="https://github.com/thiagowfx/.dotfiles"&gt;dotfiles&lt;/a&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Bash:&lt;/p&gt;
&lt;div class="codeblock" data-lang="bash"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;bash&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ cat ~/.bashrc.d/direnv.bash
#!/bin/bash
# https://direnv.net/
if hash direnv &amp;gt;/dev/null 2&amp;gt;&amp;amp;1; then
 eval &amp;#34;$(direnv hook bash)&amp;#34;
fi&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Zsh:&lt;/p&gt;
&lt;div class="codeblock" data-lang="zsh"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;zsh&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-zsh"&gt;$ cat ~/.zshrc.d/direnv.zsh
#!/bin/zsh
# https://direnv.net/
if (( $&amp;#43;commands[direnv] )); then
 eval &amp;#34;$(direnv hook zsh)&amp;#34;
fi&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ol start="2"&gt;
&lt;li&gt;Set up direnv in the AOC repository:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ cat ~/projects/adventofcode/.envrc
layout python3
$ direnv allow # Only needs to be done once&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;That&amp;rsquo;s it: It&amp;rsquo;s a single line of configuration. Now what does it do? All of the above. No magic: whenever you cd into the project directory or any of its subdirectories with one of the configured shells, if the venv doesn&amp;rsquo;t exist:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;it will be automatically created;&lt;/li&gt;
&lt;li&gt;then it will be sourced&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now you may ask yourself: Why go through all this trouble? Why not simply create a shell script to do exactly that for you automatically? That&amp;rsquo;s perfectly fine, it&amp;rsquo;s a matter of taste. But then you&amp;rsquo;ll have to maintain that script. The python ecosystem keeps changing ‚Äî a few years ago I was using &lt;code&gt;virtualenvwrapper&lt;/code&gt; to manage virtual environments, these days it doesn&amp;rsquo;t exist anymore, people use either &lt;code&gt;python -m env&lt;/code&gt; or &lt;code&gt;pyenv&lt;/code&gt; or &lt;code&gt;poetry&lt;/code&gt; or&amp;hellip;it never ends. &lt;a href="https://drewdevault.com/2021/11/16/Python-stop-screwing-distros-over.html"&gt;Drew DeVault&lt;/a&gt; wrote a good piece about that.&lt;/p&gt;
&lt;figure&gt;&lt;a href="https://xkcd.com/1987/"&gt;&lt;img src="https://imgs.xkcd.com/comics/python_environment.png"
 alt="The Python environmental protection agency wants to seal it in a cement chamber, with pictorial messages to future civilizations warning them about the danger of using sudo to install random Python packages."&gt;&lt;/a&gt;&lt;figcaption&gt;
 &lt;p&gt;XKCD Courtesy of Randall Munroe&lt;/p&gt;
 &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Maintenance is not the only burden, scalability is also one: If you use python in several repositories, you&amp;rsquo;ll now have to include your script in all of them.&lt;/p&gt;
&lt;p&gt;Considering that &lt;code&gt;direnv&lt;/code&gt; is flexible enough in other scenarios, I consider its adoption in this situation a good trade-off to make.&lt;/p&gt;
&lt;h3 id="use-case-hugo"&gt;Use Case: Hugo&lt;/h3&gt;
&lt;p&gt;This blog is written in Hugo. I have a &lt;code&gt;Makefile&lt;/code&gt; with a bunch of environment variables to manage its setup:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ make dev&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Whenever I am working in my VPS, for reasons outside of the scope of this post I need to use a different port other than the default one for Hugo (&lt;code&gt;1313&lt;/code&gt;). Since I am using variables, I could just do:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ make PORT=1234 dev&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;However, to make this change permanent (&amp;ldquo;fire-and-forget&amp;rdquo;), I could also do:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ echo &amp;#39;export PORT=1234&amp;#39; | tee -a .envrc
$ direnv allow # Only needs to be done once
$ make dev&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;This way, whenever I run &lt;code&gt;make&lt;/code&gt; I wouldn&amp;rsquo;t even need to think twice about which port to use.&lt;/p&gt;
&lt;p&gt;Of course, a small improvement that should be done in this scenario is to add &lt;code&gt;direnv&lt;/code&gt; related files to your &lt;code&gt;.gitignore&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;$ git ignore direnv &amp;gt;&amp;gt; .gitignore

# Created by https://www.toptal.com/developers/gitignore/api/direnv
# Edit at https://www.toptal.com/developers/gitignore?templates=direnv

### direnv ###
.direnv
.envrc

# End of https://www.toptal.com/developers/gitignore/api/direnv&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id="other-use-cases"&gt;Other use cases?&lt;/h3&gt;
&lt;p&gt;I don&amp;rsquo;t have other real use cases to share because only recently I became familiarized with &lt;code&gt;direnv&lt;/code&gt;. That said, the &lt;a href="https://direnv.net/man/direnv-stdlib.1.html"&gt;direnv docs&lt;/a&gt; are very comprehensive of its full potential usage.&lt;/p&gt;
&lt;p&gt;Some use cases that I like:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;dotenv&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Automatically sources &lt;code&gt;.env&lt;/code&gt; (note: not to confuse with &lt;code&gt;.envrc&lt;/code&gt;) files, which are widely common in projects managed with &lt;code&gt;docker-compose&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;source_env&lt;/code&gt; + &lt;code&gt;env_vars_required&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Alongside &lt;code&gt;.gitignore&lt;/code&gt;, this is a great way to source secrets (e.g. API keys or tokens) and not accidentally check them into your repository.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;fetchurl&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;&lt;code&gt;bash | curl&lt;/code&gt; is a cancer&lt;sup id="fnref:4"&gt;&lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/#fn:4" class="footnote-ref" role="doc-noteref"&gt;4&lt;/a&gt;&lt;/sup&gt; that should arguably be stopped due to its inherent security risks. That said, &lt;code&gt;direnv&lt;/code&gt; provides a safer way to work with it because you can specify a hash to ensure you&amp;rsquo;re downloading the same script ‚Äî if an attacker or malicious actor modified it, direnv would throw an error.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;path_add&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;If your project outputs to e.g. &lt;code&gt;build/&amp;lt;...&amp;gt;/bin&lt;/code&gt; or similar (typical in &lt;code&gt;cmake&lt;/code&gt; projects and AFAIK in Rust ones too), you could add that directory to your &lt;code&gt;PATH&lt;/code&gt; so that you could easily execute your binaries, without having to write the full subdirectory path each time.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;layout&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Besides python, &lt;code&gt;direnv&lt;/code&gt; supports several other programming languages out-of-the-box. Popular examples include &lt;code&gt;go&lt;/code&gt;, &lt;code&gt;nix&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt; and &lt;code&gt;ruby&lt;/code&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2 id="downsides"&gt;Downsides?&lt;/h2&gt;
&lt;p&gt;One could call &lt;code&gt;direnv&lt;/code&gt; bloated because of all of the aforementioned capabilities. If it doesn&amp;rsquo;t spark joy for your taste, consider using &lt;a href="https://github.com/hyperupcall/autoenv"&gt;autoenv&lt;/a&gt; which is basically a leaner version of &lt;code&gt;direnv&lt;/code&gt;, meant mostly for doing one thing and doing it well: setting and unsetting variables.&lt;/p&gt;
&lt;p&gt;Other than that, &lt;code&gt;direnv&lt;/code&gt; is pretty much a great piece of software.&lt;/p&gt;
&lt;p&gt;One thing I didn&amp;rsquo;t cover is how secure it is: You need to run &lt;code&gt;direnv allow&lt;/code&gt; explicitly in order to tell &lt;code&gt;direnv&lt;/code&gt; that you trust a given &lt;code&gt;.envrc&lt;/code&gt; file. If you don&amp;rsquo;t do it, &lt;code&gt;direnv&lt;/code&gt; will refuse to source it:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;$ touch .envrc
direnv: error ~/projects/foo/.envrc is blocked. Run `direnv allow` to approve its content&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;If you run &lt;code&gt;direnv allow&lt;/code&gt; but later on the file is modified (for example, after &lt;code&gt;git pull&lt;/code&gt;, whereby you retrieve a modification from a teammate), &lt;code&gt;direnv&lt;/code&gt; will once again refuse to operate. You&amp;rsquo;ll need to whitelist it again by re-running &lt;code&gt;direnv allow&lt;/code&gt;. Direnv will snapshot/hash the file contents of &lt;code&gt;.envrc&lt;/code&gt; remember it across sessions.&lt;/p&gt;
&lt;h2 id="references"&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://cuddly-octo-palm-tree.com/posts/2021-12-12-tyska-direnv/"&gt;Tools You Should Know About: direnv&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Obviously the aforementioned list was non-exhaustive. There are a few other questions that you may want to ask, out of scope of this article, such as: (i) does the project have an OSS or FLOSS license? (ii) does the project depend on Java?&amp;#160;&lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Advent of code challenges are released one by one, thereby forcing you to wait until the next day in order to get the next challenge.&amp;#160;&lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/#fnref:2" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;more on this another day&amp;#160;&lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/#fnref:3" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;c.f. &lt;a href="https://curlpipesh.tumblr.com/"&gt;https://curlpipesh.tumblr.com/&lt;/a&gt;, &lt;a href="https://gnu.moe/wallofshame.md"&gt;https://gnu.moe/wallofshame.md&lt;/a&gt;&amp;#160;&lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/#fnref:4" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Direnv: Automate your Environment Variables"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/advent-of-code/"&gt;#advent-of-code&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/bestof/"&gt;#bestof&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>