<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet type="text/xsl" href="https://perrotta.dev/rss.xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Terraform on ¬¨ just serendipity üçÄ</title><link>https://perrotta.dev/</link><description>Recent content in Terraform on ¬¨ just serendipity üçÄ</description><generator>Hugo</generator><language>en</language><managingEditor>serendipity@perrotta.dev (Thiago Perrotta)</managingEditor><webMaster>serendipity@perrotta.dev (Thiago Perrotta)</webMaster><copyright>¬© 2013 - 2026 Thiago Perrotta ¬∑
[some rights reserved](https://creativecommons.org/licenses/by-nc-sa/4.0/) ¬∑
a fork of [hugo  ï‚Ä¢·¥•‚Ä¢ î bear](https://github.com/janraasch/hugo-bearblog/)</copyright><lastBuildDate>Thu, 05 Feb 2026 12:56:39 +0100</lastBuildDate><atom:link href="https://perrotta.dev/tags/terraform/index.xml" rel="self" type="application/rss+xml"/><item><title>just apply it</title><link>https://perrotta.dev/2026/02/just-apply-it/</link><pubDate>Wed, 04 Feb 2026 11:08:58 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>dev</category><category>serenity</category><category>terraform</category><guid>https://perrotta.dev/2026/02/just-apply-it/</guid><description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Thiago&lt;/strong&gt;: now that your PR is merged, you can &lt;em&gt;just apply&lt;/em&gt; it&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Teammate&lt;/strong&gt;: ah never did that, what would I need to do?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Thiago&lt;/strong&gt;: &lt;code&gt;just apply github-{corp}-ai-resources&lt;/code&gt;&lt;sup id="fnref:1"&gt;&lt;a href="https://perrotta.dev/2026/02/just-apply-it/#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I love these accidental word puns (ft. &lt;a href="https://just.systems/"&gt;just&lt;/a&gt;).&lt;/p&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;In this context, &lt;code&gt;just apply&lt;/code&gt; is a wrapper of &lt;code&gt;terraform apply&lt;/code&gt;.&amp;#160;&lt;a href="https://perrotta.dev/2026/02/just-apply-it/#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: just apply it"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/serenity/"&gt;#serenity&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>terraform import arrays</title><link>https://perrotta.dev/2026/01/terraform-import-arrays/</link><pubDate>Sat, 24 Jan 2026 17:00:07 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2026/01/terraform-import-arrays/</guid><description>&lt;p&gt;Given an existing resource
&lt;code&gt;module.atlas_mongo_external.mongodbatlas_alert_configuration.maintenance_no_longer_needed[0]&lt;/code&gt;
to be imported into terraform state through an
&lt;a href="https://developer.hashicorp.com/terraform/language/v1.14.x/import/bulk?page=import&amp;amp;page=bulk"&gt;&lt;code&gt;imports.tf&lt;/code&gt;&lt;/a&gt;
file with &lt;a href="https://developer.hashicorp.com/terraform/language/import"&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;
blocks, a targeted imported can be performed like this:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;terraform apply -target=&amp;#39;module.atlas_mongo_external.mongodbatlas_alert_configuration.maintenance_no_longer_needed[0]&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Nothing special here.
The &amp;ldquo;TIL&amp;rdquo; bit of the day is that the array suffix &lt;code&gt;[0]&lt;/code&gt; is not needed:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;terraform apply -target=&amp;#39;module.atlas_mongo_external.mongodbatlas_alert_configuration.maintenance_no_longer_needed&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;works as well.&lt;/p&gt;
&lt;p&gt;It feels like a silly optimization to know about but, when you double-click the
resource name in most terminal emulators, only
&lt;code&gt;module.atlas_mongo_external.mongodbatlas_alert_configuration.maintenance_no_longer_needed&lt;/code&gt;
gets selected by default, stopping right before &lt;code&gt;[&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: terraform import arrays"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Terraformer</title><link>https://perrotta.dev/2025/11/terraformer/</link><pubDate>Wed, 19 Nov 2025 10:22:18 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>aws</category><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2025/11/terraformer/</guid><description>&lt;p&gt;&lt;a href="https://github.com/GoogleCloudPlatform/terraformer"&gt;terraformer&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CLI tool to generate terraform files from existing infrastructure (reverse
Terraform). Infrastructure to Code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In other words: &amp;ldquo;reverse terraform&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;I was quite excited to add this project to my tool belt, as it can save a lot of
time with scaffolding and &lt;code&gt;terraform import&lt;/code&gt; commands.&lt;/p&gt;
&lt;p&gt;Then &lt;a href="https://www.claude.com/product/claude-code"&gt;Claude Code&lt;/a&gt;, once again,
surprised me.&lt;/p&gt;
&lt;p&gt;It turns out there&amp;rsquo;s absolutely no need to adopt &lt;code&gt;terraformer&lt;/code&gt; if you have a
superb agent available and a few cents/dollars to spare.&lt;/p&gt;
&lt;p&gt;Claude can figure out which CLI arguments to pass to &lt;code&gt;aws&lt;/code&gt;, &lt;code&gt;az&lt;/code&gt;, etc. to list
all relevant cloud resources. Then it can generate / scaffold a basic set of
Terraform files to manage them&lt;sup id="fnref:1"&gt;&lt;a href="https://perrotta.dev/2025/11/terraformer/#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt;. And then it can craft an one-off shell or
python script to import them all in terraform.&lt;/p&gt;
&lt;p&gt;Easy. Quick. Painless.&lt;/p&gt;
&lt;p&gt;The interesting part is that I had initially asked Claude to explicitly use
&lt;em&gt;terraformer&lt;/em&gt; to do so, but it turned out to be more complicated / less
efficient than having the agent perform the task &lt;em&gt;directly&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;I am sorry if you were expecting a &lt;code&gt;terraformer&lt;/code&gt; tutorial.&lt;/p&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;You&amp;rsquo;ll need to refactor these later for maintainability.&amp;#160;&lt;a href="https://perrotta.dev/2025/11/terraformer/#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Terraformer"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/aws/"&gt;#aws&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>terraform: update outputs only</title><link>https://perrotta.dev/2025/11/terraform-update-outputs-only/</link><pubDate>Mon, 17 Nov 2025 12:04:26 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2025/11/terraform-update-outputs-only/</guid><description>&lt;p&gt;&lt;strong&gt;Problem statement&lt;/strong&gt;: Given a Terraform project full of pending changes
(&lt;code&gt;terraform plan&lt;/code&gt;), update its
&lt;a href="https://developer.hashicorp.com/terraform/cli/commands/output"&gt;outputs&lt;/a&gt; only.&lt;/p&gt;
&lt;p&gt;I would expect to be able to use &lt;code&gt;-target&lt;/code&gt; to do so, but that&amp;rsquo;s not possible.
This flag is intended for resources only.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://devops.stackexchange.com/questions/14286/terraform-apply-output-only"&gt;correct
approach&lt;/a&gt;
is &lt;code&gt;terraform apply -refresh-only&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Running terraform apply -refresh-only should take care of any new outputs. It
will read the latest data from each resource and then update all of the
outputs in terms of those updates, which includes re-evaluating your output
expressions to incorporate any changes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I tested this and it indeed works as expected.&lt;/p&gt;
&lt;p&gt;The next action from here would be to run &lt;code&gt;terraform apply&lt;/code&gt; for select &lt;code&gt;-target&lt;/code&gt;
resources, a few at a time, until drift is completely eliminated.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: terraform: update outputs only"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>terraform: bypass lock</title><link>https://perrotta.dev/2025/08/terraform-bypass-lock/</link><pubDate>Mon, 04 Aug 2025 11:49:16 +0200</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2025/08/terraform-bypass-lock/</guid><description>&lt;p&gt;Terraform supports &lt;a href="https://developer.hashicorp.com/terraform/language/state/locking"&gt;state
locking&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If supported by your backend, Terraform will lock your state for all
operations that could write state. This prevents others from acquiring the
lock and potentially corrupting your state.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Neat, right?&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% op run --env-file=.env -- terraform plan
‚ï∑
‚îÇ Error: Error acquiring the state lock
‚îÇ
‚îÇ Error message: operation error S3: PutObject, https response error
‚îÇ StatusCode: 412, RequestID: {redacted}, HostID:
‚îÇ {redacted},
‚îÇ api error PreconditionFailed: At least one of the pre-conditions you
‚îÇ specified did not hold
‚îÇ Lock Info:
‚îÇ ID: {redacted}
‚îÇ Path: {redacted}/chartmuseum.tfstate
‚îÇ Operation: OperationTypePlan
‚îÇ Who: {redacted}
‚îÇ Version: 1.10.5
‚îÇ Created: 2025-08-04 09:46:55.995791 &amp;#43;0000 UTC
‚îÇ Info:
‚îÇ
‚îÇ
‚îÇ Terraform acquires a state lock to protect the state from being written
‚îÇ by multiple users at the same time. Please resolve the issue above and try
‚îÇ again. For most commands, you can disable locking with the &amp;#34;-lock=false&amp;#34;
‚îÇ flag, but this is not recommended.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;It even uses a custom &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/412"&gt;HTTP
Status&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;The HTTP 412 Precondition Failed&lt;/strong&gt; &lt;em&gt;client error response status code&lt;/em&gt;
indicates that access to the target resource was denied. This happens with
conditional requests on methods other than GET or HEAD when the condition
defined by the If-Unmodified-Since or If-Match headers is not fulfilled. In
that case, the request (usually an upload or a modification of a resource)
cannot be made and this error response is sent back.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you&amp;rsquo;re sure no one else is working on that workspace, you can proceed with
&lt;code&gt;-lock=false&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% op run --env-file=.env -- terraform plan -lock=false
uptime_check_http.chartmuseum: Refreshing state... [name=chartmuseum]
data.aws_availability_zones.available: Reading...
data.aws_availability_zones.available: Read complete after 1s [id=us-east-1]
[...]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;That&amp;rsquo;s an one-off. A subsequent run without that argument will fail again:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% op run --env-file=.env -- terraform plan
‚ï∑
‚îÇ Error: Error acquiring the state lock
[...]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;In this case it would be better to simply remove the lock with
&lt;a href="https://developer.hashicorp.com/terraform/language/state/locking#force-unlock"&gt;&lt;code&gt;force-unlock&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% op run --env-file=.env -- terraform force-unlock {lock-id}
Do you really want to force-unlock?
 Terraform will remove the lock on the remote state.
 This will allow local Terraform commands to modify this state, even though it
 may still be in use. Only &amp;#39;yes&amp;#39; will be accepted to confirm.

 Enter a value: yes

Terraform state has been successfully unlocked!

The state has been unlocked, and Terraform commands should now be able to
obtain a new lock on the remote state.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;lock-id&lt;/code&gt; can be obtained from the &lt;code&gt;plan&lt;/code&gt; output.&lt;/p&gt;
&lt;p&gt;Now we can &lt;code&gt;plan&lt;/code&gt; as usual:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% op run --env-file=.env -- terraform plan
uptime_check_http.chartmuseum: Refreshing state... [name=chartmuseum]
data.aws_availability_zones.available: Reading...
data.aws_availability_zones.available: Read complete after 0s [id=us-east-1]
[...]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: terraform: bypass lock"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Terraform: rename resources</title><link>https://perrotta.dev/2025/03/terraform-rename-resources/</link><pubDate>Wed, 19 Mar 2025 11:40:43 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>aws</category><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2025/03/terraform-rename-resources/</guid><description>&lt;p&gt;Sometimes I need to make a simple refactoring rename change to a terraform
resource that has already been applied. For example:&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;resource &amp;#34;aws_api_gateway_request_validator&amp;#34; &amp;#34;delete&amp;#34; {
 name = &amp;#34;Validate body, query string parameters, and headers&amp;#34;
 rest_api_id = aws_api_gateway_rest_api.this.id
 validate_request_body = true
 validate_request_parameters = true
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;to&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;resource &amp;#34;aws_api_gateway_request_validator&amp;#34; &amp;#34;this&amp;#34; {
 name = &amp;#34;Validate body, query string parameters, and headers&amp;#34;
 rest_api_id = aws_api_gateway_rest_api.this.id
 validate_request_body = true
 validate_request_parameters = true
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The simplest way to do so is to &lt;code&gt;terraform apply&lt;/code&gt;. However, that incurs
destruction + re-creation of the resource, which would incur downtime in case
it&amp;rsquo;s already deployed in prod.&lt;/p&gt;
&lt;p&gt;The best way is &lt;code&gt;% terraform state mv aws_api_gateway_request_validator.{delete,this}&lt;/code&gt;. In-place move, simple and
easy.&lt;/p&gt;
&lt;p&gt;When doing it at scale, running multiple &lt;code&gt;terraform state mv&lt;/code&gt; commands could be
cumbersome.&lt;/p&gt;
&lt;p&gt;There&amp;rsquo;s a second way, using the
&lt;a href="https://developer.hashicorp.com/terraform/language/moved"&gt;&lt;code&gt;moved&lt;/code&gt;&lt;/a&gt; block in HCL:&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;moved {
 from = aws_api_gateway_request_validator.delete
 to = aws_api_gateway_request_validator.this
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;code&gt;terraform&lt;/code&gt; docs call this operation &amp;ldquo;move&amp;rdquo;, instead of &amp;ldquo;rename&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Terraform: rename resources"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/aws/"&gt;#aws&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Terraform: create zip files</title><link>https://perrotta.dev/2025/03/terraform-create-zip-files/</link><pubDate>Mon, 17 Mar 2025 21:06:28 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2025/03/terraform-create-zip-files/</guid><description>&lt;p&gt;When creating &lt;code&gt;.zip&lt;/code&gt; files with terraform, for example, with the purpose of
uploading them to an &lt;a href="https://aws.amazon.com/lambda/"&gt;AWS Lambda&lt;/a&gt;, at least two
approaches exist to do so.&lt;/p&gt;
&lt;p&gt;In the examples below, assume a NodeJS source file named &lt;code&gt;index.mjs&lt;/code&gt;. It should
be packaged into a &lt;code&gt;lambda.zip&lt;/code&gt; archive.&lt;/p&gt;
&lt;h2 id="1-use-null_resource"&gt;1) Use &lt;a href="https://registry.terraform.io/providers/hashicorp/null/latest/docs/resources/resource"&gt;&lt;code&gt;null_resource&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;resource &amp;#34;null_resource&amp;#34; &amp;#34;build_lambda&amp;#34; {
 triggers = {
 source_code_hash = filebase64sha256(&amp;#34;${path.module}/lambda/index.mjs&amp;#34;)
 }

 provisioner &amp;#34;local-exec&amp;#34; {
 command = &amp;lt;&amp;lt;EOF
 cd ${path.module}/lambda
 zip -r lambda.zip index.mjs
 EOF
 }
}

resource &amp;#34;aws_lambda_function&amp;#34; &amp;#34;this&amp;#34; {
 function_name = &amp;#34;dns-changer-delete&amp;#34;
 role = aws_iam_role.this.arn

 filename = &amp;#34;${path.module}/lambda/lambda.zip&amp;#34;
 source_code_hash = filebase64sha256(&amp;#34;${path.module}/lambda/lambda.zip&amp;#34;)
 handler = &amp;#34;index.handler&amp;#34;
 runtime = &amp;#34;nodejs22.x&amp;#34;

 depends_on = [null_resource.build_lambda]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id="2-use-archive_file"&gt;2) Use &lt;a href="https://registry.terraform.io/providers/hashicorp/archive/latest/docs/resources/file"&gt;&lt;code&gt;archive_file&lt;/code&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;data &amp;#34;archive_file&amp;#34; &amp;#34;lambda_zip&amp;#34; {
 type = &amp;#34;zip&amp;#34;
 source_file = &amp;#34;${path.module}/lambda/index.mjs&amp;#34;
 output_path = &amp;#34;${path.module}/lambda/lambda.zip&amp;#34;
}

resource &amp;#34;aws_lambda_function&amp;#34; &amp;#34;this&amp;#34; {
 function_name = &amp;#34;dns-changer-delete&amp;#34;
 description = &amp;#34;Delete DNS record sets for DNS Changer&amp;#34;
 role = aws_iam_role.this.arn

 filename = data.archive_file.lambda_zip.output_path
 source_code_hash = data.archive_file.lambda_zip.output_base64sha256
 handler = &amp;#34;index.handler&amp;#34;
 runtime = &amp;#34;nodejs22.x&amp;#34;

 depends_on = [data.archive_file.lambda_zip]
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;I prefer the second approach.&lt;/p&gt;
&lt;p&gt;Furthermore, it only requires one &lt;code&gt;terraform apply&lt;/code&gt; per file update, whereas
the first one requires two.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Terraform: create zip files"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Terraform: generate diagrams</title><link>https://perrotta.dev/2025/03/terraform-generate-diagrams/</link><pubDate>Mon, 17 Mar 2025 13:42:57 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2025/03/terraform-generate-diagrams/</guid><description>&lt;p&gt;There are a few options to visualize a &lt;code&gt;terraform&lt;/code&gt; module in the form of a graph
or diagram.&lt;/p&gt;
&lt;h2 id="terraform-graph-dot--graphviz"&gt;&lt;code&gt;terraform graph&lt;/code&gt;: dot / graphviz&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developer.hashicorp.com/terraform/cli/commands/graph"&gt;&lt;code&gt;terraform graph&lt;/code&gt;&lt;/a&gt; outputs a
&lt;a href="https://graphviz.org/doc/info/lang.html"&gt;DOT&lt;/a&gt; graph, which can be manipulated /
visualized with &lt;code&gt;graphviz&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;terraform graph | dot -Tpng &amp;gt; graph.png&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The graph can then be embedded into a markdown file:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;% cat README.md
![graph](graph.png)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id="terramaid-mermaid"&gt;&lt;code&gt;terramaid&lt;/code&gt;: mermaid&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://github.com/RoseSecurity/Terramaid"&gt;&lt;code&gt;terramaid&lt;/code&gt;&lt;/a&gt; project generates
&lt;a href="https://mermaid.js.org/"&gt;Mermaid&lt;/a&gt; diagrams from Terraform configurations:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;% brew install terramaid
% terramaid run --output README.md
Mermaid diagram successfully written to README.md&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The default filename is &lt;code&gt;Terramaid.md&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Why use Mermaid? It was previously covered &lt;a href="https://perrotta.dev/2024/10/mermaid-rich-diagrams-in-markdown/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;: Mermaid has native integration with
&lt;a href="https://github.blog/developer-skills/github/include-diagrams-markdown-files-mermaid/"&gt;GitHub&lt;/a&gt;
and &lt;a href="https://docs.gitlab.com/ee/user/markdown.html#mermaid"&gt;GitLab&lt;/a&gt;, and that&amp;rsquo;s
hard to beat. Graphviz, sadly, &lt;a href="https://forum.graphviz.org/t/github-adding-support-for-mermaid-diagrams/998"&gt;does
not&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Terraform: generate diagrams"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Terraform: AWS deployment to random availability zones</title><link>https://perrotta.dev/2024/05/terraform-aws-deployment-to-random-availability-zones/</link><pubDate>Tue, 21 May 2024 14:31:03 +0200</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>aws</category><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2024/05/terraform-aws-deployment-to-random-availability-zones/</guid><description>&lt;p&gt;A common scenario: there&amp;rsquo;s a new deployment you would like to roll out to AWS.
Let&amp;rsquo;s say you pick &amp;ldquo;us-east-1&amp;rdquo; as your cloud region. There are multiple
availability zones within it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;us-east-1a&lt;/li&gt;
&lt;li&gt;us-east-1b&lt;/li&gt;
&lt;li&gt;us-east-1c&lt;/li&gt;
&lt;li&gt;us-east-1d&lt;/li&gt;
&lt;li&gt;us-east-1e&lt;/li&gt;
&lt;li&gt;us-east-1f&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Suppose you want to pick two of them for your service/app, and you don&amp;rsquo;t
particularly care about which one. How to proceed?&lt;/p&gt;
&lt;h2 id="option-1-hard-coding"&gt;Option #1: Hard-coding&lt;/h2&gt;
&lt;p&gt;Pick two arbitrary zones and hard-code them.&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;variable &amp;#34;availability_zones&amp;#34; {
 type = list(string)
 default = [&amp;#34;us-east-1a&amp;#34;, &amp;#34;us-east-1b&amp;#34;]
}

resource &amp;#34;aws_subnet&amp;#34; &amp;#34;private&amp;#34; {
 vpc_id = aws_vpc.chartmuseum.id
 cidr_block = element(var.private_subnets, count.index)
 availability_zone = element(var.availability_zones, count.index)
 count = length(var.private_subnets)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Caveat&lt;/strong&gt;: &lt;a href="https://www.goodreads.com/book/show/10639.The_Paradox_of_Choice"&gt;The paradox of
choice&lt;/a&gt;,
unnecessary decision fatigue.&lt;/p&gt;
&lt;h2 id="option-2-pick-the-first-two"&gt;Option #2: Pick the first two&lt;/h2&gt;
&lt;p&gt;Use the AWS data source to dynamically find all zones, and pick the first two.&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;data &amp;#34;aws_availability_zones&amp;#34; &amp;#34;available&amp;#34; {
 state = &amp;#34;available&amp;#34;
}

resource &amp;#34;aws_subnet&amp;#34; &amp;#34;private&amp;#34; {
 vpc_id = aws_vpc.chartmuseum.id
 cidr_block = element(var.private_subnets, count.index)
 availability_zone = element(data.aws_availability_zones.available.names, count.index)
 count = length(var.private_subnets)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;terraform plan&lt;/code&gt; should display the full zone list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Caveat&lt;/strong&gt;: Heavily biased towards the first two zones.&lt;/p&gt;
&lt;h2 id="option-3-random-shuffling"&gt;Option #3: Random shuffling&lt;/h2&gt;
&lt;p&gt;Pick two zones at random!&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;data &amp;#34;aws_availability_zones&amp;#34; &amp;#34;available&amp;#34; {
 state = &amp;#34;available&amp;#34;
}

resource &amp;#34;random_shuffle&amp;#34; &amp;#34;aws_availability_zone_names&amp;#34; {
 input = data.aws_availability_zones.available.names
 result_count = 2
}

resource &amp;#34;aws_subnet&amp;#34; &amp;#34;private&amp;#34; {
 vpc_id = aws_vpc.chartmuseum.id
 cidr_block = element(var.private_subnets, count.index)
 availability_zone = element(random_shuffle.aws_availability_zone_names.result, count.index)
 count = length(var.private_subnets)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Winner&lt;/strong&gt;: In my opinion, this is the most elegant approach.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;random_shuffle&lt;/code&gt; will output the selected regions upon running &lt;code&gt;terraform apply&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Terraform: AWS deployment to random availability zones"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/aws/"&gt;#aws&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>‚òÖ Integrating terraform with ansible</title><link>https://perrotta.dev/2024/02/integrating-terraform-with-ansible/</link><pubDate>Thu, 01 Feb 2024 14:02:28 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>bestof</category><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2024/02/integrating-terraform-with-ansible/</guid><description>&lt;p&gt;This post is a follow-up of &lt;a href="https://perrotta.dev/2024/01/terraforming-a-linode-hello-world/"&gt;Terraforming a Linode: hello world&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In a future post, we will continue from here by using Ansible to install and
set up Miniflux in our new Linode.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Before we extensively use Ansible to configure our VPS instance, first let&amp;rsquo;s
set up a basic integration between Terraform and Ansible.&lt;/p&gt;
&lt;p&gt;First of all, here&amp;rsquo;s an overview of where I stopped last time. There were a
couple of lightweight modifications since then. I&amp;rsquo;ll explain some of them
below.&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;% cat variables.tf
variable &amp;#34;github_username&amp;#34; {
 type = string
 default = &amp;#34;thiagowfx&amp;#34;
}

variable &amp;#34;linode_hostname&amp;#34; {
 type = string
 default = &amp;#34;coruscant&amp;#34;
}

variable &amp;#34;linode_region&amp;#34; {
 type = string
 default = &amp;#34;eu-central&amp;#34;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;All variables were moved to a &lt;code&gt;variables.tf&lt;/code&gt; file. This is to follow standard
terraform
&lt;a href="https://developer.hashicorp.com/terraform/language/modules/develop/structure"&gt;conventions&lt;/a&gt;
/ recommendations for module structures. Furthermore, it becomes easier to
manage variables when they are all stored in a single place.&lt;/p&gt;
&lt;p&gt;The main module file now looks like this:&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;% cat main.tf
terraform {
 required_providers {
 http = {
 source = &amp;#34;hashicorp/http&amp;#34;
 }
 linode = {
 source = &amp;#34;linode/linode&amp;#34;
 }
 }
}

provider &amp;#34;linode&amp;#34; {}

data &amp;#34;http&amp;#34; &amp;#34;github_keys&amp;#34; {
 url = &amp;#34;https://api.github.com/users/${var.github_username}/keys&amp;#34;
}

locals {
 keys = jsondecode(data.http.github_keys.response_body)[*].key
}

resource &amp;#34;linode_instance&amp;#34; &amp;#34;nanode&amp;#34; {
 type = &amp;#34;g6-nanode-1&amp;#34;
 image = &amp;#34;linode/alpine3.19&amp;#34;
 label = var.linode_hostname
 region = var.linode_region
 authorized_keys = local.keys
 backups_enabled = &amp;#34;false&amp;#34;
 booted = &amp;#34;true&amp;#34;
 watchdog_enabled = &amp;#34;true&amp;#34;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;I removed the token from the linode provider. Now it is supplied via the
&lt;code&gt;LINODE_TOKEN&lt;/code&gt; environment variable. In order to automatically populate that
variable, I use &lt;a href="https://perrotta.dev/2022/01/direnv-automate-your-environment-variables/"&gt;&lt;code&gt;direnv&lt;/code&gt;&lt;/a&gt;. There&amp;rsquo;s an &lt;code&gt;.envrc&lt;/code&gt; file that provides its value, like so:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;#!/bin/sh
# terraform init

export LINODE_TOKEN=&amp;#34;my-token-here&amp;#34;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;I also created a repository for this project:
&lt;a href="https://github.com/thiagowfx/knol"&gt;https://github.com/thiagowfx/knol&lt;/a&gt;. That&amp;rsquo;s enough for preliminaries, now let&amp;rsquo;s
go back to Ansible.&lt;/p&gt;
&lt;p&gt;The first component we&amp;rsquo;ll need is an Ansible
&lt;a href="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html"&gt;inventory&lt;/a&gt;
file, containing the IP address of the host we&amp;rsquo;ll manage. It could look like
this:&lt;/p&gt;
&lt;div class="codeblock" data-lang="ini"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;ini&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-ini"&gt;[all]
1.2.3.4 ansible_user=root&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;hellip;wherein &lt;code&gt;1.2.3.4&lt;/code&gt; is the IP address of our VPS.&lt;/p&gt;
&lt;p&gt;That said, due to the fact the VPS instance is created dynamically, maintaining
that IP address manually would be tedious. Therefore, let&amp;rsquo;s have Terraform
manage it.&lt;/p&gt;
&lt;p&gt;We can do so with a
&lt;a href="https://registry.terraform.io/providers/hashicorp/local/latest/docs/resources/file"&gt;&lt;code&gt;local_file&lt;/code&gt;&lt;/a&gt;.
Heck, we could even use a
&lt;a href="https://registry.terraform.io/providers/hashicorp/template/latest/docs/data-sources/file"&gt;&lt;code&gt;template_file&lt;/code&gt;&lt;/a&gt;,
however it would be overkill as there are only two simple lines in our
inventory at this point. A &lt;code&gt;local_file&lt;/code&gt; is created upon &lt;code&gt;terraform apply&lt;/code&gt; and
deleted upon &lt;code&gt;terraform destroy&lt;/code&gt;. Therefore it doesn&amp;rsquo;t even need to be tracked
by our VCS:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;resource &amp;#34;local_file&amp;#34; &amp;#34;ansible_inventory&amp;#34; {
 content = &amp;lt;&amp;lt;-EOF
[all]
${linode_instance.nanode.ip_address} ansible_user=root
EOF
 filename = &amp;#34;inventory.ini&amp;#34;
 file_permission = &amp;#34;0644&amp;#34;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Once we run terraform (plan + apply), an &lt;code&gt;inventory.ini&lt;/code&gt; file should be created
with the above contents.&lt;/p&gt;
&lt;p&gt;Because the IP address is ephemeral and dynamic, we should have a
straightforward way to see its value. A terraform
&lt;a href="https://developer.hashicorp.com/terraform/language/values/outputs"&gt;&lt;code&gt;output&lt;/code&gt;&lt;/a&gt;
is perfect for that:&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;% cat outputs.tf
output &amp;#34;ip_address&amp;#34; {
 value = linode_instance.nanode.ip_address
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Later on (after terraforming) we will be able to use &lt;code&gt;terraform output&lt;/code&gt; to see
the server IP address.&lt;/p&gt;
&lt;p&gt;We have the inventory file. Now we need a
&lt;a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_intro.html"&gt;playbook&lt;/a&gt;.
A playbook contains a sequence of tasks to be applied to our server.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with a basic playbook that just installs and starts &lt;code&gt;nginx&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="yaml"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;yaml&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-yaml"&gt;---
- hosts: all
 tasks:
 - name: Install the web server (nginx)
 community.general.apk:
 name: nginx
 state: present
 - name: Start the web server
 service:
 name: nginx
 state: started&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Save this to a &lt;code&gt;playbook.yml&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;After terraforming, we should now be able to run ansible:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% ansible-playbook -i inventory.ini playbook.yml&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;In order to make this setup more ergonomic, let&amp;rsquo;s create a &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="makefile"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;makefile&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-makefile"&gt;TERRAFORM := terraform

all: terraform ansible

ansible:
	ansible-playbook -i inventory.ini playbook.yml

terraform:
	$(TERRAFORM) init
	$(TERRAFORM) plan
	$(TERRAFORM) apply

clean:
	$(TERRAFORM) destroy

.PHONY: all ansible terraform clean&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Then we can just run &lt;code&gt;make terraform&lt;/code&gt; or &lt;code&gt;make ansible&lt;/code&gt; for granular steps. Or
just &lt;code&gt;make&lt;/code&gt; to run everything in the right order.&lt;/p&gt;
&lt;p&gt;I extracted the &lt;code&gt;terraform&lt;/code&gt; binary to its own variable because it facilitates
the use of &lt;a href="https://opentofu.org/"&gt;OpenTofu&lt;/a&gt; (a fork) in lieu of terraform.&lt;/p&gt;
&lt;p&gt;And that&amp;rsquo;s it for today! In a future post, we&amp;rsquo;ll look into extending our
Ansible usage to fully bootstrap Miniflux on the server.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Integrating terraform with ansible"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bestof/"&gt;#bestof&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item><item><title>‚òÖ Terraforming a Linode: hello world</title><link>https://perrotta.dev/2024/01/terraforming-a-linode-hello-world/</link><pubDate>Tue, 23 Jan 2024 23:27:04 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>alpine-linux</category><category>bestof</category><category>dev</category><category>terraform</category><guid>https://perrotta.dev/2024/01/terraforming-a-linode-hello-world/</guid><description>&lt;p&gt;I host my own &lt;a href="https://miniflux.app/"&gt;Miniflux&lt;/a&gt; instance, which happens to be
my favorite RSS reader. Currently it is hosted on Linode (Akamai Cloud)
running &lt;a href="https://www.alpinelinux.org/"&gt;Alpine Linux&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;My current setup was performed manually. I was thinking that, for fun, it would
be cool to fully automate it under the principles of
&lt;a href="https://en.wikipedia.org/wiki/Infrastructure_as_code"&gt;IaC&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The current setup does not use any containers. I had proudly made it as KISS as
possible at the time:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Linode is a very beginner-friendly (and cheap) VPS&lt;/li&gt;
&lt;li&gt;Alpine Linux is a first-class citizen on Linode&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s an &lt;code&gt;apk&lt;/code&gt; &lt;a href="https://pkgs.alpinelinux.org/packages?name=miniflux"&gt;package&lt;/a&gt; for &lt;code&gt;miniflux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;There&amp;rsquo;s an OpenRC&lt;sup id="fnref:1"&gt;&lt;a href="https://perrotta.dev/2024/01/terraforming-a-linode-hello-world/#fn:1" class="footnote-ref" role="doc-noteref"&gt;1&lt;/a&gt;&lt;/sup&gt; script for &lt;code&gt;miniflux&lt;/code&gt; (so that it can be controlled via &lt;code&gt;service&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For the first part of this automation we will look into provisioning a Linode
with an Alpine Linux installation. In order to do so we will use HashiCorp
&lt;a href="https://www.terraform.io/"&gt;Terraform&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="requirements"&gt;Requirements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Provision a new Linode&lt;/li&gt;
&lt;li&gt;Deploy it in Europe&lt;/li&gt;
&lt;li&gt;Use the smallest shape (a so-called &lt;a href="https://www.linode.com/community/questions/211/what-is-a-nanode"&gt;Nanode&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Run Alpine Linux&lt;/li&gt;
&lt;li&gt;Set it up with my &lt;a href="https://github.com/thiagowfx.keys"&gt;public ssh key&lt;/a&gt;, which is hosted on Github&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="terraform-setup"&gt;Terraform setup&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Install a provider for Linode: &lt;a href="https://registry.terraform.io/providers/linode/linode/latest/docs"&gt;https://registry.terraform.io/providers/linode/linode/latest/docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scaffold it like this, in a &lt;code&gt;main.tf&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;terraform {
 required_providers {
 linode = {
 source = &amp;#34;linode/linode&amp;#34;
 }
 }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Then run:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% terraform init&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Generate a Linode API token&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go to &lt;a href="https://cloud.linode.com/profile/tokens"&gt;https://cloud.linode.com/profile/tokens&lt;/a&gt;, create a new token called
&lt;code&gt;terraform&lt;/code&gt;. with the &amp;ldquo;Linodes&amp;rdquo; scope set to &amp;ldquo;Read/Write&amp;rdquo;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Append this API token to &lt;code&gt;main.tf&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;provider &amp;#34;linode&amp;#34; {
 token = &amp;#34;&amp;lt;your token here&amp;gt;&amp;#34;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Add a
&lt;a href="https://registry.terraform.io/providers/linode/linode/latest/docs/resources/instance"&gt;&lt;code&gt;linode_instance&lt;/code&gt;&lt;/a&gt;
with the appropriate fields set according to the documentation:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;resource &amp;#34;linode_instance&amp;#34; &amp;#34;coruscant&amp;#34; {
 label = &amp;#34;coruscant&amp;#34;
 image = &amp;#34;linode/alpine3.19&amp;#34;
 region = &amp;#34;eu-central&amp;#34;
 type = &amp;#34;g6-nanode-1&amp;#34;
 authorized_keys = [&amp;#34;&amp;lt;your ssh public key here&amp;gt;&amp;#34;]
 backups_enabled = &amp;#34;false&amp;#34;
 watchdog_enabled = &amp;#34;true&amp;#34;
 booted = &amp;#34;true&amp;#34;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Then run:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% terraform plan&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;ldquo;Plan&amp;rdquo; is basically a dry-run. Terraform will output what it intends to do, but nothing will be done yet.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Analyze the output and double check that it looks correct.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To actually perform the provisioning, run:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% terraform apply&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Then confirm the prompt.&lt;/p&gt;
&lt;p&gt;Within a few seconds (or maybe minutes), you should see your new Linode in the
&lt;a href="https://cloud.linode.com/"&gt;Linode Console&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We can test our deployment by ssh&amp;rsquo;ing to our new machine:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% ssh root@&amp;lt;public IP address&amp;gt; -i ~/.ssh/my_ssh_key
Welcome to Alpine!

The Alpine Wiki contains a large amount of how-to guides and general
information about administrating Alpine systems.
See &amp;lt;https://wiki.alpinelinux.org/&amp;gt;.

You can setup the system with the command: setup-alpine

You may change this message by editing /etc/motd.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Let&amp;rsquo;s take a pause to appreciate how lightweight it is:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;localhost:~# df -h
Filesystem Size Used Available Use% Mounted on
devtmpfs 10.0M 0 10.0M 0% /dev
shm 487.8M 0 487.8M 0% /dev/shm
/dev/sda 24.1G 238.1M 22.6G 1% /
tmpfs 195.1M 268.0K 194.8M 0% /run&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Only 238 MiB!&lt;/p&gt;
&lt;p&gt;To deprovision it, run:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% terraform plan -destroy&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;If everything looks correct, run:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% terraform destroy&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: It turns out the &amp;ldquo;Linodes&amp;rdquo; scope was not enough to do the
deprovisioning. I needed to create a new scope, with more permissions, in order
to do so.&lt;/p&gt;
&lt;p&gt;As you can see, terraform makes it very trivial to deprovision systems.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bonus points&lt;/strong&gt;: run &lt;code&gt;terraform fmt&lt;/code&gt; to format your file. Never go &lt;a href="https://www.youtube.com/watch?v=-CmadmM5cOk"&gt;out of
style&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;: At any point you can run &lt;code&gt;terraform validate&lt;/code&gt; to verify your &lt;code&gt;main.tf&lt;/code&gt;
file is syntactically correct.&lt;/p&gt;
&lt;p&gt;Two things could be improved in the previous setup:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We could use &lt;code&gt;authorized_users&lt;/code&gt; to pass in our linode username. If we add an
SSH key to our linode account, then that key would be automatically deployed
to the system, thereby removing the need to specify &lt;code&gt;authorized_keys&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Alternatively, we could fetch our key from an URL endpoint with the use of
the &lt;code&gt;hashicorp/http&lt;/code&gt; provider, like so:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;terraform {
 required_providers {
 http = {
 source = &amp;#34;hashicorp/http&amp;#34;
 }
 }
}

data &amp;#34;http&amp;#34; &amp;#34;thiagowfx_ssh_keys&amp;#34; {
 url = &amp;#34;https://github.com/thiagowfx.keys&amp;#34;
}

resource &amp;#34;linode_instance&amp;#34; &amp;#34;coruscant&amp;#34; {
 # ...
 authorized_keys = compact([for line in split(&amp;#34;\n&amp;#34;, data.http.thiagowfx_ssh_keys.response_body) : chomp(line)])
 # ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The &amp;ldquo;list comprehension&amp;rdquo; above does line splitting magic to convert them to a
list of string, and the &lt;code&gt;compact&lt;/code&gt; removes the empty new line at the end.&lt;/p&gt;
&lt;p&gt;We could improve the example above even further.&lt;/p&gt;
&lt;p&gt;For starters, let&amp;rsquo;s parameterize out the username to a variable:&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;variable &amp;#34;github_username&amp;#34; {
 type = string
 default = &amp;#34;thiagowfx&amp;#34;
}

data &amp;#34;http&amp;#34; &amp;#34;user_ssh_keys&amp;#34; {
 url = &amp;#34;https://github.com/${var.github_username}.keys&amp;#34;
}

resource &amp;#34;linode_instance&amp;#34; &amp;#34;coruscant&amp;#34; {
 # ...
 authorized_keys = compact([for line in split(&amp;#34;\n&amp;#34;, data.http.user_ssh_keys.response_body) : chomp(line)])
 # ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;We could then easily supply another username with &lt;code&gt;-var&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;% terraform plan -var github_username=torvalds&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Note that the above example leverages &lt;a href="https://developer.hashicorp.com/terraform/language/expressions/strings"&gt;string interpolation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We could also extract the SSH keys list to its own &amp;ldquo;variable&amp;rdquo; (&lt;a href="https://developer.hashicorp.com/terraform/language/values/locals"&gt;locals&lt;/a&gt;):&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;locals {
 ssh_keys = compact([for line in split(&amp;#34;\n&amp;#34;, data.http.user_ssh_keys.response_body) : chomp(line)])
}

resource &amp;#34;linode_instance&amp;#34; &amp;#34;coruscant&amp;#34; {
 # ...
 authorized_keys = local.ssh_keys
 # ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;A more robust (and stable) way to query the key though is through the Github API:&lt;/p&gt;
&lt;div class="codeblock" data-lang="terraform"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;terraform&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-terraform"&gt;data &amp;#34;http&amp;#34; &amp;#34;github_keys&amp;#34; {
 url = &amp;#34;https://api.github.com/users/${var.github_username}/keys&amp;#34;
}

locals {
 ssh_keys = jsondecode(data.http.github_keys.response_body)[*].key
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Note that a typical response body looks like the following:&lt;/p&gt;
&lt;div class="codeblock" data-lang="json"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;json&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-json"&gt;[
 {
 &amp;#34;id&amp;#34;: &amp;#34;&amp;lt;id&amp;gt;&amp;#34;,
 &amp;#34;key&amp;#34;: &amp;#34;&amp;lt;ssh key&amp;gt;&amp;#34;
 }
]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;API endpoint documentation:
&lt;a href="https://docs.github.com/en/rest/users/keys?apiVersion=2022-11-28#list-public-keys-for-a-user"&gt;https://docs.github.com/en/rest/users/keys?apiVersion=2022-11-28#list-public-keys-for-a-user&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If we use &lt;code&gt;output&lt;/code&gt; instead of &lt;code&gt;locals&lt;/code&gt;, then we can debug (inspect) it with
&lt;code&gt;terraform output&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And that&amp;rsquo;s it for today! In a future post, we will continue from here by using
&lt;a href="https://www.ansible.com/"&gt;Ansible&lt;/a&gt; to install and set up Miniflux in our new
Linode.&lt;/p&gt;
&lt;div class="footnotes" role="doc-endnotes"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Alpine Linux does not use &lt;code&gt;systemd&lt;/code&gt;.&amp;#160;&lt;a href="https://perrotta.dev/2024/01/terraforming-a-linode-hello-world/#fnref:1" class="footnote-backref" role="doc-backlink"&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: Terraforming a Linode: hello world"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/alpine-linux/"&gt;#alpine-linux&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/bestof/"&gt;#bestof&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/terraform/"&gt;#terraform&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>