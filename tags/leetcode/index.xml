<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet type="text/xsl" href="https://perrotta.dev/rss.xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Leetcode on ¬¨ just serendipity üçÄ</title><link>https://perrotta.dev/</link><description>Recent content in Leetcode on ¬¨ just serendipity üçÄ</description><generator>Hugo</generator><language>en</language><managingEditor>serendipity@perrotta.dev (Thiago Perrotta)</managingEditor><webMaster>serendipity@perrotta.dev (Thiago Perrotta)</webMaster><copyright>¬© 2013 - 2026 Thiago Perrotta ¬∑
[some rights reserved](https://creativecommons.org/licenses/by-nc-sa/4.0/) ¬∑
a fork of [hugo  ï‚Ä¢·¥•‚Ä¢ î bear](https://github.com/janraasch/hugo-bearblog/)</copyright><lastBuildDate>Mon, 23 Feb 2026 01:25:48 +0100</lastBuildDate><atom:link href="https://perrotta.dev/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>LeetCode #379: Design Phone Directory</title><link>https://perrotta.dev/2026/02/leetcode-%23379-design-phone-directory/</link><pubDate>Mon, 23 Feb 2026 01:25:36 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/02/leetcode-%23379-design-phone-directory/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-phone-directory"&gt;LeetCode #379: Design Phone Directory&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class PhoneDirectory:

 def __init__(self, maxNumbers: int):
 self.available = set(range(maxNumbers))

 def get(self) -&amp;gt; int:
 if not self.available:
 return -1

 return self.available.pop()


 def check(self, number: int) -&amp;gt; bool:
 return number in self.available


 def release(self, number: int) -&amp;gt; None:
 self.available.add(number)


# Your PhoneDirectory object will be instantiated and called as such:
# obj = PhoneDirectory(maxNumbers)
# param_1 = obj.get()
# param_2 = obj.check(number)
# obj.release(number)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #379: Design Phone Directory"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #2166: Design Bitset</title><link>https://perrotta.dev/2026/01/leetcode-%232166-design-bitset/</link><pubDate>Tue, 20 Jan 2026 22:20:59 +0100</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%232166-design-bitset/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-bitset"&gt;LeetCode #2166: Design Bitset&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Time limit exceeded:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Bitset:

 def __init__(self, size: int):
 self.bits = [False] * size


 def fix(self, idx: int) -&amp;gt; None:
 self.bits[idx] = 1


 def unfix(self, idx: int) -&amp;gt; None:
 self.bits[idx] = 0


 def flip(self) -&amp;gt; None:
 self.bits = [not bit for bit in self.bits]


 def all(self) -&amp;gt; bool:
 return all(self.bits)


 def one(self) -&amp;gt; bool:
 return any(self.bits)


 def count(self) -&amp;gt; int:
 return len([bit for bit in self.bits if bit])


 def toString(self) -&amp;gt; str:
 return &amp;#39;&amp;#39;.join(&amp;#39;1&amp;#39; if bit else &amp;#39;0&amp;#39; for bit in self.bits)



# Your Bitset object will be instantiated and called as such:
# obj = Bitset(size)
# obj.fix(idx)
# obj.unfix(idx)
# obj.flip()
# param_4 = obj.all()
# param_5 = obj.one()
# param_6 = obj.count()
# param_7 = obj.toString()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Optimized:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Bitset:

 def __init__(self, size: int):
 self.bits = [False] * size
 self.ones = 0
 self.flipped = False


 def fix(self, idx: int) -&amp;gt; None:
 if self.flipped:
 # When flipped, fixing means setting underlying bit to 0
 if self.bits[idx]:
 self.bits[idx] = False
 self.ones -= 1
 else:
 # Normal case: set to 1
 if not self.bits[idx]:
 self.bits[idx] = True
 self.ones &amp;#43;= 1


 def unfix(self, idx: int) -&amp;gt; None:
 if self.flipped:
 # When flipped, unfixing means setting underlying bit to 1
 if not self.bits[idx]:
 self.bits[idx] = True
 self.ones &amp;#43;= 1
 else:
 # Normal case: set to 0
 if self.bits[idx]:
 self.bits[idx] = False
 self.ones -= 1


 def flip(self) -&amp;gt; None:
 self.flipped = not self.flipped


 def all(self) -&amp;gt; bool:
 if self.flipped:
 return self.ones == 0
 else:
 return self.ones == len(self.bits)


 def one(self) -&amp;gt; bool:
 if self.flipped:
 # When flipped, we need at least one 0 in underlying array (which becomes 1)
 return self.ones &amp;lt; len(self.bits)
 else:
 return self.ones &amp;gt; 0


 def count(self) -&amp;gt; int:
 if self.flipped:
 return len(self.bits) - self.ones
 else:
 return self.ones


 def toString(self) -&amp;gt; str:
 if self.flipped:
 return &amp;#39;&amp;#39;.join(&amp;#39;0&amp;#39; if bit else &amp;#39;1&amp;#39; for bit in self.bits)
 else:
 return &amp;#39;&amp;#39;.join(&amp;#39;1&amp;#39; if bit else &amp;#39;0&amp;#39; for bit in self.bits)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #2166: Design Bitset"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1047: Remove All Adjacent Duplicates In String</title><link>https://perrotta.dev/2026/01/leetcode-%231047-remove-all-adjacent-duplicates-in-string/</link><pubDate>Sun, 18 Jan 2026 13:37:46 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231047-remove-all-adjacent-duplicates-in-string/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string"&gt;LeetCode #1047: Remove All Adjacent Duplicates In String&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Initial:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def removeDuplicates(self, s: str) -&amp;gt; str:
 stack = []
 ans = []

 for c in s:
 if not stack:
 stack.append(c)
 ans.append(c)
 else:
 if stack[-1] != c:
 stack.append(c)
 ans.append(c)
 else:
 stack.pop()
 ans.pop()

 return &amp;#39;&amp;#39;.join(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Optimized:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def removeDuplicates(self, s: str) -&amp;gt; str:
 stack = []
 ans = []

 for c in s:
 if not stack or stack[-1] != c:
 stack.append(c)
 ans.append(c)
 else:
 stack.pop()
 ans.pop()

 return &amp;#39;&amp;#39;.join(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1047: Remove All Adjacent Duplicates In String"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #380: Insert Delete GetRandom O(1)</title><link>https://perrotta.dev/2026/01/leetcode-%23380-insert-delete-getrandom-o1/</link><pubDate>Sun, 18 Jan 2026 02:54:25 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23380-insert-delete-getrandom-o1/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/insert-delete-getrandom-o%281%29"&gt;LeetCode #380: Insert Delete GetRandom O(1)&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Initial solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import random

class RandomizedSet:

 def __init__(self):
 self.l = []

 self.d = {}
 ## self.d = dict()

 def insert(self, val: int) -&amp;gt; bool:
 if val not in self.d:
 self.d[val] = len(self.l)
 self.l.append(val)
 return True

 return False


 def remove(self, val: int) -&amp;gt; bool:
 if val in self.d:
 del self.d[val]
 ## self.l: do not touch. Removal is O(n)
 return True

 return False


 def getRandom(self) -&amp;gt; int:
 return random.choice(list(self.d.keys()))


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;However, &lt;code&gt;getRandom()&lt;/code&gt; is &lt;code&gt;O(n)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Better solution:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import random

class RandomizedSet:

 def __init__(self):
 self.l = []

 self.d = {}
 ## self.d = dict()

 def insert(self, val: int) -&amp;gt; bool:
 if val not in self.d:
 self.d[val] = len(self.l)
 self.l.append(val)
 return True

 return False


 def remove(self, val: int) -&amp;gt; bool:
 if val in self.d:
 i = self.d[val]
 del self.d[val]

 del self.l[i]
 return True

 return False


 def getRandom(self) -&amp;gt; int:
 return random.choice(self.l)


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;But it&amp;rsquo;s still &lt;code&gt;O(n)&lt;/code&gt; because of the list deletion.&lt;/p&gt;
&lt;p&gt;Even better:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import random

class RandomizedSet:

 def __init__(self):
 self.l = []

 self.d = {}
 ## self.d = dict()

 def insert(self, val: int) -&amp;gt; bool:
 if val not in self.d:
 self.d[val] = len(self.l)
 self.l.append(val)
 return True

 return False


 def remove(self, val: int) -&amp;gt; bool:
 if val in self.d:
 i = self.d[val]
 del self.d[val]

 last_val = self.l[-1]

 # Swap with the last element
 self.l[i] = last_val
 self.l.pop()

 # Update the dictionary for the swapped element only if it&amp;#39;s not the same as removed valA
 # i.e. not the last element
 if i &amp;lt; len(self.l):
 ## if i != len(self.l):
 self.d[last_val] = i

 return True

 return False


 def getRandom(self) -&amp;gt; int:
 return random.choice(self.l)


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #380: Insert Delete GetRandom O(1)"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #288: Unique Word Abbreviation</title><link>https://perrotta.dev/2026/01/leetcode-%23288-unique-word-abbreviation/</link><pubDate>Sat, 17 Jan 2026 03:00:13 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23288-unique-word-abbreviation/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/unique-word-abbreviation"&gt;LeetCode #288: Unique Word Abbreviation&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

def abbrev(word):
 if len(word) &amp;lt; 3:
 return word

 return f&amp;#39;{word[0]}{len(word) - 2}{word[-1]}&amp;#39;

assert abbrev(&amp;#34;dg&amp;#34;) == &amp;#34;dg&amp;#34;
assert abbrev(&amp;#34;dog&amp;#34;) == &amp;#34;d1g&amp;#34;
assert abbrev(&amp;#34;a&amp;#34;) == &amp;#34;a&amp;#34;


class ValidWordAbbr:

 def __init__(self, words: List[str]):
 self.words = words

 ## self.mappings = Counter() # abbrev -&amp;gt; word
 ## for word in set(words):
 ## self.mappings[abbrev(word)] &amp;#43;= 1

 self.mappings = Counter(abbrev(word) for word in set(words))

 def isUnique(self, word: str) -&amp;gt; bool:
 ab = abbrev(word)

 return self.mappings[ab] &amp;lt; 1 or (self.mappings[ab] == 1 and word in self.words)


# Your ValidWordAbbr object will be instantiated and called as such:
# obj = ValidWordAbbr(dictionary)
# param_1 = obj.isUnique(word)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #288: Unique Word Abbreviation"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #23: Merge k Sorted Lists</title><link>https://perrotta.dev/2026/01/leetcode-%2323-merge-k-sorted-lists/</link><pubDate>Thu, 15 Jan 2026 23:20:52 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%2323-merge-k-sorted-lists/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/merge-k-sorted-lists"&gt;LeetCode #23: Merge k Sorted Lists&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Heap of ListNodes:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import heapq

# Definition for singly-linked list.
# class ListNode:
# def __init__(self, val=0, next=None):
# self.val = val
# self.next = next
class HeapNode:
 def __init__(self, node: ListNode):
 self.node = node

 def __lt__(self, other: HeapNode):
 return self.node.val &amp;lt; other.node.val

class Solution:
 def mergeKLists(self, lists: List[Optional[ListNode]]) -&amp;gt; Optional[ListNode]:
 prehead = ListNode(None)

 curr = prehead
 heap = []

 for lst in lists:
 if lst:
 heapq.heappush(heap, HeapNode(lst))

 while heap:
 # find next element: val
 next_heap_node = heapq.heappop(heap)
 next_node = next_heap_node.node

 curr.next = ListNode(next_node.val)
 curr = curr.next

 next_node = next_node.next
 if next_node:
 heapq.heappush(heap, HeapNode(next_node))


 head = prehead.next
 return head&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #23: Merge k Sorted Lists"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #362: Design Hit Counter</title><link>https://perrotta.dev/2026/01/leetcode-%23362-design-hit-counter/</link><pubDate>Thu, 15 Jan 2026 23:10:19 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23362-design-hit-counter/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-hit-counter"&gt;LeetCode #362: Design Hit Counter&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;Counter&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import bisect
from collections import Counter

class HitCounter:

 def __init__(self):
 self.hits = Counter()
 ## timestamp -&amp;gt; hits

 def hit(self, timestamp: int) -&amp;gt; None:
 self.hits[timestamp] &amp;#43;= 1

 def getHits(self, timestamp: int) -&amp;gt; int:
 ## 3 * 60 -&amp;gt; 2
 ## 4 * 60 -&amp;gt; 1
 ## getHits(8 * 60) -&amp;gt; 3

 ## (exclusive, inclusive)
 ## (self.hits[timestamp - 300], self.hits[timestamp])

 items = list(sorted(self.hits.items()))
 ## (timestamp, counter)

 ## inclusive
 ts_left = bisect.bisect_right(items, timestamp - 300, key=lambda item: item[0])
 ts_right = bisect.bisect_left(items, timestamp, key=lambda item: item[0])

 ans = 0

 for (timestamp, hits) in items[ts_left:]:
 ans &amp;#43;= hits

 return ans


# Your HitCounter object will be instantiated and called as such:
# obj = HitCounter()
# obj.hit(timestamp)
# param_2 = obj.getHits(timestamp)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Alternatively, maintain our own sorted list of tuple:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import bisect

class HitCounter:

 def __init__(self):
 self.hits = []
 ## (timestamp, hits)

 def hit(self, timestamp: int) -&amp;gt; None:
 i = bisect.bisect_left(self.hits, timestamp, key=lambda item: item[0])
 if i &amp;lt; len(self.hits) and self.hits[i][0] == timestamp:
 self.hits[i] = (timestamp, self.hits[i][1] &amp;#43; 1)
 else:
 self.hits.insert(i, (timestamp, 1))

 def getHits(self, timestamp: int) -&amp;gt; int:
 ## 3 * 60 -&amp;gt; 2
 ## 4 * 60 -&amp;gt; 1
 ## getHits(8 * 60) -&amp;gt; 3

 ## (exclusive, inclusive)
 ## (self.hits[timestamp - 300], self.hits[timestamp])

 ## (timestamp, counter)

 ## inclusive
 ts_left = bisect.bisect_right(self.hits, timestamp - 300, key=lambda item: item[0])
 ts_right = bisect.bisect_left(self.hits, timestamp, key=lambda item: item[0])

 ans = 0

 for (timestamp, hits) in self.hits[ts_left:]:
 ans &amp;#43;= hits

 return ans


# Your HitCounter object will be instantiated and called as such:
# obj = HitCounter()
# obj.hit(timestamp)
# param_2 = obj.getHits(timestamp)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #362: Design Hit Counter"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #692: Top K Frequent Words</title><link>https://perrotta.dev/2026/01/leetcode-%23692-top-k-frequent-words/</link><pubDate>Sun, 11 Jan 2026 10:26:15 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23692-top-k-frequent-words/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/top-k-frequent-words"&gt;LeetCode #692: Top K Frequent Words&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter, defaultdict

class Solution:
 def topKFrequent(self, words: List[str], k: int) -&amp;gt; List[str]:
 ## return [word for (word, freq) in Counter(words).most_common()][:k]

 by_freq = defaultdict(list)

 for (word, freq) in Counter(words).most_common():
 by_freq[freq].append(word)

 ans = []

 for (freq, words) in sorted(by_freq.items(), reverse=True):
 ans.extend(sorted(words))
 if len(ans) &amp;gt;= k:
 break

 return ans[:k]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #692: Top K Frequent Words"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #170: Two Sum III - Data structure design</title><link>https://perrotta.dev/2026/01/leetcode-%23170-two-sum-iii-data-structure-design/</link><pubDate>Sun, 11 Jan 2026 08:08:13 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23170-two-sum-iii-data-structure-design/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/two-sum-iii---data-structure-design"&gt;LeetCode #170: Two Sum III ‚Äî Data structure design&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class TwoSum:

 def __init__(self):
 self.s = Counter()


 def add(self, number: int) -&amp;gt; None:
 self.s[number] &amp;#43;= 1


 def find(self, value: int) -&amp;gt; bool:
 for num in self.s:
 if (value - num) == num:
 if self.s[num] &amp;gt; 1:
 return True
 elif value - num in self.s:
 return True

 return False


# Your TwoSum object will be instantiated and called as such:
# obj = TwoSum()
# obj.add(number)
# param_2 = obj.find(value)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #170: Two Sum III - Data structure design"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #347: Top K Frequent Elements</title><link>https://perrotta.dev/2026/01/leetcode-%23347-top-k-frequent-elements/</link><pubDate>Sat, 10 Jan 2026 02:09:59 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23347-top-k-frequent-elements/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/top-k-frequent-elements"&gt;LeetCode #347: Top K Frequent Elements&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;Counter&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Solution:
 def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
 return [k for (k, v) in Counter(nums).most_common()[:k]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;defaultdict(int)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

class Solution:
 def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
 c = defaultdict(int)
 for num in nums:
 c[num] &amp;#43;= 1

 return [k for (k, v) in (sorted(c.items(), key=lambda item: item[1], reverse=True))[:k]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With max heap:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter
import heapq

class Solution:
 def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
 # c = defaultdict(int)
 # for num in nums:
 # c[num] &amp;#43;= 1

 # return [k for (k, v) in (sorted(c.items(), key=lambda item: item[1], reverse=True))[:k]]

 counter = Counter(nums)

 class Pair:
 def __init__(self, num, freq):
 self.num = num
 self.freq = freq

 def __lt__(self, other):
 if not isinstance(other, Pair):
 raise ValueError
 # note: &amp;gt; instead of &amp;lt; because we want the TOP elements ‚Äì max heap
 return self.freq &amp;gt; other.freq

 pq = []

 for (num, freq) in counter.items():
 pq.append(Pair(num, freq))

 heapq.heapify(pq)

 ans = []

 for _ in range(k):
 pair = heapq.heappop(pq)
 ans.append(pair.num)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Simpler:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter
import heapq

class Solution:
 def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
 # c = defaultdict(int)
 # for num in nums:
 # c[num] &amp;#43;= 1

 # return [k for (k, v) in (sorted(c.items(), key=lambda item: item[1], reverse=True))[:k]]

 counter = Counter(nums)

 class Pair:
 def __init__(self, num, freq):
 self.num = num
 self.freq = freq

 def __lt__(self, other):
 if not isinstance(other, Pair):
 raise ValueError
 return self.freq &amp;lt; other.freq

 pq = []

 for (num, freq) in counter.items():
 pq.append(Pair(num, freq))

 heapq.heapify(pq)

 ans = []

 return [pair.num for pair in heapq.nlargest(k, pq)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #347: Top K Frequent Elements"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #694: Number of Distinct Islands</title><link>https://perrotta.dev/2026/01/leetcode-%23694-number-of-distinct-islands/</link><pubDate>Sat, 10 Jan 2026 01:50:25 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23694-number-of-distinct-islands/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/number-of-distinct-islands"&gt;LeetCode #694: Number of Distinct Islands&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wrong answer&lt;/strong&gt;: 696 / 760 testcases passed. Directions do not uniquely
identify shapes. Counterexample:&lt;/p&gt;
&lt;div class="codeblock"&gt;
 &lt;pre&gt;&lt;code class="language-plaintext"&gt;1 1 1 1
1 0 0 1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;These produce the same directions.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

class Solution:
 def numDistinctIslands(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 ans: set[str] = set()

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def bfs(x, y):
 queue = deque([(x, y)])
 h = [str((0, 0))] # hash

 while queue:
 (x, y) = queue.popleft()

 # if not within_bounds(x, y):
 # continue

 ## if grid[x][y] == -1:
 ## continue

 grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )

 if within_bounds(neighbor[0], neighbor[1]) and grid[neighbor[0]][neighbor[1]] == 1:
 queue.append((neighbor[0], neighbor[1]))
 h.append(str(dir))

 ans.add(&amp;#39;&amp;#39;.join(h))


 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if cell == 1:
 bfs(x, y)

 return len(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Instead, store relative positions. Memory limit exceeded: 714 / 760 testcases
passed.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

class Solution:
 def numDistinctIslands(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 ans: set[str] = set()

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def bfs(initial_x, initial_y):
 queue = deque([(initial_x, initial_y)])
 h = [str((0, 0))] # hash

 while queue:
 (x, y) = queue.popleft()

 # if not within_bounds(x, y):
 # continue

 ## if grid[x][y] == -1:
 ## continue

 grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )

 if within_bounds(neighbor[0], neighbor[1]) and grid[neighbor[0]][neighbor[1]] == 1:
 queue.append((neighbor[0], neighbor[1]))
 h.append(str((neighbor[0] - initial_x, neighbor[1] - initial_y)))

 ans.add(&amp;#39;&amp;#39;.join(h))


 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if cell == 1:
 bfs(x, y)

 return len(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;We need to mark cells as visited right away, before queueing them:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

class Solution:
 def numDistinctIslands(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 ans: set[str] = set()

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def bfs(initial_x, initial_y):
 queue = deque([(initial_x, initial_y)])
 h = [(0, 0)] # hash
 grid[initial_x][initial_y] = -1

 while queue:
 (x, y) = queue.popleft()

 # if not within_bounds(x, y):
 # continue

 ## if grid[x][y] == -1:
 ## continue

 ## grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )

 if within_bounds(neighbor[0], neighbor[1]) and grid[neighbor[0]][neighbor[1]] == 1:
 queue.append((neighbor[0], neighbor[1]))
 grid[neighbor[0]][neighbor[1]] = -1
 h.append((neighbor[0] - initial_x, neighbor[1] - initial_y))

 ## ans.add(frozenset(h))
 ans.add(tuple(sorted(h))) # supposedly faster


 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if cell == 1:
 bfs(x, y)

 return len(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #694: Number of Distinct Islands"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1254: Number of Closed Islands</title><link>https://perrotta.dev/2026/01/leetcode-%231254-number-of-closed-islands/</link><pubDate>Sat, 10 Jan 2026 01:23:06 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231254-number-of-closed-islands/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/number-of-closed-islands"&gt;LeetCode #1254: Number of Closed Islands&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Recursive:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def closedIsland(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def dfs(x, y, poisoned=False):
 if not within_bounds(x, y):
 return True

 if grid[x][y] in [-1, 1]:
 return False

 grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )
 if dfs(neighbor[0], neighbor[1]):
 poisoned = True

 return poisoned

 ans = 0

 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if grid[x][y] == 0:
 if not dfs(x, y):
 ans &amp;#43;= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Iterative:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def closedIsland(self, grid: List[List[int]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def dfs(x, y):
 valid = True

 stack = [(x, y)]

 while stack:
 (x, y) = stack.pop()

 if not within_bounds(x, y):
 valid = False
 continue

 if grid[x][y] in [-1, 1]:
 continue

 ## assert grid[x][y] == 0
 grid[x][y] = -1

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )
 ## if not within_bounds(neighbor[0], neighbor[1]):
 ## return False
 stack.append((neighbor[0], neighbor[1]))

 return valid

 ans = 0

 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if grid[x][y] == 0:
 ans &amp;#43;= dfs(x, y)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1254: Number of Closed Islands"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #200: Number of Islands</title><link>https://perrotta.dev/2026/01/leetcode-%23200-number-of-islands/</link><pubDate>Sat, 10 Jan 2026 00:24:09 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23200-number-of-islands/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/number-of-islands"&gt;LeetCode #200: Number of Islands&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numIslands(self, grid: List[List[str]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def dfs(x, y):
 if not within_bounds(x, y):
 return

 if grid[x][y] in [&amp;#34;-1&amp;#34;, &amp;#34;0&amp;#34;]:
 return

 grid[x][y] = &amp;#34;-1&amp;#34;

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )
 dfs(neighbor[0], neighbor[1])

 ans = 0

 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if grid[x][y] == &amp;#34;1&amp;#34;:
 dfs(x, y)
 ans &amp;#43;= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Pass tuples around:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numIslands(self, grid: List[List[str]]) -&amp;gt; int:
 m = len(grid)
 n = len(grid[0])

 def within_bounds(coords):
 (a, b) = coords
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 def dfs(coords):
 (x, y) = coords
 if not within_bounds(coords):
 return

 if grid[x][y] in [&amp;#34;-1&amp;#34;, &amp;#34;0&amp;#34;]:
 return

 grid[x][y] = &amp;#34;-1&amp;#34;

 for dir in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )
 dfs(neighbor)

 ans = 0

 for x, row in enumerate(grid):
 for y, cell in enumerate(row):
 if grid[x][y] == &amp;#34;1&amp;#34;:
 dfs((x, y))
 ans &amp;#43;= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #200: Number of Islands"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1244: Design A Leaderboard</title><link>https://perrotta.dev/2026/01/leetcode-%231244-design-a-leaderboard/</link><pubDate>Sat, 10 Jan 2026 00:12:45 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231244-design-a-leaderboard/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-a-leaderboard"&gt;LeetCode #1244: Design A Leaderboard&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;With Counter:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Leaderboard:

 def __init__(self):
 self.counter = Counter()

 def addScore(self, playerId: int, score: int) -&amp;gt; None:
 self.counter[playerId] &amp;#43;= score

 def top(self, K: int) -&amp;gt; int:
 return sum(v for (k, v) in self.counter.most_common()[:K])

 def reset(self, playerId: int) -&amp;gt; None:
 del self.counter[playerId]
 ## self.counter[playerId] = 0


# Your Leaderboard object will be instantiated and called as such:
# obj = Leaderboard()
# obj.addScore(playerId,score)
# param_2 = obj.top(K)
# obj.reset(playerId)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With priority queue (heap):&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

class Leaderboard:

 def __init__(self):
 self.d = defaultdict(int)

 def addScore(self, playerId: int, score: int) -&amp;gt; None:
 self.d[playerId] &amp;#43;= score

 def top(self, K: int) -&amp;gt; int:
 pq = []

 for score in self.d.values():
 heapq.heappush(pq, score)
 if len(pq) &amp;gt; K:
 heapq.heappop(pq)

 return sum(pq)

 def reset(self, playerId: int) -&amp;gt; None:
 del self.d[playerId]


# Your Leaderboard object will be instantiated and called as such:
# obj = Leaderboard()
# obj.addScore(playerId,score)
# param_2 = obj.top(K)
# obj.reset(playerId)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1244: Design A Leaderboard"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #2490: Circular Sentence</title><link>https://perrotta.dev/2026/01/leetcode-%232490-circular-sentence/</link><pubDate>Sat, 10 Jan 2026 00:05:44 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%232490-circular-sentence/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/circular-sentence"&gt;LeetCode #2490: Circular Sentence&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def isCircularSentence(self, sentence: str) -&amp;gt; bool:
 # case sensitive

 words = sentence.strip().split(&amp;#39; &amp;#39;)

 for word1, word2 in zip(
 words,
 words[1:] &amp;#43; [words[0]]
 ):
 if word1[-1] != word2[0]:
 return False

 return True&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #2490: Circular Sentence"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #286: Walls and Gates</title><link>https://perrotta.dev/2026/01/leetcode-%23286-walls-and-gates/</link><pubDate>Fri, 09 Jan 2026 23:57:56 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23286-walls-and-gates/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/walls-and-gates"&gt;LeetCode #286: Walls and Gates&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Level order traversal:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

class Solution:
 def wallsAndGates(self, rooms: List[List[int]]) -&amp;gt; None:
 &amp;#34;&amp;#34;&amp;#34;
 Do not return anything, modify rooms in-place instead.
 &amp;#34;&amp;#34;&amp;#34;
 m = len(rooms)
 n = len(rooms[0])

 INF = 2 ** 31 - 1

 def bfs(x, y):
 queue = deque([(x, y)])

 dirs = [
 (0, 1),
 (1, 0),
 (0, -1),
 (-1, 0),
 ]

 def within_bounds(a, b):
 return 0 &amp;lt;= a &amp;lt; m and 0 &amp;lt;= b &amp;lt; n

 level = 0
 while queue:
 level &amp;#43;= 1
 num_elements = len(queue)

 for _ in range(num_elements):
 (x, y) = queue.popleft()

 for dir in dirs:
 neighbor = (
 x &amp;#43; dir[0],
 y &amp;#43; dir[1],
 )

 if within_bounds(neighbor[0], neighbor[1]):
 value = rooms[neighbor[0]][neighbor[1]]

 if value == 0 or value == -1:
 continue

 if level &amp;lt; value:
 rooms[neighbor[0]][neighbor[1]] = level
 queue.append((neighbor[0], neighbor[1]))



 for x, row in enumerate(rooms):
 for y, cell in enumerate(row):
 if cell == 0:
 bfs(x, y)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #286: Walls and Gates"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1472: Design Browser History</title><link>https://perrotta.dev/2026/01/leetcode-%231472-design-browser-history/</link><pubDate>Fri, 09 Jan 2026 22:07:44 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231472-design-browser-history/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-browser-history"&gt;LeetCode #1472: Design Browser History&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class BrowserHistory:

 def __init__(self, homepage: str):
 self.history = [homepage]
 self.pos = 0

 # example.com &amp;lt;-
 # example.org
 # foo.example.com &amp;lt;=


 def visit(self, url: str) -&amp;gt; None:
 if self.pos == (len(self.history) - 1):
 self.history.append(url)
 self.pos &amp;#43;= 1
 else:
 self.pos &amp;#43;= 1
 self.history[self.pos] = url
 self.history = self.history[:self.pos &amp;#43; 1]


 def back(self, steps: int) -&amp;gt; str:
 steps = min(steps, self.pos)
 self.pos -= steps
 return self.history[self.pos]


 def forward(self, steps: int) -&amp;gt; str:
 steps = min(steps, len(self.history) - 1 - self.pos)
 self.pos &amp;#43;= steps
 return self.history[self.pos]


# Your BrowserHistory object will be instantiated and called as such:
# obj = BrowserHistory(homepage)
# obj.visit(url)
# param_2 = obj.back(steps)
# param_3 = obj.forward(steps)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1472: Design Browser History"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1188: Design Bounded Blocking Queue</title><link>https://perrotta.dev/2026/01/leetcode-%231188-design-bounded-blocking-queue/</link><pubDate>Fri, 09 Jan 2026 21:58:29 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231188-design-bounded-blocking-queue/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-bounded-blocking-queue"&gt;LeetCode #1188: Design Bounded Blocking Queue&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque
from threading import Lock, Condition

class BoundedBlockingQueue(object):

 def __init__(self, capacity: int):
 self.q = deque()
 self.capacity = capacity
 self.lock = Lock()
 self.not_full = Condition(self.lock)
 self.not_empty = Condition(self.lock)


 def enqueue(self, element: int) -&amp;gt; None:
 self.not_full.acquire()

 while self.size() == self.capacity:
 self.not_full.wait()

 self.q.append(element)
 self.not_empty.notify()
 self.not_full.release()

 def dequeue(self) -&amp;gt; int:
 self.not_empty.acquire()

 while self.size() == 0:
 self.not_empty.wait()

 element = self.q.popleft()
 self.not_full.notify()
 self.not_empty.release()

 return element


 def size(self) -&amp;gt; int:
 return len(self.q)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1188: Design Bounded Blocking Queue"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1756: Design Most Recently Used Queue</title><link>https://perrotta.dev/2026/01/leetcode-%231756-design-most-recently-used-queue/</link><pubDate>Fri, 09 Jan 2026 21:53:51 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231756-design-most-recently-used-queue/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-most-recently-used-queue"&gt;LeetCode #1756: Design Most Recently Used Queue&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class MRUQueue:

 def __init__(self, n: int):
 self.arr = list(range(1, n &amp;#43; 1))

 def fetch(self, k: int) -&amp;gt; int:
 # 0-indexed
 k -= 1

 assert 0 &amp;lt;= k &amp;lt; len(self.arr)

 el = self.arr[k]

 del self.arr[k]
 self.arr.append(el)

 return el

# Your MRUQueue object will be instantiated and called as such:
# obj = MRUQueue(n)
# param_1 = obj.fetch(k)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1756: Design Most Recently Used Queue"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #622: Design Circular Queue</title><link>https://perrotta.dev/2026/01/leetcode-%23622-design-circular-queue/</link><pubDate>Fri, 09 Jan 2026 04:35:00 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23622-design-circular-queue/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-circular-queue"&gt;LeetCode #622: Design Circular Queue&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class MyCircularQueue:

 def __init__(self, k: int):
 self.q = [None] * k
 self.k = k

 self.start = 0
 self.end = 0
 self.count = 0

 ## -- queue

 ## . . .
 ## se

 ## 1 . .
 ## s e

 ## 1 . 2
 ## s e

 ## -- dequeue

 ## 1 . 2
 ## s e

 ## . . 2
 ## e s

 def enQueue(self, value: int) -&amp;gt; bool:
 if self.isFull():
 return False

 self.q[self.end] = value
 self.end = (self.end - 1) % self.k
 self.count &amp;#43;= 1
 return True


 def deQueue(self) -&amp;gt; bool:
 if self.isEmpty():
 return False

 self.start = (self.start - 1) % self.k
 self.count -= 1
 return True


 def Front(self) -&amp;gt; int:
 if self.isEmpty():
 return -1

 return self.q[self.start]


 def Rear(self) -&amp;gt; int:
 if self.isEmpty():
 return -1

 return self.q[(self.end &amp;#43; 1) % self.k]


 def isEmpty(self) -&amp;gt; bool:
 return self.count == 0


 def isFull(self) -&amp;gt; bool:
 return self.count == self.k


# Your MyCircularQueue object will be instantiated and called as such:
# obj = MyCircularQueue(k)
# param_1 = obj.enQueue(value)
# param_2 = obj.deQueue()
# param_3 = obj.Front()
# param_4 = obj.Rear()
# param_5 = obj.isEmpty()
# param_6 = obj.isFull()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #622: Design Circular Queue"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #641: Design Circular Deque</title><link>https://perrotta.dev/2026/01/leetcode-%23641-design-circular-deque/</link><pubDate>Fri, 09 Jan 2026 04:20:38 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23641-design-circular-deque/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-circular-deque"&gt;LeetCode #641: Design Circular Deque&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class MyCircularDeque:

 def __init__(self, k: int):
 self.q = [None] * k
 self.k = k

 self.start = 0
 self.end = 0
 self.count = 0

 ## . . . .
 ## se

 ## . 1 . .
 ## s e

 ## . 2 3 .
 ## s e

 def insertFront(self, value: int) -&amp;gt; bool:
 if self.isEmpty():
 self.q[self.start] = value
 self.start = (self.start - 1) % self.k
 self.end = (self.end &amp;#43; 1) % self.k
 self.count &amp;#43;= 1
 return True

 if self.isFull():
 return False

 self.q[self.start] = value
 self.start = (self.start - 1) % self.k
 self.count &amp;#43;= 1
 return True


 def insertLast(self, value: int) -&amp;gt; bool:
 if self.isEmpty():
 self.q[self.end] = value
 self.start = (self.start - 1) % self.k
 self.end = (self.end &amp;#43; 1) % self.k
 self.count &amp;#43;= 1
 return True

 if self.isFull():
 return False

 self.q[self.end] = value
 self.end = (self.end &amp;#43; 1) % self.k
 self.count &amp;#43;= 1
 return True


 def deleteFront(self) -&amp;gt; bool:
 if self.isEmpty():
 return False

 self.start = (self.start &amp;#43; 1) % self.k
 self.count -= 1
 ## self.q[self.start] = None

 if self.count == 0:
 self.end = self.start

 return True


 def deleteLast(self) -&amp;gt; bool:
 if self.isEmpty():
 return False

 self.end = (self.end - 1) % self.k
 self.count -= 1
 ## self.q[self.end] = None

 if self.count == 0:
 self.start = self.end

 return True

 def getFront(self) -&amp;gt; int:
 if self.isEmpty():
 return -1
 return self.q[(self.start &amp;#43; 1) % self.k]


 def getRear(self) -&amp;gt; int:
 if self.isEmpty():
 return -1
 return self.q[self.end - 1 % self.k]


 def isEmpty(self) -&amp;gt; bool:
 return self.count == 0


 def isFull(self) -&amp;gt; bool:
 return self.count == self.k



# Your MyCircularDeque object will be instantiated and called as such:
# obj = MyCircularDeque(k)
# param_1 = obj.insertFront(value)
# param_2 = obj.insertLast(value)
# param_3 = obj.deleteFront()
# param_4 = obj.deleteLast()
# param_5 = obj.getFront()
# param_6 = obj.getRear()
# param_7 = obj.isEmpty()
# param_8 = obj.isFull()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #641: Design Circular Deque"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #211: Design Add and Search Words Data Structure</title><link>https://perrotta.dev/2026/01/leetcode-%23211-design-add-and-search-words-data-structure/</link><pubDate>Thu, 08 Jan 2026 03:43:06 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23211-design-add-and-search-words-data-structure/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/design-add-and-search-words-data-structure"&gt;LeetCode #211: Design Add and Search Words Data Structure&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

class Node:
 def __init__(self):
 self.children = {}
 self.end = False

class WordDictionary:

 def __init__(self):
 self.root = Node()

 def addWord(self, word: str) -&amp;gt; None:
 node = self.root
 ## &amp;#34;hello&amp;#34;
 for c in word:
 if c not in node.children:
 node.children[c] = Node()
 node = node.children[c]
 node.end = True

 def search(self, word: str) -&amp;gt; bool:
 def node_search(node, word: str) -&amp;gt; bool:
 for i, c in enumerate(word):
 if c == &amp;#39;.&amp;#39;:
 for child in node.children.values():
 if node_search(child, word[i &amp;#43; 1:]):
 return True
 return False

 if c not in node.children:
 return False
 node = node.children[c]

 return node.end

 return node_search(self.root, word)


# Your WordDictionary object will be instantiated and called as such:
# obj = WordDictionary()
# obj.addWord(word)
# param_2 = obj.search(word)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #211: Design Add and Search Words Data Structure"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #2965: Find Missing and Repeated Values</title><link>https://perrotta.dev/2026/01/leetcode-%232965-find-missing-and-repeated-values/</link><pubDate>Thu, 08 Jan 2026 00:24:02 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%232965-find-missing-and-repeated-values/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/find-missing-and-repeated-values"&gt;LeetCode #2965: Find Missing and Repeated Values&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Two sets:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def findMissingAndRepeatedValues(self, grid: List[List[int]]) -&amp;gt; List[int]:
 seen = set()
 numbers = set(range(1, len(grid) ** 2 &amp;#43; 1))

 a = b = None

 for row in grid:
 for num in row:
 if num in seen:
 a = num
 continue
 seen.add(num)
 numbers.discard(num)

 assert len(numbers) == 1
 b = numbers.pop()

 return [a, b]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #2965: Find Missing and Repeated Values"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1033: Moving Stones Until Consecutive</title><link>https://perrotta.dev/2026/01/leetcode-%231033-moving-stones-until-consecutive/</link><pubDate>Wed, 07 Jan 2026 23:53:36 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231033-moving-stones-until-consecutive/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/moving-stones-until-consecutive"&gt;LeetCode #1033: Moving Stones Until Consecutive&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Convoluted:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numMovesStones(self, a: int, b: int, c: int) -&amp;gt; List[int]:
 (a, b, c) = sorted([a, b, c])

 ans_max = ((c - b) - 1) &amp;#43; ((b - a) - 1)

 ans_min = 0
 while not ((b - a) == 1 and (c - b) == 1): ## 3 4 5
 ## 3 10 50

 if (b - a) == 1 or (c - b) == 1:
 ans_min &amp;#43;= 1
 break

 # find smallest interval with a gap
 ## (3, 10)
 if (c - b == 1) or (b - a) &amp;lt;= (c - b): # left
 e1 = a
 e2 = b
 ms = c
 else: ## right
 e1 = b
 e2 = c
 ms = a

 # move the other stone (ms) to the middle of (e1, e2)
 ms = (e1 &amp;#43; e2) // 2

 # update a, b, c; then keep going
 a, b, c = e1, ms, e2
 assert a &amp;lt; b
 assert b &amp;lt; c

 ans_min &amp;#43;= 1
 if ans_min == 2:
 break

 return [ans_min, ans_max]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;min_ans&lt;/code&gt; will be up to 2. That will significantly simplify everything!&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numMovesStones(self, a: int, b: int, c: int) -&amp;gt; List[int]:
 (a, b, c) = sorted([a, b, c])

 ans_max = ((c - b) - 1) &amp;#43; ((b - a) - 1)

 ans_min = 0
 if ((b - a) == 1 and (c - b) == 1): ## 3 4 5
 ans_min = 0
 elif (b - a) in [1, 2] or (c - b) in [1, 2]: ## 3 4 6
 ans_min = 1
 else:
 ans_min = 2

 return [ans_min, ans_max]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1033: Moving Stones Until Consecutive"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #771: Jewels and Stones</title><link>https://perrotta.dev/2026/01/leetcode-%23771-jewels-and-stones/</link><pubDate>Wed, 07 Jan 2026 01:18:30 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23771-jewels-and-stones/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/jewels-and-stones"&gt;LeetCode #771: Jewels and Stones&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Cozy:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numJewelsInStones(self, jewels: str, stones: str) -&amp;gt; int:
 s = set(jewels)

 ans = 0

 for stone in stones:
 if stone in s:
 ans &amp;#43;= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;One-liner:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def numJewelsInStones(self, jewels: str, stones: str) -&amp;gt; int:
 s = set(jewels)
 return sum(stone in s for stone in stones)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #771: Jewels and Stones"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #652: Find Duplicate Subtrees</title><link>https://perrotta.dev/2026/01/leetcode-%23652-find-duplicate-subtrees/</link><pubDate>Wed, 07 Jan 2026 00:49:44 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23652-find-duplicate-subtrees/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/find-duplicate-subtrees"&gt;LeetCode #652: Find Duplicate Subtrees&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Original, 119 / 175 testcases passed:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

# Definition for a binary tree node.
# class TreeNode:
# def __init__(self, val=0, left=None, right=None):
# self.val = val
# self.left = left
# self.right = right
class Solution:
 def findDuplicateSubtrees(self, root: Optional[TreeNode]) -&amp;gt; List[Optional[TreeNode]]:
 mappings = defaultdict(list)

 def dfs(node):
 if not node:
 return

 mappings[node.val].append(node)

 dfs(node.left)
 dfs(node.right)

 dfs(root)

 ans = set()

 def duplicate_subtree(node1, node2):
 if not node1 and not node2:
 return True

 if not node1 and node2:
 return False

 if node1 and not node2:
 return False

 return node1.val == node2.val and duplicate_subtree(node1.left, node2.left) and duplicate_subtree(node1.right, node2.right)

 for nodes in mappings.values():
 for i, node1 in enumerate(nodes[:-1]):
 for node2 in nodes[i &amp;#43; 1:]:
 if duplicate_subtree(node1, node2):
 ans.add(node1)

 return list(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With proper serialization:&lt;/p&gt;
&lt;div class="codeblock" data-lang="shell"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;shell&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-bash"&gt;from collections import Counter

class Solution:
 def findDuplicateSubtrees(self, root: Optional[TreeNode]) -&amp;gt; List[Optional[TreeNode]]:
 # serial -&amp;gt; count
 seen = Counter()

 # serial -&amp;gt; node
 node_from_serial = {}

 def dfs(node) -&amp;gt; str:
 &amp;#34;&amp;#34;&amp;#34;Return the serialized representation of the node.&amp;#34;&amp;#34;&amp;#34;
 if not node:
 return &amp;#34;null&amp;#34;

 s = f&amp;#34;{node.val},{dfs(node.left)},{dfs(node.right)}&amp;#34;

 node_from_serial[s] = node

 seen[s] &amp;#43;= 1

 return s

 dfs(root)

 ans = []

 for (serial, count) in seen.items():
 if count &amp;gt;= 2:
 ans.append(node_from_serial[serial])

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Optimized:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Solution:
 def findDuplicateSubtrees(self, root: Optional[TreeNode]) -&amp;gt; List[Optional[TreeNode]]:
 # serial -&amp;gt; count
 seen = Counter()

 ans = []

 def dfs(node) -&amp;gt; str:
 &amp;#34;&amp;#34;&amp;#34;Return the serialized representation of the node.&amp;#34;&amp;#34;&amp;#34;
 if not node:
 return &amp;#34;null&amp;#34;

 s = f&amp;#34;{node.val},{dfs(node.left)},{dfs(node.right)}&amp;#34;

 seen[s] &amp;#43;= 1

 if seen[s] == 2:
 ans.append(node)

 return s

 dfs(root)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #652: Find Duplicate Subtrees"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #36: Valid Sudoku</title><link>https://perrotta.dev/2026/01/leetcode-%2336-valid-sudoku/</link><pubDate>Wed, 07 Jan 2026 00:10:01 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%2336-valid-sudoku/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/valid-sudoku"&gt;LeetCode #36: Valid Sudoku&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def isValidSudoku(self, board: List[List[str]]) -&amp;gt; bool:
 m = len(board)
 n = len(board[0])

 def is_valid(a):
 a = [el for el in a if el != &amp;#34;.&amp;#34;]
 ## [1, 2, 2] -&amp;gt; 3
 ## {1, 2} -&amp;gt; 2
 ##
 ## [1, 2]
 ## {1, 2}
 return len(a) - len(set(a)) == 0

 for row in board:
 if not is_valid(row):
 return False

 for col in zip(*board):
 if not is_valid(col):
 return False

 subgrids_i = [
 [0, 0],
 [0, 3],
 [0, 6],
 [3, 0],
 [3, 3],
 [3, 6],
 [6, 0],
 [6, 3],
 [6, 6],
 ]

 for subgrid_i in subgrids_i:
 subgrid = []

 for x in range(3):
 for y in range(3):
 ix = subgrid_i[0] &amp;#43; x
 iy = subgrid_i[1] &amp;#43; y
 subgrid.append(board[ix][iy])

 if not is_valid(subgrid):
 return False

 return True&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #36: Valid Sudoku"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #49: Group Anagrams</title><link>https://perrotta.dev/2026/01/leetcode-%2349-group-anagrams/</link><pubDate>Tue, 06 Jan 2026 23:55:13 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%2349-group-anagrams/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/group-anagrams"&gt;LeetCode #49: Group Anagrams&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict
from collections.abc import Hashable

def is_hashable(obj) -&amp;gt; bool:
 return isinstance(obj, Hashable)

class Solution:
 def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]:
 seen = defaultdict(list)

 for s in strs:
 cs = &amp;#39;&amp;#39;.join(sorted(s)) # canonical
 seen[cs].append(s)

 return list(seen.values())&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #49: Group Anagrams"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #359: Logger Rate Limiter</title><link>https://perrotta.dev/2026/01/leetcode-%23359-logger-rate-limiter/</link><pubDate>Tue, 06 Jan 2026 23:45:02 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23359-logger-rate-limiter/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/logger-rate-limiter"&gt;LeetCode #359: Logger Rate Limiter&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Logger:

 def __init__(self):
 self.log = {}


 def shouldPrintMessage(self, timestamp: int, message: str) -&amp;gt; bool:
 if message not in self.log:
 self.log[message] = timestamp
 return True

 if timestamp - self.log[message] &amp;lt; 10:
 return False

 self.log[message] = timestamp
 return True



# Your Logger object will be instantiated and called as such:
# obj = Logger()
# param_1 = obj.shouldPrintMessage(timestamp,message)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #359: Logger Rate Limiter"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #2215: Find the Difference of Two Arrays</title><link>https://perrotta.dev/2026/01/leetcode-%232215-find-the-difference-of-two-arrays/</link><pubDate>Tue, 06 Jan 2026 23:30:46 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%232215-find-the-difference-of-two-arrays/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/find-the-difference-of-two-arrays"&gt;LeetCode #2215: Find the Difference of Two Arrays&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def findDifference(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[List[int]]:
 s1 = set(nums1)
 s2 = set(nums2)

 return [list(s1 - s2), list(s2 - s1)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #2215: Find the Difference of Two Arrays"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #219: Contains Duplicate II</title><link>https://perrotta.dev/2026/01/leetcode-%23219-contains-duplicate-ii/</link><pubDate>Tue, 06 Jan 2026 21:10:50 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23219-contains-duplicate-ii/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/contains-duplicate-ii"&gt;LeetCode #219: Contains Duplicate II&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import defaultdict

class Solution:
 def containsNearbyDuplicate(self, nums: List[int], k: int) -&amp;gt; bool:
 d = defaultdict(list)
 for i, num in enumerate(nums):
 d[num].append(i)

 for values in d.values():
 values.sort()
 # 1 3 4
 for a, b in zip(values[:-1], values[1:]):
 if abs(a - b) &amp;lt;= k:
 return True

 return False&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #219: Contains Duplicate II"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #350: Intersection of Two Arrays II</title><link>https://perrotta.dev/2026/01/leetcode-%23350-intersection-of-two-arrays-ii/</link><pubDate>Tue, 06 Jan 2026 21:03:03 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23350-intersection-of-two-arrays-ii/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/intersection-of-two-arrays-ii"&gt;LeetCode #350: Intersection of Two Arrays II&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Solution:
 def intersect(self, nums1: List[int], nums2: List[int]) -&amp;gt; List[int]:
 c1 = Counter(nums1)
 c2 = Counter(nums2)

 common = set(c1.keys()) &amp;amp; set(c2.keys())

 ans = []

 for n in common:
 ans.extend([n] * min(c1[n], c2[n]))

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #350: Intersection of Two Arrays II"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #387: First Unique Character in a String</title><link>https://perrotta.dev/2026/01/leetcode-%23387-first-unique-character-in-a-string/</link><pubDate>Tue, 06 Jan 2026 20:59:58 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23387-first-unique-character-in-a-string/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/first-unique-character-in-a-string"&gt;LeetCode #387: First Unique Character in a String&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Solution:
 def firstUniqChar(self, s: str) -&amp;gt; int:
 counter = Counter(s)
 for i, c in enumerate(s):
 if counter[c] == 1:
 return i

 return -1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #387: First Unique Character in a String"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #136: Single Number</title><link>https://perrotta.dev/2026/01/leetcode-%23136-single-number/</link><pubDate>Tue, 06 Jan 2026 20:55:38 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%23136-single-number/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/single-number"&gt;LeetCode #136: Single Number&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;XOR everything:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def singleNumber(self, nums: List[int]) -&amp;gt; int:
 ans = 0
 for num in nums:
 ans ^= num
 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Or with &lt;code&gt;reduce&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from functools import reduce

class Solution:
 def singleNumber(self, nums: List[int]) -&amp;gt; int:
 return reduce(lambda a, b: a ^ b, nums)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #136: Single Number"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #2154: Keep Multiplying Found Values by Two</title><link>https://perrotta.dev/2026/01/leetcode-%232154-keep-multiplying-found-values-by-two/</link><pubDate>Tue, 06 Jan 2026 20:43:08 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%232154-keep-multiplying-found-values-by-two/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/keep-multiplying-found-values-by-two"&gt;LeetCode #2154: Keep Multiplying Found Values by Two&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def findFinalValue(self, nums: List[int], original: int) -&amp;gt; int:
 s = set(nums)

 while True:
 if original in s:
 original &amp;lt;&amp;lt;= 1
 else:
 break

 return original&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #2154: Keep Multiplying Found Values by Two"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #3667: Sort Array By Absolute Value</title><link>https://perrotta.dev/2026/01/leetcode-%233667-sort-array-by-absolute-value/</link><pubDate>Tue, 06 Jan 2026 20:42:00 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%233667-sort-array-by-absolute-value/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/sort-array-by-absolute-value"&gt;LeetCode #3667: Sort Array By Absolute Value&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def sortByAbsoluteValue(self, nums: List[int]) -&amp;gt; List[int]:
 return list(sorted(nums, key=lambda x: abs(x)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #3667: Sort Array By Absolute Value"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1018: Binary Prefix Divisible By 5</title><link>https://perrotta.dev/2026/01/leetcode-%231018-binary-prefix-divisible-by-5/</link><pubDate>Tue, 06 Jan 2026 20:40:49 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231018-binary-prefix-divisible-by-5/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/binary-prefix-divisible-by-5"&gt;LeetCode #1018: Binary Prefix Divisible By 5&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def prefixesDivBy5(self, nums: List[int]) -&amp;gt; List[bool]:
 ans = []

 n = 0

 for i, num in enumerate(nums):
 n = n * 2 &amp;#43; num
 ans.append(n % 5 == 0)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1018: Binary Prefix Divisible By 5"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #1636: Sort Array by Increasing Frequency</title><link>https://perrotta.dev/2026/01/leetcode-%231636-sort-array-by-increasing-frequency/</link><pubDate>Tue, 06 Jan 2026 20:36:01 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%231636-sort-array-by-increasing-frequency/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/sort-array-by-increasing-frequency"&gt;LeetCode #1636: Sort Array by Increasing Frequency&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Solution:
 def frequencySort(self, nums: List[int]) -&amp;gt; List[int]:
 ans = []

 counter = Counter(nums)

 ## 3 3 4 4 2 1 -&amp;gt; 4 4 3 3 2 1

 chunk = []
 prev_count = None

 ## [3, 3]

 for (num, count) in counter.most_common()[::-1]:
 if count != prev_count:
 prev_count = count
 ans.extend(list(sorted(chunk, reverse=True)))
 chunk = []

 chunk.extend([num] * count)

 if chunk:
 ans.extend(list(sorted(chunk, reverse=True)))

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #1636: Sort Array by Increasing Frequency"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #3662: Filter Characters by Frequency</title><link>https://perrotta.dev/2026/01/leetcode-%233662-filter-characters-by-frequency/</link><pubDate>Tue, 06 Jan 2026 20:28:28 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%233662-filter-characters-by-frequency/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/filter-characters-by-frequency"&gt;LeetCode #3662: Filter Characters by Frequency&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import Counter

class Solution:
 def filterCharacters(self, s: str, k: int) -&amp;gt; str:
 ans = []

 counter = Counter(s)

 for c in s:
 if counter[c] &amp;lt; k:
 ans.append(c)

 return &amp;#39;&amp;#39;.join(ans)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #3662: Filter Characters by Frequency"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item><item><title>LeetCode #3467: Transform Array by Parity</title><link>https://perrotta.dev/2026/01/leetcode-%233467-transform-array-by-parity/</link><pubDate>Tue, 06 Jan 2026 20:13:09 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>dev</category><category>leetcode</category><guid>https://perrotta.dev/2026/01/leetcode-%233467-transform-array-by-parity/</guid><description>&lt;p&gt;&lt;a href="https://leetcode.com/problems/transform-array-by-parity"&gt;LeetCode #3467: Transform Array by Parity&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Manual:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def transformArray(self, nums: List[int]) -&amp;gt; List[int]:
 for i, num in enumerate(nums):
 if num % 2 == 0:
 nums[i] = 0
 if num % 2 == 1:
 nums[i] = 1
 return list(sorted(nums))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;List comprehension, less readable:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
 def transformArray(self, nums: List[int]) -&amp;gt; List[int]:
 return list(sorted([(1 if num % 2 == 1 else num) for num in [(0 if num % 2 == 0 else num) for num in nums]]))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: LeetCode #3467: Transform Array by Parity"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/leetcode/"&gt;#leetcode&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>