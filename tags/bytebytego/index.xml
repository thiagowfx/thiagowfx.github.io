<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet type="text/xsl" href="https://perrotta.dev/rss.xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bytebytego on ¬¨ just serendipity üçÄ</title><link>https://perrotta.dev/</link><description>Recent content in Bytebytego on ¬¨ just serendipity üçÄ</description><generator>Hugo</generator><language>en</language><managingEditor>serendipity@perrotta.dev (Thiago Perrotta)</managingEditor><webMaster>serendipity@perrotta.dev (Thiago Perrotta)</webMaster><copyright>¬© 2013 - 2026 Thiago Perrotta ¬∑
[some rights reserved](https://creativecommons.org/licenses/by-nc-sa/4.0/) ¬∑
a fork of [hugo  ï‚Ä¢·¥•‚Ä¢ î bear](https://github.com/janraasch/hugo-bearblog/)</copyright><lastBuildDate>Sun, 22 Feb 2026 00:18:38 +0100</lastBuildDate><atom:link href="https://perrotta.dev/tags/bytebytego/index.xml" rel="self" type="application/rss+xml"/><item><title>ByteByteGo: Product Array Without Current Element</title><link>https://perrotta.dev/2025/12/bytebytego-product-array-without-current-element/</link><pubDate>Tue, 02 Dec 2025 23:12:24 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/12/bytebytego-product-array-without-current-element/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/bytebytego:-product-array-without-current-element"&gt;ByteByteGo: Product Array Without Current Element&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List
from functools import reduce
import operator

def product_array_without_current_element(nums: List[int]) -&amp;gt; List[int]:
 total_no_zeroes = 1
 for num in nums:
 total_no_zeroes *= num if num != 0 else 1

 num_zeroes = len([num for num in nums if num == 0])

 if num_zeroes &amp;gt;= 2:
 return [0] * len(nums)

 if num_zeroes == 0:
 return [total_no_zeroes // num for num in nums]

 assert num_zeroes == 1
 return [0 if num != 0 else total_no_zeroes for num in nums]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Product Array Without Current Element"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: K-Sum Subarrays</title><link>https://perrotta.dev/2025/12/bytebytego-k-sum-subarrays/</link><pubDate>Tue, 02 Dec 2025 22:56:27 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/12/bytebytego-k-sum-subarrays/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/prefix-sums/k-sum-subarrays"&gt;ByteByteGo: K-Sum Subarrays&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List
import itertools

def k_sum_subarrays(nums: List[int], k: int) -&amp;gt; int:
 acc = list(itertools.accumulate(nums))

 ans = 0

 for i in range(len(nums)):
 for j in range(i, len(nums)):
 mysum = acc[j] - (acc[i - 1] if i != 0 else 0)
 if mysum == k:
 ans &amp;#43;= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: K-Sum Subarrays"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Sum Between Range</title><link>https://perrotta.dev/2025/12/bytebytego-sum-between-range/</link><pubDate>Tue, 02 Dec 2025 22:50:57 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/12/bytebytego-sum-between-range/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/prefix-sums/sum-between-range"&gt;ByteByteGo: Sum Between Range&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

import itertools

class SumBetweenRange:
 def __init__(self, nums: List[int]):
 self.acc = list(itertools.accumulate(nums))

 def sum_range(self, i: int, j: int):
 return self.acc[j] - (self.acc[i - 1] if i != 0 else 0)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Sum Between Range"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: First and Last Occurrences of a Number</title><link>https://perrotta.dev/2025/12/bytebytego-first-and-last-occurrences-of-a-number/</link><pubDate>Tue, 02 Dec 2025 16:37:49 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/12/bytebytego-first-and-last-occurrences-of-a-number/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/binary-search/first-and-last-occurrences-of-a-number"&gt;ByteByteGo: First and Last Occurrences of a Number&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import bisect
from typing import List

def first_and_last_occurrences_of_a_number(nums: List[int], target: int) -&amp;gt; int:
 if not nums:
 return [-1, -1]

 left = bisect.bisect_left(nums, target)
 right = bisect.bisect_right(nums, target)

 if (left &amp;lt; len(nums) and nums[left] == target) and (right &amp;gt; 0 and nums[right - 1] == target):
 return [left, right - 1]

 return [-1, -1]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: First and Last Occurrences of a Number"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Happy Number</title><link>https://perrotta.dev/2025/12/bytebytego-happy-number/</link><pubDate>Tue, 02 Dec 2025 16:32:31 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/12/bytebytego-happy-number/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/fast-and-slow-pointers/happy-number"&gt;ByteByteGo: Happy Number&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def happy_number(n: int) -&amp;gt; bool:
 seen = (set([n]))

 def apply(n):
 ans = 0

 while n &amp;gt; 0:
 ans &amp;#43;= (n % 10) ** 2
 n //= 10

 return ans

 assert apply(23) == 13

 while n != 1:
 n = apply(n)

 if n in seen:
 return False
 else:
 seen.add(n)

 return True&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Happy Number"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Linked List Midpoint</title><link>https://perrotta.dev/2025/12/bytebytego-linked-list-midpoint/</link><pubDate>Tue, 02 Dec 2025 16:10:08 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/12/bytebytego-linked-list-midpoint/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/fast-and-slow-pointers/linked-list-midpoint"&gt;ByteByteGo: Linked List Midpoint&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Slow and fast pointers.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from ds import ListNode

&amp;#34;&amp;#34;&amp;#34;
Definition of ListNode:
class ListNode:
 def __init__(self, val=None, next=None):
 self.val = val
 self.next = next
&amp;#34;&amp;#34;&amp;#34;

def linked_list_midpoint(head: ListNode) -&amp;gt; ListNode:
 if not head or not head.next:
 return head

 slow = head
 fast = head

 while fast and fast.next:
 slow = slow.next
 fast = fast.next.next

 return slow&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Linked List Midpoint"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Linked List Loop</title><link>https://perrotta.dev/2025/12/bytebytego-linked-list-loop/</link><pubDate>Tue, 02 Dec 2025 16:01:34 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/12/bytebytego-linked-list-loop/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/fast-and-slow-pointers/detect-linked-list-loops"&gt;ByteByteGo: Linked List Loop&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Slow and fast pointers.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from ds import ListNode

&amp;#34;&amp;#34;&amp;#34;
Definition of ListNode:
class ListNode:
 def __init__(self, val=None, next=None):
 self.val = val
 self.next = next
&amp;#34;&amp;#34;&amp;#34;

def linked_list_loop(head: ListNode) -&amp;gt; bool:
 if not head or not head.next:
 return False

 slow = head
 fast = head.next

 while slow != fast:
 slow = slow.next

 if not fast or not fast.next:
 return False

 fast = fast.next.next

 return True&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Linked List Loop"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Remove the Kth Last Node From a Linked List</title><link>https://perrotta.dev/2025/12/bytebytego-remove-the-kth-last-node-from-a-linked-list/</link><pubDate>Tue, 02 Dec 2025 03:58:25 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/12/bytebytego-remove-the-kth-last-node-from-a-linked-list/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/linked-lists/remove-the-kth-last-node-from-a-linked-list"&gt;ByteByteGo: Remove the Kth Last Node From a Linked List&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from ds import ListNode

&amp;#34;&amp;#34;&amp;#34;
Definition of ListNode:
class ListNode:
 def __init__(self, val=None, next=None):
 self.val = val
 self.next = next
&amp;#34;&amp;#34;&amp;#34;

def remove_kth_last_node(head: ListNode, k: int) -&amp;gt; ListNode:
 pivot = head
 back = head

 for _ in range(k):
 if pivot:
 pivot = pivot.next
 else:
 return head

 if not pivot:
 return head.next

 while pivot.next:
 pivot = pivot.next
 back = back.next

 back.next = back.next.next

 return head&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Remove the Kth Last Node From a Linked List"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Largest Square in a Matrix</title><link>https://perrotta.dev/2025/11/bytebytego-largest-square-in-a-matrix/</link><pubDate>Sun, 30 Nov 2025 23:18:37 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-largest-square-in-a-matrix/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/dynamic-programming/largest-square-in-a-matrix"&gt;ByteByteGo: Largest Square in a Matrix&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List
from functools import lru_cache

def largest_square_in_a_matrix(matrix: List[List[int]]) -&amp;gt; int:
 @lru_cache(maxsize=None)
 def solve(x: int, y: int) -&amp;gt; int:
 if x &amp;lt; 0 or y &amp;lt; 0:
 return 0
 if matrix[x][y] == 0 or x == 0 or y == 0:
 return matrix[x][y]
 return 1 &amp;#43; min(
 solve(x - 1, y),
 solve(x, y - 1),
 solve(x - 1, y - 1),
 )

 # stores the maximum side length
 ans = 0
 for i in range(len(matrix)):
 for j in range(len(matrix[0])):
 ans = max(ans, solve(i, j))

 # Return the area (side length squared)
 return ans * ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Largest Square in a Matrix"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Longest Palindrome in a String</title><link>https://perrotta.dev/2025/11/bytebytego-longest-palindrome-in-a-string/</link><pubDate>Sun, 30 Nov 2025 22:16:55 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-longest-palindrome-in-a-string/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/dynamic-programming/longest-palindrome-in-a-string"&gt;ByteByteGo: Longest Palindrome in a String&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def longest_palindrome_in_a_string(s: str) -&amp;gt; str:
 from functools import lru_cache

 ans = &amp;#34;&amp;#34;

 @lru_cache(maxsize=None)
 def is_palindrome(i, j):
 assert i &amp;gt;= 0
 assert j &amp;lt; len(s)

 if i &amp;gt;= j: # out of bounds
 return True

 if s[i] != s[j]:
 return False

 return is_palindrome(i &amp;#43; 1, j - 1)

 if len(s) &amp;gt; 0:
 ans = s[0]

 for i in range(len(s)):
 for j in range(i &amp;#43; 1, len(s)): # both inclusive
 if is_palindrome(i, j):
 curr_len = j - i &amp;#43; 1
 if curr_len &amp;gt; len(ans):
 ans = s[i:j &amp;#43; 1]

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Longest Palindrome in a String"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: N Queens</title><link>https://perrotta.dev/2025/11/bytebytego-n-queens/</link><pubDate>Sun, 30 Nov 2025 21:14:24 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-n-queens/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/backtracking/n-queens"&gt;ByteByteGo: N Queens&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def n_queens(n: int) -&amp;gt; int:
 ans = 0

 def backtrack(r, vset: set, d1set: set, d2set: set):
 nonlocal ans

 # r, c: row, col

 # d1 set: r &amp;#43; c
 # d2 set: r - c (or c - r, just be consistent)

 if r == n:
 ans &amp;#43;= 1
 return

 for c in range(n):
 # place a queen in (r, c) position if possible
 if c not in vset and c &amp;#43; r not in d1set and c - r not in d2set:
 vset.add(c)
 d1set.add(c &amp;#43; r)
 d2set.add(c - r)

 backtrack(r &amp;#43; 1, vset, d1set, d2set)

 vset.remove(c)
 d1set.remove(c &amp;#43; r)
 d2set.remove(c - r)


 backtrack(0, set(), set(), set())

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: N Queens"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Josephus</title><link>https://perrotta.dev/2025/11/bytebytego-josephus/</link><pubDate>Sun, 30 Nov 2025 17:26:22 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-josephus/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/math-and-geometry/the-josephus-problem"&gt;ByteByteGo: Josephus&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;With an array:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def josephus(n: int, k: int) -&amp;gt; int:
 circle = list(range(n))
 victim = 0
 # [0, 1, 2, 3, 4]
 # ^
 #
 # clockwise: victim &amp;#43;= 1
 #
 # next victim: victim &amp;#43; k - 1 (remember to mod)

 while len(circle) &amp;gt; 1:
 victim = (victim &amp;#43; (k - 1)) % len(circle)
 del circle[victim]

 return circle[0]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With a linked list (&lt;code&gt;deque&lt;/code&gt;):&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

def josephus(n: int, k: int) -&amp;gt; int:
 circle = deque(range(n))
 victim = 0
 # [0, 1, 2, 3, 4]
 # ^
 #
 # clockwise: victim &amp;#43;= 1
 #
 # next victim: victim &amp;#43; k - 1 (remember to mod)

 while len(circle) &amp;gt; 1:
 victim = (victim &amp;#43; (k - 1)) % len(circle)
 del circle[victim]

 return circle[0]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With a linked list, efficient removals from the end (beginning) of the list:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from collections import deque

def josephus(n: int, k: int) -&amp;gt; int:
 circle = deque(range(n))

 while len(circle) &amp;gt; 1:
 # rotate left so that the k‚Äëth person becomes the leftmost element
 # deque.rotate moves elements to the right; negative rotates left
 circle.rotate(-(k - 1))

 # eliminate that person
 circle.popleft()

 return circle[0]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Josephus"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Spiral Traversal</title><link>https://perrotta.dev/2025/11/bytebytego-spiral-traversal/</link><pubDate>Sun, 30 Nov 2025 16:49:27 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-spiral-traversal/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/math-and-geometry/spiral-traversal"&gt;ByteByteGo: Spiral Traversal&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def spiral_matrix(matrix: List[List[int]]) -&amp;gt; List[int]:
 ans = []

 start = (0, 0)
 end = (len(matrix), len(matrix[0]))

 def debian_once(start, end):
 for j in range(start[1], end[1]):
 ans.append(matrix[start[0]][j])

 for i in range(start[0] &amp;#43; 1, end[0] - 1):
 ans.append(matrix[i][end[1] - 1])

 if end[0] - 1 &amp;gt; start[0]:
 for j in range(end[1] - 1, start[1] - 1, -1):
 ans.append(matrix[end[0] - 1][j])

 if end[1] - 1 &amp;gt; start[1]:
 for i in range(end[0] - 1 - 1, start[1], -1):
 ans.append(matrix[i][start[1]])

 # while start[0] &amp;lt; end[0] and start[1] &amp;lt; end[1]:
 # while all(start[i] &amp;lt; end[i] for i in range(len(start))):
 while all(x &amp;lt; y for (x, y) in zip(start, end)):
 debian_once(start, end)
 start = tuple(el &amp;#43; 1 for el in start)
 end = tuple(el - 1 for el in end)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Beware of not doing &lt;code&gt;&amp;lt;-&lt;/code&gt; (leftwards) and &lt;code&gt;^&lt;/code&gt; (upwards) whenever there&amp;rsquo;s a single
column or a single row!&lt;/p&gt;
&lt;p&gt;Or, changing the meaning of &lt;code&gt;end&lt;/code&gt; by shifting one cell diagonally inwards
(inclusive):&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def spiral_matrix(matrix: List[List[int]]) -&amp;gt; List[int]:
 ans = []

 start = (0, 0)
 end = (len(matrix) - 1, len(matrix[0]) - 1)

 def debian_once(start, end):
 for j in range(start[1], end[1] &amp;#43; 1):
 ans.append(matrix[start[0]][j])

 for i in range(start[0] &amp;#43; 1, end[0]):
 ans.append(matrix[i][end[1]])

 if start[0] &amp;lt; end[0]:
 for j in range(end[1], start[1] - 1, -1):
 ans.append(matrix[end[0]][j])

 if start[1] &amp;lt; end[1]:
 for i in range(end[0] - 1, start[1], -1):
 ans.append(matrix[i][start[1]])

 # while start[0] &amp;lt;= end[0] and start[1] &amp;lt;= end[1]:
 # while all(start[i] &amp;lt;= end[i] for i in range(len(start))):
 while all(x &amp;lt;= y for (x, y) in zip(start, end)):
 debian_once(start, end)
 start = tuple(el &amp;#43; 1 for el in start)
 end = tuple(el - 1 for el in end)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Spiral Traversal"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Combinations of a Sum</title><link>https://perrotta.dev/2025/11/bytebytego-combinations-of-a-sum/</link><pubDate>Sun, 30 Nov 2025 14:58:14 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-combinations-of-a-sum/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/backtracking/combinations-of-a-sum"&gt;ByteByteGo: Combinations of a Sum&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Initial solution, wrong:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;Input: nums = [1, 2, 3], target = 4
Output: [[1,1,1,1],[1,1,2],[1,2,1],[1,3],[2,1,1],[2,2],[3,1]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def combinations_of_sum_k(nums: List[int], target: int) -&amp;gt; List[List[int]]:
 ans = []

 def backtrack(candidate = [], target = target):
 if target &amp;lt; 0:
 return

 if target == 0:
 ans.append(candidate[:])
 return

 for num in nums:
 # include num
 candidate.append(num)
 backtrack(candidate, target - num)
 candidate.pop()

 # do not include num
 continue

 backtrack()

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;It is incorrect because it includes certain combinations multiple times e.g.
&lt;code&gt;[1,1,2]&lt;/code&gt;, &lt;code&gt;[1,2,1]&lt;/code&gt;, &lt;code&gt;[2,1,1]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The key insight is, upon moving to the next &lt;code&gt;num&lt;/code&gt; in &lt;code&gt;nums&lt;/code&gt;, not to include the
entire &lt;code&gt;nums&lt;/code&gt; list during the backtracking, but rather only from the index
corresponding to &lt;code&gt;num&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Final solution, correct:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;Input: nums = [1, 2, 3], target = 4
Output: [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2]]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def combinations_of_sum_k(nums: List[int], target: int) -&amp;gt; List[List[int]]:
 ans = []

 def backtrack(nums = nums, candidate = [], target = target):
 if target &amp;lt; 0:
 return

 if target == 0:
 ans.append(candidate[:])
 return

 for i, num in enumerate(nums):
 # include num
 candidate.append(num)
 backtrack(nums[i:], candidate, target - num)
 candidate.pop()

 # do not include num
 continue

 backtrack()

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Combinations of a Sum"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Find All Subsets</title><link>https://perrotta.dev/2025/11/bytebytego-find-all-subsets/</link><pubDate>Sun, 30 Nov 2025 14:42:17 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-find-all-subsets/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/backtracking/find-all-subsets"&gt;ByteByteGo: Find All Subsets&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def find_all_subsets(nums: List[int]) -&amp;gt; List[List[int]]:
 ans = []

 def backtrack(nums = nums, candidate = []):
 if not nums:
 ans.append(candidate[:])
 return

 num = nums[0]

 # or do include num
 candidate.append(num)
 backtrack(nums[1:], candidate)
 candidate.pop()

 # either do not include num
 backtrack(nums[1:], candidate)


 backtrack()

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;It&amp;rsquo;s also possible to do it with a single recursion:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def find_all_subsets(nums: List[int]) -&amp;gt; List[List[int]]:
 ans = []

 def backtrack(start, candidate):
 # Every point in the recursion represents a valid subset
 ans.append(candidate[:])

 for i in range(start, len(nums)):
 candidate.append(nums[i]) # include nums[i]
 backtrack(i &amp;#43; 1, candidate) # recurse on the rest
 candidate.pop() # backtrack

 backtrack(0, [])

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Find All Subsets"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Find All Permutations</title><link>https://perrotta.dev/2025/11/bytebytego-find-all-permutations/</link><pubDate>Sun, 30 Nov 2025 14:02:35 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-find-all-permutations/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/backtracking/find-all-permutations"&gt;ByteByteGo: Find All Permutations&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def find_all_permutations(nums: List[int]) -&amp;gt; List[List[int]]:
 ans = []

 def backtrack(candidate = [], visited = set()):
 if len(candidate) == len(nums):
 ans.append(candidate[:])
 return

 for num in nums:
 if num not in visited:
 candidate.append(num)
 visited.add(num)

 backtrack(candidate, visited)

 candidate.pop()
 visited.remove(num)


 backtrack()

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;If we do not make a copy of candidate (&lt;code&gt;candidate[:]&lt;/code&gt;), &lt;code&gt;ans&lt;/code&gt; will be a mess.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Find All Permutations"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Hamming Weights of Integers</title><link>https://perrotta.dev/2025/11/bytebytego-hamming-weights-of-integers/</link><pubDate>Thu, 27 Nov 2025 03:09:16 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-hamming-weights-of-integers/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/bit-manipulation/hamming-weights-of-integers"&gt;ByteByteGo: Hamming Weights of Integers&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Did someone say something about variable scoping? Poor &lt;code&gt;n&lt;/code&gt; is overworked.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def hamming_weights_of_integers(n: int) -&amp;gt; List[int]:
 def hammer(n):
 ans = 0
 while n &amp;gt; 0:
 ans &amp;#43;= n &amp;amp; 1
 n &amp;gt;&amp;gt;= 1
 return ans

 return [hammer(n) for n in range(n &amp;#43; 1)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With top-down dynamic programming, linear:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def hamming_weights_of_integers(n: int) -&amp;gt; List[int]:
 from functools import lru_cache

 @lru_cache(maxsize=None)
 def hammer(n):
 if n in [0, 1]:
 return n

 return hammer(n &amp;gt;&amp;gt; 1) &amp;#43; (n &amp;amp; 1)

 return [hammer(n) for n in range(n &amp;#43; 1)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;With bottom-up dynamic programming, linear:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def hamming_weights_of_integers(n: int) -&amp;gt; List[int]:
 from functools import lru_cache

 if n == 0:
 return [0]

 hammer = [0] * (n &amp;#43; 1)
 hammer[0] = 0
 hammer[1] = 1

 for x in range(2, n &amp;#43; 1):
 hammer[x] = hammer[x &amp;gt;&amp;gt; 1] &amp;#43; (x &amp;amp; 1)

 return hammer&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Hamming Weights of Integers"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Swap Odd and Even Bits</title><link>https://perrotta.dev/2025/11/bytebytego-swap-odd-and-even-bits/</link><pubDate>Thu, 27 Nov 2025 03:06:15 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-swap-odd-and-even-bits/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/bit-manipulation/swap-odd-and-even-bits"&gt;ByteByteGo: Swap Odd and Even Bits&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def swap_odd_and_even_bits(n: int) -&amp;gt; int:
 ans = 0
 shift = 0

 while n &amp;gt; 0:
 ans &amp;#43;= ((n &amp;amp; 0b01) &amp;lt;&amp;lt; 1) &amp;#43; ((n &amp;amp; 0b10) &amp;gt;&amp;gt; 1) &amp;lt;&amp;lt; shift
 n &amp;gt;&amp;gt;= 2
 shift &amp;#43;= 2

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Swap Odd and Even Bits"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Lonely Integer</title><link>https://perrotta.dev/2025/11/bytebytego-lonely-integer/</link><pubDate>Thu, 27 Nov 2025 02:58:33 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-lonely-integer/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/bit-manipulation/lonely-integer"&gt;ByteByteGo: Lonely Integer&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List
from functools import reduce

def lonely_integer(nums: List[int]) -&amp;gt; int:
 return reduce(lambda x, y: x ^ y, nums)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;If you forget how to call &lt;code&gt;reduce&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List
from functools import reduce

def lonely_integer(nums: List[int]) -&amp;gt; int:
 ans = 0
 for num in nums:
 ans ^= num
 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Lonely Integer"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Maximum Subarray Sum</title><link>https://perrotta.dev/2025/11/bytebytego-maximum-subarray-sum/</link><pubDate>Thu, 27 Nov 2025 02:51:23 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-maximum-subarray-sum/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/dynamic-programming/maximum-subarray-sum"&gt;ByteByteGo: Maximum Subarray Sum&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def maximum_subarray_sum(nums: List[int]) -&amp;gt; int:
 from functools import lru_cache

 @lru_cache(maxsize=None)
 def solve(i, must_take=False):
 if i &amp;lt; 0:
 return 0

 if i == 0:
 if must_take:
 return max(0, nums[i])
 else:
 return nums[i]

 take = nums[i] &amp;#43; solve(i - 1, True)
 if must_take:
 return max(0, take)

 skip = solve(i - 1)
 return max(take, skip)

 return solve(len(nums) - 1)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Maximum Subarray Sum"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: 0/1 Knapsack</title><link>https://perrotta.dev/2025/11/bytebytego-0/1-knapsack/</link><pubDate>Wed, 26 Nov 2025 22:06:31 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-0/1-knapsack/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/dynamic-programming/01-knapsack"&gt;ByteByteGo: 0/1 Knapsack&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def knapsack(k: int, weights: List[int], values: List[int]) -&amp;gt; int:
 from functools import lru_cache

 assert len(weights) == len(values)

 @lru_cache(maxsize=None)
 def solve(i, k):
 assert i &amp;gt;= 0

 if i == 0:
 if weights[i] &amp;lt;= k:
 return values[i]
 else:
 return 0

 if k &amp;lt;= 0:
 return 0

 skip = solve(i - 1, k)

 take = 0
 if weights[i] &amp;lt;= k:
 take = values[i] &amp;#43; solve(i - 1, k - weights[i])

 return max(skip, take)

 return solve(len(weights) - 1, k)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: 0/1 Knapsack"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Neighborhood Burglary</title><link>https://perrotta.dev/2025/11/bytebytego-neighborhood-burglary/</link><pubDate>Wed, 26 Nov 2025 21:17:39 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-neighborhood-burglary/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/dynamic-programming/neighborhood-burglary"&gt;ByteByteGo: Neighborhood Burglary&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def neighborhood_burglary(houses: List[int]) -&amp;gt; int:
 from functools import lru_cache

 @lru_cache(maxsize=None)
 def solve(i):
 # 0 to n - 1
 assert i &amp;gt;= 0

 if i == 0:
 return houses[0]

 if i == 1:
 return max(houses[0], houses[1])

 return max(
 houses[i] &amp;#43; solve(i - 2),
 solve(i - 1),
 )

 return solve(len(houses) - 1)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Neighborhood Burglary"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Matrix Pathways</title><link>https://perrotta.dev/2025/11/bytebytego-matrix-pathways/</link><pubDate>Wed, 26 Nov 2025 21:01:40 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-matrix-pathways/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/dynamic-programming/matrix-pathways"&gt;ByteByteGo: Matrix Pathways&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def matrix_pathways(m: int, n: int) -&amp;gt; int:
 from functools import lru_cache

 @lru_cache(maxsize=None)
 def solve(m, n):
 # from 1 to m, from 1 to n
 assert (m, n) &amp;gt;= (0, 0)

 if m == 0 or n == 0:
 return 0

 if m == 1 and n == 1:
 return 1

 return solve(m - 1, n) &amp;#43; solve(m, n - 1)

 return solve(m, n)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Matrix Pathways"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Kth Largest Integer</title><link>https://perrotta.dev/2025/11/bytebytego-kth-largest-integer/</link><pubDate>Wed, 26 Nov 2025 18:11:54 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-kth-largest-integer/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/sort-and-search/kth-largest-integer"&gt;ByteByteGo: Kth Largest Integer&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Sort with &lt;code&gt;reverse=True&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def kth_largest_integer(nums: List[int], k: int) -&amp;gt; int:
 s = sorted(set(nums), reverse=True)

 if len(s) == 1:
 return list(s)[0]

 return list(s)[k - 1 % len(nums)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Sort with &lt;code&gt;reversed&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def kth_largest_integer(nums: List[int], k: int) -&amp;gt; int:
 s = list(reversed(list(sorted(set(nums)))))

 if len(s) == 1:
 return list(s)[0]

 return list(s)[k - 1 % len(nums)]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Forego reversion, index from the end of the list instead:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def kth_largest_integer(nums: List[int], k: int) -&amp;gt; int:
 s = sorted(set(nums))

 if len(s) == 1:
 return list(s)[0]

 return list(s)[len(nums) - k]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Kth Largest Integer"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Reverse 32-Bit Integer</title><link>https://perrotta.dev/2025/11/bytebytego-reverse-32-bit-integer/</link><pubDate>Wed, 26 Nov 2025 15:06:17 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-reverse-32-bit-integer/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/math-and-geometry/reverse-32-bit-integer"&gt;ByteByteGo: Reverse 32-Bit Integer&lt;/a&gt;:&lt;/p&gt;
&lt;h2 id="strings"&gt;Strings&lt;/h2&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def reverse_32_bit_integer(n: int) -&amp;gt; int:
 ans = &amp;#34;&amp;#34;

 s = str(n)[::-1]

 # 420
 # 024

 # -15
 # 51-

 is_negative = n &amp;lt; 0
 is_beginning = True

 for i, c in enumerate(s):
 if i == (len(s) - 1) and is_negative:
 continue

 if c == &amp;#39;0&amp;#39; and is_beginning:
 continue

 ans &amp;#43;= c

 is_beginning = False

 ans = int(ans) * (-1 if is_negative else 1)

 return ans if (-1 * 2**31 &amp;lt;= ans &amp;lt;= 2**31 - 1) else 0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id="numbers"&gt;Numbers&lt;/h2&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def reverse_32_bit_integer(n: int) -&amp;gt; int:
 ans = 0
 is_negative = -1 if n &amp;lt; 0 else 1
 n = abs(n)

 while n != 0:
 digit = n % 10
 n //= 10

 # Check for overflow: positive
 if ans &amp;gt; (2**31 - 1) // 10:
 return 0

 ans = ans * 10 &amp;#43; digit

 return is_negative * ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Reverse 32-Bit Integer"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Dutch National Flag</title><link>https://perrotta.dev/2025/11/bytebytego-dutch-national-flag/</link><pubDate>Wed, 26 Nov 2025 14:03:26 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-dutch-national-flag/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/sort-and-search/dutch-national-flag"&gt;ByteByteGo: Dutch National Flag&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Cheat, O(n log n) time:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List
from collections import defaultdict

def dutch_national_flag(nums: List[int]) -&amp;gt; None:
 nums.sort()&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;O(n) time, O(1) storage:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List
from collections import defaultdict

def dutch_national_flag(nums: List[int]) -&amp;gt; None:
 c = defaultdict(int)

 for num in nums:
 c[num] &amp;#43;= 1

 order = sorted(c.keys())

 for i in range(len(nums)):
 for ins in order:
 if c[ins] &amp;gt; 0:
 nums[i] = ins
 c[ins] -= 1
 break&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Clean:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def dutch_national_flag(nums: List[int]) -&amp;gt; None:
 &amp;#34;&amp;#34;&amp;#34;
 In-place sort of array containing only 0,1,2 using the three-pointer method.
 Time: O(n), Space: O(1)
 &amp;#34;&amp;#34;&amp;#34;
 left = 0
 mid = 0
 right = len(nums) - 1

 while mid &amp;lt;= right:
 if nums[mid] == 0:
 nums[left], nums[mid] = nums[mid], nums[left]
 left &amp;#43;= 1
 mid &amp;#43;= 1
 elif nums[mid] == 1:
 mid &amp;#43;= 1
 else: # nums[mid] == 2
 nums[mid], nums[right] = nums[right], nums[mid]
 right -= 1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Dutch National Flag"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Find the Insertion Index</title><link>https://perrotta.dev/2025/11/bytebytego-find-the-insertion-index/</link><pubDate>Wed, 26 Nov 2025 13:48:52 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-find-the-insertion-index/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/binary-search/find-the-insertion-index"&gt;ByteByteGo: Find the Insertion Index&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def find_the_insertion_index(nums: List[int], target: int) -&amp;gt; int:
 if len(nums) == 0:
 return 0

 left = 0
 right = len(nums) - 1
 assert right &amp;gt;= left

 while left &amp;lt; right:
 mid = left &amp;#43; ((right - left) // 2)

 if nums[mid] == target:
 return mid

 elif nums[mid] &amp;lt; target:
 left = mid &amp;#43; 1

 else:
 right = mid - 1

 if nums[left] &amp;lt; target:
 return left &amp;#43; 1
 else:
 return left&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Elegant:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;import bisect
from typing import List

def find_the_insertion_index(nums: List[int], target: int) -&amp;gt; int:
 return bisect.bisect_left(nums, target)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Find the Insertion Index"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Minimum Coin Combination</title><link>https://perrotta.dev/2025/11/bytebytego-minimum-coin-combination/</link><pubDate>Wed, 26 Nov 2025 13:28:33 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-minimum-coin-combination/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/dynamic-programming/minimum-coin-combination"&gt;ByteByteGo: Minimum Coin Combination&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;-1&lt;/code&gt; return requirement makes it a bit ugly.&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List
from functools import lru_cache

def min_coin_combination(coins: List[int], target: int) -&amp;gt; int:
 @lru_cache(maxsize=None)
 def solve(i, target):
 if i &amp;lt; 0 or target &amp;lt; 0:
 if target == 0:
 return 0
 else:
 return -1

 q1 = solve(i, target - coins[i])
 q2 = solve(i - 1, target)

 if q1 != -1 and q2 != -1:
 return min(
 q1 &amp;#43; 1,
 q2,
 )
 if q1 != -1:
 return q1 &amp;#43; 1
 if q2 != -1:
 return q2

 return -1

 return solve(len(coins) - 1, target)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Minimum Coin Combination"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Repeated Removal of Adjacent Duplicates</title><link>https://perrotta.dev/2025/11/bytebytego-repeated-removal-of-adjacent-duplicates/</link><pubDate>Tue, 25 Nov 2025 21:45:48 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-repeated-removal-of-adjacent-duplicates/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/stacks/repeated-removal-of-adjacent-duplicates"&gt;ByteByteGo: Repeated Removal of Adjacent Duplicates&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def repeated_removal_of_adjacent_duplicates(s: str) -&amp;gt; str:
 stack = []

 for c in s:
 if len(stack) == 0 or stack[-1] != c:
 stack.append(c)
 elif stack[-1] == c:
 stack.pop()

 return &amp;#39;&amp;#39;.join(stack)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Repeated Removal of Adjacent Duplicates"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Valid Parenthesis Expression</title><link>https://perrotta.dev/2025/11/bytebytego-valid-parenthesis-expression/</link><pubDate>Tue, 25 Nov 2025 21:39:15 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-valid-parenthesis-expression/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/stacks/valid-parenthesis-expression"&gt;ByteByteGo: Valid Parenthesis Expression&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def valid_parenthesis_expression(s: str) -&amp;gt; bool:
 stack = []

 for c in s:
 if c in &amp;#39;([{&amp;#39;:
 stack.append(c)

 if len(stack) == 0:
 return False

 if c == &amp;#39;)&amp;#39;:
 if stack.pop() != &amp;#39;(&amp;#39;:
 return False

 if c == &amp;#39;]&amp;#39;:
 if stack.pop() != &amp;#39;[&amp;#39;:
 return False

 if c == &amp;#39;}&amp;#39;:
 if stack.pop() != &amp;#39;{&amp;#39;:
 return False

 return len(stack) == 0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Refinement:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def valid_parenthesis_expression(s: str) -&amp;gt; bool:
 stack = []

 ass = {
 &amp;#39;)&amp;#39;: &amp;#39;(&amp;#39;,
 &amp;#39;]&amp;#39;: &amp;#39;[&amp;#39;,
 &amp;#39;}&amp;#39;: &amp;#39;{&amp;#39;,
 }

 for c in s:
 if c in &amp;#39;([{&amp;#39;:
 stack.append(c)

 if len(stack) == 0:
 return False

 if c in &amp;#39;)]}&amp;#39;:
 if stack.pop() != ass[c]:
 return False

 return len(stack) == 0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Valid Parenthesis Expression"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Linked List Reversal</title><link>https://perrotta.dev/2025/11/bytebytego-linked-list-reversal/</link><pubDate>Tue, 25 Nov 2025 21:18:56 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-linked-list-reversal/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/linked-lists/linked-list-reversal"&gt;ByteByteGo: Linked List Reversal&lt;/a&gt;:&lt;/p&gt;
&lt;h2 id="recursive"&gt;Recursive&lt;/h2&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from ds import ListNode

&amp;#34;&amp;#34;&amp;#34;
Definition of ListNode:
class ListNode:
 def __init__(self, val=None, next=None):
 self.val = val
 self.next = next
&amp;#34;&amp;#34;&amp;#34;

def linked_list_reversal(head: ListNode) -&amp;gt; ListNode:
 if head is None or head.next is None:
 return head

 new_head = linked_list_reversal(head.next)

 head.next.next = head
 head.next = None

 return new_head&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id="iterative"&gt;Iterative&lt;/h2&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from ds import ListNode

&amp;#34;&amp;#34;&amp;#34;
Definition of ListNode:
class ListNode:
 def __init__(self, val=None, next=None):
 self.val = val
 self.next = next
&amp;#34;&amp;#34;&amp;#34;

def linked_list_reversal(head: ListNode) -&amp;gt; ListNode:
 if head is None or head.next is None:
 return head

 prev = None

 while head is not None:
 next_node = head.next

 head.next = prev

 prev = head
 head = next_node

 return prev&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Linked List Reversal"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Invert Binary Tree</title><link>https://perrotta.dev/2025/11/bytebytego-invert-binary-tree/</link><pubDate>Tue, 25 Nov 2025 00:36:17 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-invert-binary-tree/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/trees/invert-binary-tree"&gt;ByteByteGo: Invert Binary Tree&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from ds import TreeNode

&amp;#34;&amp;#34;&amp;#34;
Definition of TreeNode:
class TreeNode:
 def __init__(self, val):
 self.val = val
 self.left = None
 self.right = None
&amp;#34;&amp;#34;&amp;#34;

def invert_binary_tree(root: TreeNode) -&amp;gt; TreeNode:
 if root is None:
 return None

 root.left, root.right = root.right, root.left

 invert_binary_tree(root.left)
 invert_binary_tree(root.right)

 return root&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The following &lt;strong&gt;DOES NOT&lt;/strong&gt; work:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from ds import TreeNode

&amp;#34;&amp;#34;&amp;#34;
Definition of TreeNode:
class TreeNode:
 def __init__(self, val):
 self.val = val
 self.left = None
 self.right = None
&amp;#34;&amp;#34;&amp;#34;

def invert_binary_tree(root: TreeNode) -&amp;gt; TreeNode:
 if root is None:
 return None

 root.left = invert_binary_tree(root.right)
 root.right = invert_binary_tree(root.left)

 return root&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;The swap must happen simultaneously. The following works:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from ds import TreeNode

&amp;#34;&amp;#34;&amp;#34;
Definition of TreeNode:
class TreeNode:
 def __init__(self, val):
 self.val = val
 self.left = None
 self.right = None
&amp;#34;&amp;#34;&amp;#34;

def invert_binary_tree(root: TreeNode) -&amp;gt; TreeNode:
 if root is None:
 return None

 root.left, root.right = invert_binary_tree(root.right), invert_binary_tree(root.left)

 return root&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Invert Binary Tree"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Climbing Stairs</title><link>https://perrotta.dev/2025/11/bytebytego-climbing-stairs/</link><pubDate>Tue, 25 Nov 2025 00:27:38 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-climbing-stairs/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/dynamic-programming/climbing-stairs"&gt;ByteByteGo: Climbing Stairs&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;Top-down DP:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def climbing_stairs(n: int) -&amp;gt; int:
 from functools import lru_cache

 @lru_cache(maxsize=None)
 def cs(n):
 &amp;#34;&amp;#34;&amp;#34;How many possibilities for n steps?&amp;#34;&amp;#34;&amp;#34;
 assert n &amp;gt;= 0

 if n in [0, 1, 2]:
 return n

 return cs(n-1) &amp;#43; cs(n-2)

 return cs(n)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Their Python environment is quite old (3.8). Goodness.&lt;/p&gt;
&lt;p&gt;We can only do &lt;code&gt;from functools import cache&lt;/code&gt; &lt;a href="https://stackoverflow.com/questions/66846743/importerror-cannot-import-name-cache-from-functools"&gt;from Python
3.9+&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Bottom-up DP:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;def climbing_stairs(n: int) -&amp;gt; int:
 dp = [None] * n

 dp[0] = 1
 dp[1] = 2

 for i in range(2, n):
 dp[i] = dp[i - 1] &amp;#43; dp[i - 2]

 return dp[n - 1]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Climbing Stairs"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Zero Striping</title><link>https://perrotta.dev/2025/11/bytebytego-zero-striping/</link><pubDate>Tue, 25 Nov 2025 00:13:43 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-zero-striping/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/hash-maps-and-sets/zero-striping"&gt;ByteByteGo: Zero Striping&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def zero_striping(matrix: List[List[int]]) -&amp;gt; None:
 row_set = set()
 col_set = set()

 for x in range(len(matrix)):
 for y in range(len(matrix[0])):
 c = matrix[x][y]

 if c == 0:
 row_set.add(x)
 col_set.add(y)

 for x in range(len(matrix)):
 for y in range(len(matrix[0])):
 if x in row_set or y in col_set:
 matrix[x][y] = 0&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Zero Striping"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Verify Sudoku Board</title><link>https://perrotta.dev/2025/11/bytebytego-verify-sudoku-board/</link><pubDate>Mon, 24 Nov 2025 22:09:17 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-verify-sudoku-board/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/hash-maps-and-sets/verify-sudoku-board"&gt;ByteByteGo: Verify Sudoku Board&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def verify_sudoku_board(board: List[List[int]]) -&amp;gt; bool:
 row_sets = [set() for _ in range(9)]
 col_sets = [set() for _ in range(9)]
 grid_sets = [[set() for _ in range(3)] for _ in range(3)]

 for x in range(len(board)):
 for y in range(len(board[0])):
 c = board[x][y]
 if c == 0:
 continue

 if c in row_sets[x]:
 return False
 else:
 row_sets[x].add(c)

 if c in col_sets[y]:
 return False
 else:
 col_sets[y].add(c)

 if c in grid_sets[x // 3][y // 3]:
 return False
 else:
 grid_sets[x // 3][y // 3].add(c)

 return True&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Verify Sudoku Board"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Longest Chain of Consecutive Numbers</title><link>https://perrotta.dev/2025/11/bytebytego-longest-chain-of-consecutive-numbers/</link><pubDate>Mon, 24 Nov 2025 00:41:57 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-longest-chain-of-consecutive-numbers/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/hash-maps-and-sets/longest-chain-of-consecutive-numbers"&gt;ByteByteGo: Longest Chain of Consecutive Numbers&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def longest_chain_of_consecutive_numbers(nums: List[int]) -&amp;gt; int:
 nums.sort()

 ans = 0

 size = 0
 last = None

 for n in nums:
 if last is None:
 last = n
 size = 1
 elif n == last &amp;#43; 1:
 last = n
 size &amp;#43;= 1
 elif n == last: # alternatively: put nums in a set
 continue
 else:
 last = n
 size = 1
 ans = max(ans, size)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Alternative:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def longest_chain_of_consecutive_numbers(nums: List[int]) -&amp;gt; int:
 ans = 0

 size = 0
 last = None

 for n in sorted(set(nums)):
 if last is None:
 last = n
 size = 1
 elif n == last &amp;#43; 1:
 last = n
 size &amp;#43;= 1
 else:
 last = n
 size = 1
 ans = max(ans, size)

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Longest Chain of Consecutive Numbers"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Shift Zeros to the End</title><link>https://perrotta.dev/2025/11/bytebytego-shift-zeros-to-the-end/</link><pubDate>Sun, 23 Nov 2025 18:16:40 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-shift-zeros-to-the-end/</guid><description>&lt;p&gt;&lt;a href="https://perrotta.dev/2025/09/leetcode-%23283-move-zeroes/"&gt;Same as LeetCode #283&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/two-pointers/shift-zeros-to-the-end"&gt;ByteByteGo: Shift Zeros to the End&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def shift_zeros_to_the_end(nums: List[int]) -&amp;gt; None:
 j = None

 for i, num in enumerate(nums):
 if num != 0:
 if j is not None:
 assert j &amp;lt; i
 nums[i], nums[j] = nums[j], nums[i]
 j &amp;#43;= 1
 else:
 if j is None:
 j = i&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Simplified version:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def shift_zeros_to_the_end(nums: List[int]) -&amp;gt; None:
 j = 0

 for i, num in enumerate(nums):
 if num != 0:
 nums[i], nums[j] = nums[j], nums[i]
 j &amp;#43;= 1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Shift Zeros to the End"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Largest Container</title><link>https://perrotta.dev/2025/11/bytebytego-largest-container/</link><pubDate>Sun, 23 Nov 2025 17:09:59 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-largest-container/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/two-pointers/largest-container"&gt;ByteByteGo: Largest Container&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def largest_container(heights: List[int]) -&amp;gt; int:
 left = 0
 right = len(heights) - 1

 ans = 0

 def area(left, right):
 assert 0 &amp;lt;= left &amp;lt; len(heights)
 assert 0 &amp;lt;= right &amp;lt; len(heights)

 return (right - left) * min(heights[left], heights[right])

 while left &amp;lt; right:
 myarea = area(left, right)
 ans = max(ans, myarea)

 if heights[left] &amp;lt; heights[left &amp;#43; 1]:
 left &amp;#43;= 1
 elif heights[right - 1] &amp;gt; heights[right]:
 right -= 1
 else:
 left &amp;#43;= 1
 right -= 1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Converge two pointers inwards. No mystery.&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Largest Container"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Triplet Sum</title><link>https://perrotta.dev/2025/11/bytebytego-triplet-sum/</link><pubDate>Sun, 23 Nov 2025 17:00:21 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-triplet-sum/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/two-pointers/triplet-sum"&gt;ByteByteGo: Triplet Sum&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def triplet_sum(nums: List[int]) -&amp;gt; List[List[int]]:
 sequence = sorted(nums)

 ans = []

 for ia, a in enumerate(sequence):
 if a &amp;gt; 0: # positive numbers cannot add up to zero
 break

 if ia &amp;gt; 0 and sequence[ia - 1] == sequence[ia]: # prevent duplicates
 continue

 ib = ia &amp;#43; 1
 ic = len(sequence) - 1

 while ib &amp;lt; ic:
 b = sequence[ib]
 c = sequence[ic]

 target = -a
 if (b &amp;#43; c) == target:
 ans.append([a, b, c])
 ib &amp;#43;= 1
 ic -= 1

 # keep going, preventing duplicates
 while ib &amp;lt; ic and sequence[ib - 1] == sequence[ib]:
 ib &amp;#43;= 1
 while ib &amp;lt; ic and sequence[ic &amp;#43; 1] == sequence[ic]:
 ic -= 1
 elif (b &amp;#43; c) &amp;lt; target:
 ib &amp;#43;= 1
 else:
 ic -=1

 return ans&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Time complexity: O(n^2)&lt;/p&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Triplet Sum"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item><item><title>ByteByteGo: Pair Sum - Unsorted</title><link>https://perrotta.dev/2025/11/bytebytego-pair-sum-unsorted/</link><pubDate>Sat, 22 Nov 2025 19:28:06 -0300</pubDate><author>serendipity@perrotta.dev (Thiago Perrotta)</author><category>coding</category><category>bytebytego</category><category>dev</category><guid>https://perrotta.dev/2025/11/bytebytego-pair-sum-unsorted/</guid><description>&lt;p&gt;&lt;a href="https://bytebytego.com/exercises/coding-patterns/hash-maps-and-sets/pair-sum-unsorted"&gt;ByteByteGo: Pair Sum ‚Äî Unsorted&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def pair_sum_unsorted(nums: List[int], target: int) -&amp;gt; List[int]:
 # Option 1: sort it and do two pointers.
 # Option 2: hash map.
 d = {}
 for i, num in enumerate(nums):
 d[num] = i

 for i, num in enumerate(nums):
 if (target - num) in d.keys():
 j = d[target - num]
 if i != j:
 return [i, j]

 return []&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Be careful not to pick the same index twice.&lt;/p&gt;
&lt;p&gt;Simpler way to construct the hash map: a dict comprehension:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;d = {num: i for i, num in enumerate(nums)}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Fancier:&lt;/p&gt;
&lt;div class="codeblock" data-lang="python"&gt;
 &lt;div class="codeblock-header"&gt;
 &lt;span class="codeblock-language"&gt;python&lt;/span&gt;
 &lt;/div&gt;
 &lt;pre&gt;&lt;code class="language-python"&gt;d = dict(zip(nums, range(len(nums))))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;‚Äî ¬ß ‚Äî&lt;/p&gt;&lt;p&gt;Reply via &lt;a href="mailto:serendipity@perrotta.dev?subject=Reply to: ByteByteGo: Pair Sum - Unsorted"&gt;email&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href="https://perrotta.dev/tags/bytebytego/"&gt;#bytebytego&lt;/a&gt; &lt;a href="https://perrotta.dev/tags/dev/"&gt;#dev&lt;/a&gt;&lt;/p&gt;</description></item></channel></rss>